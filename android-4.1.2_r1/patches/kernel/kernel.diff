From 045e20356295e2a9228b641e9742af9c1d09fb55 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Sun, 23 Sep 2012 01:17:09 -0400
Subject: [PATCH 01/72] eventlogging: create double buffers and empty procfs.

---
 kernel/Makefile               |  1 +
 kernel/eventlogging/Makefile  |  1 +
 kernel/eventlogging/buffer.c  | 51 +++++++++++++++++++++++++++++++++++++++++++
 kernel/eventlogging/buffer.h  | 26 ++++++++++++++++++++++
 kernel/eventlogging/events.h  | 38 ++++++++++++++++++++++++++++++++
 kernel/eventlogging/logging.c | 35 +++++++++++++++++++++++++++++
 kernel/eventlogging/proc_fs.c | 44 +++++++++++++++++++++++++++++++++++++
 kernel/eventlogging/proc_fs.h |  8 +++++++
 8 files changed, 204 insertions(+)
 create mode 100644 kernel/eventlogging/Makefile
 create mode 100644 kernel/eventlogging/buffer.c
 create mode 100644 kernel/eventlogging/buffer.h
 create mode 100644 kernel/eventlogging/events.h
 create mode 100644 kernel/eventlogging/logging.c
 create mode 100644 kernel/eventlogging/proc_fs.c
 create mode 100644 kernel/eventlogging/proc_fs.h

diff --git a/kernel/Makefile b/kernel/Makefile
index e4fd98b..9d5a515 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -73,6 +73,7 @@ obj-$(CONFIG_AUDITSYSCALL) += auditsc.o
 obj-$(CONFIG_AUDIT_WATCH) += audit_watch.o
 obj-$(CONFIG_AUDIT_TREE) += audit_tree.o
 obj-$(CONFIG_GCOV_KERNEL) += gcov/
+obj-y += eventlogging/
 obj-$(CONFIG_KPROBES) += kprobes.o
 obj-$(CONFIG_KGDB) += debug/
 obj-$(CONFIG_DETECT_HUNG_TASK) += hung_task.o
diff --git a/kernel/eventlogging/Makefile b/kernel/eventlogging/Makefile
new file mode 100644
index 0000000..0d05db2
--- /dev/null
+++ b/kernel/eventlogging/Makefile
@@ -0,0 +1 @@
+obj-y := logging.o proc_fs.o buffer.o
diff --git a/kernel/eventlogging/buffer.c b/kernel/eventlogging/buffer.c
new file mode 100644
index 0000000..b9a2c31
--- /dev/null
+++ b/kernel/eventlogging/buffer.c
@@ -0,0 +1,51 @@
+#include "buffer.h"
+#include <linux/gfp.h>
+#include <linux/bootmem.h>
+
+int sbuffer_init(struct sbuffer* buf, int order) {
+  void* addr;
+
+  /* Use bootmem allocator, because get_free_pages is limited to less
+     than 2^12 pages.  alloc_bootmem will panic if it fails, but we
+     leave the error handling code in case we switch to a saner memory
+     allocator.*/
+  addr = alloc_bootmem((1 << order) * PAGE_SIZE);
+  if (!addr)
+    goto err;
+
+  buf->order = order;
+  buf->start = addr;
+  buf->end   = addr + (1 << order) * PAGE_SIZE;
+  buf->cur   = addr;
+  
+  return 0;
+
+ err:
+  return -ENOMEM;
+}
+
+void sbuffer_free(struct sbuffer* buf) {
+  // Can't free bootmem and kernel will have paniced anyway.
+  // Keep this method in case we migrate to a bette memory allocator
+  // than bootmem.
+}
+
+int dbuffer_init(struct dbuffer* buf, int order) {
+  int ret;
+
+  ret = sbuffer_init(&buf->one, order);
+  if (ret)
+    goto err1;
+
+  ret = sbuffer_init(&buf->two, order);
+  if (ret)
+    goto err2;
+
+  spin_lock_init(&buf->lock);
+  return 0;
+
+ err2:
+  sbuffer_free(&buf->one);
+ err1:
+  return ret;
+}
diff --git a/kernel/eventlogging/buffer.h b/kernel/eventlogging/buffer.h
new file mode 100644
index 0000000..132a9ae
--- /dev/null
+++ b/kernel/eventlogging/buffer.h
@@ -0,0 +1,26 @@
+#ifndef EVENT_LOGGING_BUFFER_H
+#define EVENT_LOGGING_BUFFER_H
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+
+struct sbuffer {
+  int order;   // order of page allocation (2^order pages)
+  void* start; // starting address
+  void* end;   // last address in buffer
+  void* cur;   // pointer to next free byte
+};
+
+struct dbuffer {
+  struct sbuffer one;
+  struct sbuffer two;
+  spinlock_t lock;
+};
+
+int sbuffer_init(struct sbuffer* buf, int order);
+void sbuffer_free(struct sbuffer* buf);
+
+int dbuffer_init(struct dbuffer* buf, int order);
+
+#endif
diff --git a/kernel/eventlogging/events.h b/kernel/eventlogging/events.h
new file mode 100644
index 0000000..cda64fa
--- /dev/null
+++ b/kernel/eventlogging/events.h
@@ -0,0 +1,38 @@
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#define EVENT_CONTEXT_SWITCH 10
+#define EVENT_FORK 15
+
+#define EVENT_IO_BLOCK 20
+#define EVENT_IO_RESUME 21
+
+#define EVENT_NETWORK_BLOCK 30
+#define EVENT_NETWORK_RESUME 31
+
+#define EVENT_SEMAPHORE_LOCK 40
+#define EVENT_SEMAPHORE_WAIT 41
+
+#define EVENT_MUTEX_LOCK 50
+#define EVENT_MUTEX_WAIT 51
+
+#define EVENT_IPC_LOCK 60
+#define EVENT_IPC_WAIT 11
+
+struct event_hdr {
+  u8  event_type;
+  __le32 timestamp_s;
+  __le32 timestamp_us;
+  u8     proc;
+  __le16 pid;
+};
+
+struct context_switch_event {
+  struct event_hdr hdr;
+  __le16 old_pid;
+  __le16 new_pid;
+};
+
+struct network_block_event {
+  struct event_hdr hdr;
+};
diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
new file mode 100644
index 0000000..d097c7c
--- /dev/null
+++ b/kernel/eventlogging/logging.c
@@ -0,0 +1,35 @@
+#include <linux/cpumask.h>
+#include <linux/percpu.h>
+#include <linux/gfp.h>
+
+#include "buffer.h"
+#include "proc_fs.h"
+
+#define BUFFER_ORDER 12 // 2^12 = 16 MB with 4096 page size
+
+static DEFINE_PER_CPU(struct dbuffer, buffers);
+
+static __init int init_alloc_buffers(void) {
+  int ret = 0;
+
+  int cpu;
+  for_each_cpu(cpu, cpu_possible_mask) {
+    ret = dbuffer_init(&per_cpu(buffers, cpu), BUFFER_ORDER);
+    if (ret)
+      goto err;
+
+    printk("eventlogging: Allocated buffer for CPU %d\n", cpu);
+  }
+  return 0;
+
+ err:
+  printk("eventlogging: Failed to allocate buffer for CPU %d\n", cpu);
+  return ret;
+}
+
+static __init int init_proc_fs(void) {
+  return event_logging_create_pfs();
+}
+
+early_initcall(init_alloc_buffers);
+fs_initcall(init_proc_fs);
diff --git a/kernel/eventlogging/proc_fs.c b/kernel/eventlogging/proc_fs.c
new file mode 100644
index 0000000..26a2f5e
--- /dev/null
+++ b/kernel/eventlogging/proc_fs.c
@@ -0,0 +1,44 @@
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include "proc_fs.h"
+
+#define PFS_NAME "event_logging"
+#define PFS_PERMS S_IFREG|S_IROTH|S_IRGRP|S_IRUSR
+static struct proc_dir_entry* el_pfs_entry;
+
+DECLARE_WAIT_QUEUE_HEAD(el_pfs_queue);
+
+int event_logging_create_pfs(void) {
+  el_pfs_entry = create_proc_entry(PFS_NAME, PFS_PERMS, NULL);
+  if (!el_pfs_entry)
+    goto err;
+  
+  el_pfs_entry->uid = 0;
+  el_pfs_entry->gid = 0;
+  el_pfs_entry->read_proc = event_logging_read_pfs;
+  el_pfs_entry->write_proc = NULL;
+  return 0;
+
+ err:
+  return -EINVAL;
+}
+
+void event_logging_remove_pfs(void) {
+  remove_proc_entry(PFS_NAME, NULL);
+}
+
+int event_logging_read_pfs(char* page, char** start, off_t off, int count, int* eof, void* data) {
+  int len = 0;
+
+  *start = page;
+  *eof = 1;
+
+  while (len == 0) {
+    if ( wait_event_interruptible(el_pfs_queue, 0) )
+      return -ERESTARTSYS;
+
+    len = 0;
+  }
+
+  return len;
+}
diff --git a/kernel/eventlogging/proc_fs.h b/kernel/eventlogging/proc_fs.h
new file mode 100644
index 0000000..390eb3c
--- /dev/null
+++ b/kernel/eventlogging/proc_fs.h
@@ -0,0 +1,8 @@
+#ifndef EVENT_LOGGING_PROC_FS_H
+#define EVENT_LOGGING_PROC_FS_H
+
+int event_logging_create_pfs(void);
+void event_logging_remove_pfs(void);
+int event_logging_read_pfs(char* buffer, char** start, off_t offset, int len, int* eof, void* data);
+
+#endif
-- 
1.9.1


From 5f747bcee7c4fea8c7bfcc4e377fc2e282759be5 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 07:04:31 -0400
Subject: [PATCH 02/72] eventlogging: add to kbuild

---
 kernel/eventlogging/Kconfig | 9 +++++++++
 lib/Kconfig.debug           | 1 +
 2 files changed, 10 insertions(+)
 create mode 100644 kernel/eventlogging/Kconfig

diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
new file mode 100644
index 0000000..d8935ad
--- /dev/null
+++ b/kernel/eventlogging/Kconfig
@@ -0,0 +1,9 @@
+#
+# Event logging framework for Lide Zhang and David Bild.
+#
+#
+
+menuconfig EVENT_LOGGING
+        bool "Event Logging Zhang/Bild"
+        help
+          Event tracing framework for Lide Zhang and David Bild.
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index c6b006a..c38c2c4 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -1109,6 +1109,7 @@ config SYSCTL_SYSCALL_CHECK
 
 source mm/Kconfig.debug
 source kernel/trace/Kconfig
+source kernel/eventlogging/Kconfig
 
 config PROVIDE_OHCI1394_DMA_INIT
 	bool "Remote debugging over FireWire early on boot"
-- 
1.9.1


From 187d33c189c5041e7c1cbb3c9e5d11873590c9ea Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 07:34:44 -0400
Subject: [PATCH 03/72] eventlogging: change from double buffers to buffer
 queues.

---
 include/eventlogging/events.h |  61 +++++++++++++++
 kernel/eventlogging/Makefile  |   2 +-
 kernel/eventlogging/buffer.c  | 168 +++++++++++++++++++++++++++++++++++-------
 kernel/eventlogging/buffer.h  |  30 +++++---
 kernel/eventlogging/events.c  |  57 ++++++++++++++
 kernel/eventlogging/events.h  |  38 ----------
 kernel/eventlogging/logging.c |  72 ++++++++++++++++--
 kernel/eventlogging/logging.h |   8 ++
 kernel/eventlogging/proc_fs.c |  20 +++--
 kernel/eventlogging/proc_fs.h |   4 +-
 10 files changed, 369 insertions(+), 91 deletions(-)
 create mode 100644 include/eventlogging/events.h
 create mode 100644 kernel/eventlogging/events.c
 delete mode 100644 kernel/eventlogging/events.h
 create mode 100644 kernel/eventlogging/logging.h

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
new file mode 100644
index 0000000..39c45a0
--- /dev/null
+++ b/include/eventlogging/events.h
@@ -0,0 +1,61 @@
+#ifndef EVENTLOGGING_EVENTS_H
+#define EVENTLOGGING_EVENTS_H
+
+#include <linux/types.h>
+
+#define EVENT_CONTEXT_SWITCH 10
+#define EVENT_FORK 15
+
+#define EVENT_IO_BLOCK 20
+#define EVENT_IO_RESUME 21
+
+#define EVENT_NETWORK_BLOCK 30
+#define EVENT_NETWORK_RESUME 31
+
+#define EVENT_SEMAPHORE_LOCK 40
+#define EVENT_SEMAPHORE_WAIT 41
+
+#define EVENT_MUTEX_LOCK 50
+#define EVENT_MUTEX_WAIT 51
+
+#define EVENT_IPC_LOCK 60
+#define EVENT_IPC_WAIT 11
+
+struct event_hdr {
+  __u8  event_type;
+  __u8  cpu;
+  __le32 tv_sec;
+  __le32 tv_usec;
+  __le16 pid;
+}__attribute__((packed));
+
+struct context_switch_event {
+  struct event_hdr hdr;
+  __le16 old_pid;
+  __le16 new_pid;
+}__attribute__((packed));
+
+struct fork_event {
+  struct event_hdr hdr;
+  __le16 pid;
+  __le16 tgid;
+}__attribute__((packed));
+
+struct network_block_event {
+  struct event_hdr hdr;
+}__attribute__((packed));
+
+struct network_resume_event {
+  struct event_hdr hdr;
+}__attribute__((packed));
+
+#ifdef __KERNEL__
+void event_log_header_init(struct event_hdr* event, u8 type);
+void event_log_simple(u8 event_type);
+void event_log_context_switch(pid_t old, pid_t new);
+void event_log_network_block(void);
+void event_log_network_resume(void);
+void event_log_fork(pid_t pid, pid_t tgid);
+#endif
+
+#endif
diff --git a/kernel/eventlogging/Makefile b/kernel/eventlogging/Makefile
index 0d05db2..b57a43f 100644
--- a/kernel/eventlogging/Makefile
+++ b/kernel/eventlogging/Makefile
@@ -1 +1 @@
-obj-y := logging.o proc_fs.o buffer.o
+obj-$(CONFIG_EVENT_LOGGING) := logging.o proc_fs.o buffer.o events.o
diff --git a/kernel/eventlogging/buffer.c b/kernel/eventlogging/buffer.c
index b9a2c31..9f3314e 100644
--- a/kernel/eventlogging/buffer.c
+++ b/kernel/eventlogging/buffer.c
@@ -1,23 +1,33 @@
-#include "buffer.h"
-#include <linux/gfp.h>
 #include <linux/bootmem.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/gfp.h>
+
+#include "buffer.h"
+
+static DEFINE_SPINLOCK(empty_lock);
+static LIST_HEAD(empty_list);
 
-int sbuffer_init(struct sbuffer* buf, int order) {
+static DEFINE_SPINLOCK(full_lock);
+static LIST_HEAD(full_list);
+
+static DECLARE_WAIT_QUEUE_HEAD(full_wait);
+
+// max order is likely 10 or 11
+int sbuffer_init(struct sbuffer* buf, unsigned int order) {
   void* addr;
 
-  /* Use bootmem allocator, because get_free_pages is limited to less
-     than 2^12 pages.  alloc_bootmem will panic if it fails, but we
-     leave the error handling code in case we switch to a saner memory
-     allocator.*/
-  addr = alloc_bootmem((1 << order) * PAGE_SIZE);
+  addr = (void*) __get_free_pages(GFP_ATOMIC, order);
   if (!addr)
     goto err;
 
+  INIT_LIST_HEAD(&buf->list);
   buf->order = order;
   buf->start = addr;
   buf->end   = addr + (1 << order) * PAGE_SIZE;
-  buf->cur   = addr;
-  
+  buf->rp    = addr;
+  buf->wp    = addr;
   return 0;
 
  err:
@@ -25,27 +35,133 @@ int sbuffer_init(struct sbuffer* buf, int order) {
 }
 
 void sbuffer_free(struct sbuffer* buf) {
-  // Can't free bootmem and kernel will have paniced anyway.
-  // Keep this method in case we migrate to a bette memory allocator
-  // than bootmem.
+  free_pages((unsigned long) buf->start, buf->order);
 }
 
-int dbuffer_init(struct dbuffer* buf, int order) {
-  int ret;
+void sbuffer_clear(struct sbuffer* buf) {
+  buf->rp = buf->start;
+  buf->wp = buf->start;
+}
 
-  ret = sbuffer_init(&buf->one, order);
-  if (ret)
-    goto err1;
+int sbuffer_avail(struct sbuffer* buf) {
+  return (buf->end - buf->wp);
+}
 
-  ret = sbuffer_init(&buf->two, order);
-  if (ret)
-    goto err2;
+int sbuffer_write(struct sbuffer* buf, char* page, int count) {
+  if (sbuffer_avail(buf) < count)
+    return 0;
+  memcpy(buf->wp, page, count);
+  buf->wp += count;
+  return count;
+}
 
-  spin_lock_init(&buf->lock);
-  return 0;
+int sbuffer_empty(struct sbuffer* buf) {
+  return (buf->rp == buf->wp);
+}
+
+int sbuffer_read(struct sbuffer* buf, char* page, int count) {
+  int len, num;
+  int avail;
+  
+  len = 0;
+  avail = buf->wp - buf->rp;
+  num = min(count, avail);
+
+  if (num > 0) {
+    memcpy(page, buf->rp, num);
+    buf->rp += num;
+    len += num;
+  }
+
+  return len;
+}
+
+void put_empty(struct sbuffer* buf) {
+  unsigned long flags;
+  spin_lock_irqsave(&empty_lock, flags);
+  list_add(&buf->list, &empty_list);
+  spin_unlock_irqrestore(&empty_lock, flags);
+}
 
- err2:
-  sbuffer_free(&buf->one);
- err1:
+void put_full(struct sbuffer* buf) {
+  unsigned long flags;
+  spin_lock_irqsave(&full_lock, flags);
+  list_add_tail(&buf->list, &full_list);
+  spin_unlock_irqrestore(&full_lock, flags);
+  wake_up_interruptible(&full_wait);
+}
+
+struct sbuffer* take_empty_try(void) {
+  struct sbuffer* ret = NULL;
+  unsigned long flags;
+  spin_lock_irqsave(&empty_lock, flags);
+  if (0 == list_empty(&empty_list)) {
+    ret = list_entry(empty_list.next, struct sbuffer, list);
+    list_del_init(&ret->list);
+  }
+  spin_unlock_irqrestore(&empty_lock, flags);
   return ret;
 }
+
+struct sbuffer* __peek_full(void) {
+  if (0 == list_empty(&full_list))
+    return list_entry(full_list.next, struct sbuffer, list);
+  else
+    return NULL;
+}
+
+struct sbuffer* __take_full(void) {
+  struct sbuffer* ret;
+  ret = list_entry(full_list.next, struct sbuffer, list);
+  list_del_init(&ret->list);
+  return ret;
+}
+
+void recycle_if_empty(void) {
+  struct sbuffer* buf;
+  unsigned long flags;
+
+  spin_lock_irqsave(&full_lock, flags);
+  buf = __peek_full();
+  if (NULL == buf)
+    goto not_empty;
+  if (0 == sbuffer_empty(buf))
+    goto not_empty;
+  buf = __take_full();
+  spin_unlock_irqrestore(&full_lock, flags);
+  
+  sbuffer_clear(buf);
+  put_empty(buf);
+  return;
+
+ not_empty:
+  spin_unlock_irqrestore(&full_lock, flags);
+}
+
+int __full_list_empty(void) {
+  int ret;
+  unsigned long flags;
+  spin_lock_irqsave(&full_lock, flags);
+  ret = list_empty(&full_list);
+  spin_unlock_irqrestore(&full_lock, flags);
+  return ret;
+}
+
+/*
+ * Returns, but does not remove, the head of the list of full buffers.
+ * If the list is empty, block until a buffer is available.  Will
+ * return NULL if the waiting process is interrupted while waiting.
+ */
+struct sbuffer* peek_full_blocking(void) {
+  struct sbuffer* ret = NULL;
+  unsigned long flags;
+  do {
+    spin_lock_irqsave(&full_lock, flags);
+    ret = __peek_full();
+    spin_unlock_irqrestore(&full_lock, flags);
+  } while ( NULL == ret && 
+	    0 == wait_event_interruptible(full_wait, 0 == __full_list_empty()) );
+  return ret;
+}
+
+
diff --git a/kernel/eventlogging/buffer.h b/kernel/eventlogging/buffer.h
index 132a9ae..703b1a3 100644
--- a/kernel/eventlogging/buffer.h
+++ b/kernel/eventlogging/buffer.h
@@ -1,26 +1,34 @@
 #ifndef EVENT_LOGGING_BUFFER_H
 #define EVENT_LOGGING_BUFFER_H
 
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/spinlock.h>
+#include <linux/list.h>
 
 struct sbuffer {
+  struct list_head list;
   int order;   // order of page allocation (2^order pages)
   void* start; // starting address
   void* end;   // last address in buffer
-  void* cur;   // pointer to next free byte
+  void* rp;    // pointer to next byte to read
+  void* wp;    // pointer to next byte writer
 };
 
-struct dbuffer {
-  struct sbuffer one;
-  struct sbuffer two;
-  spinlock_t lock;
-};
+void sbuffer_print_empty(void);
 
-int sbuffer_init(struct sbuffer* buf, int order);
+int sbuffer_init(struct sbuffer* buf, unsigned int order);
 void sbuffer_free(struct sbuffer* buf);
 
-int dbuffer_init(struct dbuffer* buf, int order);
+void sbuffer_clear(struct sbuffer* buf);
+int sbuffer_avail(struct sbuffer* buf); // how much space to write?
+int sbuffer_write(struct sbuffer* buf, char* page, int count);
+int sbuffer_empty(struct sbuffer* buf); // any data to read?
+int sbuffer_read(struct sbuffer* buf, char* page, int count);
+
+
+void put_empty(struct sbuffer* buf);
+void put_full(struct sbuffer* buf);
+
+struct sbuffer* take_empty_try(void);
+struct sbuffer* peek_full_blocking(void);
+void recycle_if_empty(void); // move from full to empty, if empty
 
 #endif
diff --git a/kernel/eventlogging/events.c b/kernel/eventlogging/events.c
new file mode 100644
index 0000000..54280af
--- /dev/null
+++ b/kernel/eventlogging/events.c
@@ -0,0 +1,57 @@
+#include <linux/time.h>
+#include <linux/sched.h>
+#include <linux/smp.h>
+
+#include <eventlogging/events.h>
+#include "logging.h"
+
+void event_log_header_init(struct event_hdr* event, u8 type) {
+  struct timeval tv;
+  do_gettimeofday(&tv);
+
+  event->event_type = type;
+  event->tv_sec = tv.tv_sec;
+  event->tv_usec = tv.tv_usec;
+  event->cpu = smp_processor_id();
+  event->pid = current->pid;
+}
+
+void event_log_simple(u8 event_type) {
+  unsigned long flags;
+  struct event_hdr event;
+  local_irq_save(flags);
+  event_log_header_init(&event, event_type);
+  log_event(&event, sizeof(struct event_hdr));
+  local_irq_restore(flags);
+}
+
+void event_log_context_switch(pid_t old, pid_t new) {
+  unsigned long flags;
+  struct context_switch_event event;
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_CONTEXT_SWITCH);
+  event.old_pid = old;
+  event.new_pid = new;
+  log_event(&event, sizeof(struct context_switch_event));
+  local_irq_restore(flags);
+}
+
+void event_log_network_block(void) {
+  event_log_simple(EVENT_NETWORK_BLOCK);
+}
+
+void event_log_network_resume(void) {
+  event_log_simple(EVENT_NETWORK_RESUME);
+}
+
+void event_log_fork(pid_t pid, pid_t tgid) {
+  unsigned long flags;
+  struct fork_event event;
+  
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_FORK);
+  event.pid = pid;
+  event.tgid = tgid;
+  log_event(&event, sizeof(struct fork_event));
+  local_irq_restore(flags);
+}
diff --git a/kernel/eventlogging/events.h b/kernel/eventlogging/events.h
deleted file mode 100644
index cda64fa..0000000
--- a/kernel/eventlogging/events.h
+++ /dev/null
@@ -1,38 +0,0 @@
-#include <linux/types.h>
-#include <linux/kernel.h>
-
-#define EVENT_CONTEXT_SWITCH 10
-#define EVENT_FORK 15
-
-#define EVENT_IO_BLOCK 20
-#define EVENT_IO_RESUME 21
-
-#define EVENT_NETWORK_BLOCK 30
-#define EVENT_NETWORK_RESUME 31
-
-#define EVENT_SEMAPHORE_LOCK 40
-#define EVENT_SEMAPHORE_WAIT 41
-
-#define EVENT_MUTEX_LOCK 50
-#define EVENT_MUTEX_WAIT 51
-
-#define EVENT_IPC_LOCK 60
-#define EVENT_IPC_WAIT 11
-
-struct event_hdr {
-  u8  event_type;
-  __le32 timestamp_s;
-  __le32 timestamp_us;
-  u8     proc;
-  __le16 pid;
-};
-
-struct context_switch_event {
-  struct event_hdr hdr;
-  __le16 old_pid;
-  __le16 new_pid;
-};
-
-struct network_block_event {
-  struct event_hdr hdr;
-};
diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index d097c7c..470fbf8 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -1,29 +1,85 @@
 #include <linux/cpumask.h>
 #include <linux/percpu.h>
-#include <linux/gfp.h>
+#include <linux/slab.h>
 
+#include "logging.h"
 #include "buffer.h"
 #include "proc_fs.h"
 
-#define BUFFER_ORDER 12 // 2^12 = 16 MB with 4096 page size
+// 2^12 = 16 MB with 4096 page size
+#define BUFFER_ORDER 2
 
-static DEFINE_PER_CPU(struct dbuffer, buffers);
+static DEFINE_PER_CPU(struct sbuffer*, sbuffers);
+static DEFINE_PER_CPU(unsigned int, missed_events);
+
+static struct sbuffer* __get_cpu_buffer(void) {
+  struct sbuffer* buf = __get_cpu_var(sbuffers);
+  if (NULL == buf) {
+    buf = take_empty_try();
+    __get_cpu_var(sbuffers) = buf;
+  }
+  return buf;
+}
+
+static struct sbuffer* __flush_cpu_buffer(void) {
+  put_full(__get_cpu_var(sbuffers));
+  __get_cpu_var(sbuffers) = NULL;
+  return __get_cpu_buffer();
+}
+
+void log_event(void* data, int len) {
+  struct sbuffer* buf;
+  unsigned long avail;
+
+  // Get buffer, if available
+  buf = __get_cpu_buffer();
+  if (NULL == buf) {
+    __get_cpu_var(missed_events)++;
+    return;
+  }
+
+  // Flush and replace buffer, if not enough room for new event
+  avail = sbuffer_avail(buf);
+  if (avail < len) {
+    buf = __flush_cpu_buffer();
+    if (NULL == buf) {
+      __get_cpu_var(missed_events)++;
+      return;
+    }
+  }
+  
+  // Write data
+  sbuffer_write(buf, data, len);
+}
 
 static __init int init_alloc_buffers(void) {
   int ret = 0;
 
   int cpu;
   for_each_cpu(cpu, cpu_possible_mask) {
-    ret = dbuffer_init(&per_cpu(buffers, cpu), BUFFER_ORDER);
-    if (ret)
-      goto err;
+    // Create two buffers, one to use now and one for the empty list
+    int i;
+    struct sbuffer* buf[2];
+    for (i = 0; i < 2; ++i) {
+      buf[i] = (struct sbuffer*) kmalloc(sizeof(struct sbuffer), GFP_ATOMIC);
+      if (0 == buf[i]) {
+	ret = -ENOMEM;
+	goto err;
+      }
+      sbuffer_init(buf[i], BUFFER_ORDER);
+    }
+
+    // Attach buffers
+    per_cpu(sbuffers, cpu) = buf[0];
+    put_empty(buf[1]);
 
-    printk("eventlogging: Allocated buffer for CPU %d\n", cpu);
+    printk("eventlogging: allocated buffers for CPU %d\n", cpu);
   }
+
   return 0;
 
  err:
-  printk("eventlogging: Failed to allocate buffer for CPU %d\n", cpu);
+  printk("eventlogging: failed to allocate buffer for CPU %d\n", cpu);
   return ret;
 }
 
diff --git a/kernel/eventlogging/logging.h b/kernel/eventlogging/logging.h
new file mode 100644
index 0000000..1d00aa6
--- /dev/null
+++ b/kernel/eventlogging/logging.h
@@ -0,0 +1,8 @@
+#ifndef EVENT_LOGGING_H
+#define EVENT_LOGGING_H
+
+#include "buffer.h"
+
+void log_event(void* data, int len);
+
+#endif
diff --git a/kernel/eventlogging/proc_fs.c b/kernel/eventlogging/proc_fs.c
index 26a2f5e..4f36863 100644
--- a/kernel/eventlogging/proc_fs.c
+++ b/kernel/eventlogging/proc_fs.c
@@ -1,13 +1,15 @@
 #include <linux/proc_fs.h>
 #include <linux/sched.h>
+#include <linux/list.h>
+
+#include "buffer.h"
 #include "proc_fs.h"
 
+
 #define PFS_NAME "event_logging"
 #define PFS_PERMS S_IFREG|S_IROTH|S_IRGRP|S_IRUSR
 static struct proc_dir_entry* el_pfs_entry;
 
-DECLARE_WAIT_QUEUE_HEAD(el_pfs_queue);
-
 int event_logging_create_pfs(void) {
   el_pfs_entry = create_proc_entry(PFS_NAME, PFS_PERMS, NULL);
   if (!el_pfs_entry)
@@ -28,17 +30,23 @@ void event_logging_remove_pfs(void) {
 }
 
 int event_logging_read_pfs(char* page, char** start, off_t off, int count, int* eof, void* data) {
-  int len = 0;
+  int len;
+  struct sbuffer* buf;
 
+  len = 0;
   *start = page;
   *eof = 1;
 
   while (len == 0) {
-    if ( wait_event_interruptible(el_pfs_queue, 0) )
+    buf = peek_full_blocking();
+    if (buf == NULL)
       return -ERESTARTSYS;
 
-    len = 0;
+    if (sbuffer_empty(buf)) 
+      recycle_if_empty();
+    else 
+      len += sbuffer_read(buf, page, count);
   }
-
+  
   return len;
 }
diff --git a/kernel/eventlogging/proc_fs.h b/kernel/eventlogging/proc_fs.h
index 390eb3c..a4138d1 100644
--- a/kernel/eventlogging/proc_fs.h
+++ b/kernel/eventlogging/proc_fs.h
@@ -1,8 +1,10 @@
 #ifndef EVENT_LOGGING_PROC_FS_H
 #define EVENT_LOGGING_PROC_FS_H
 
+#include "buffer.h"
+
 int event_logging_create_pfs(void);
 void event_logging_remove_pfs(void);
-int event_logging_read_pfs(char* buffer, char** start, off_t offset, int len, int* eof, void* data);
+int event_logging_read_pfs(char* page, char** start, off_t off, int count, int* eof, void* data);
 
 #endif
-- 
1.9.1


From 896ff38a9090e342a8c3742d06bf00d35424f3c3 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 07:37:47 -0400
Subject: [PATCH 04/72] eventlogging: log process forking.

---
 kernel/fork.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/kernel/fork.c b/kernel/fork.c
index 06909a9..ef684e8 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -69,6 +69,10 @@
 #include <linux/khugepaged.h>
 #include <linux/signalfd.h>
 
+#ifdef CONFIG_EVENT_LOGGING
+#include <eventlogging/events.h>
+#endif
+
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
@@ -1269,6 +1273,10 @@ static struct task_struct *copy_process(unsigned long clone_flags,
 	if (clone_flags & CLONE_THREAD)
 		p->tgid = current->tgid;
 
+#ifdef CONFIG_EVENT_LOGGING
+	event_log_fork(p->pid, p->tgid);
+#endif
+
 	p->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? child_tidptr : NULL;
 	/*
 	 * Clear TID on mm_release()?
-- 
1.9.1


From f49457572bd34d0a5293074eb2f52132903ac44c Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 07:53:01 -0400
Subject: [PATCH 05/72] eventlogging: log network blocks and resumes.

---
 include/eventlogging/events.h | 16 ++++++++++++----
 kernel/eventlogging/events.c  | 24 ++++++++++++++++++++----
 kernel/eventlogging/logging.c |  2 +-
 net/core/datagram.c           | 10 ++++++++++
 net/core/sock.c               | 10 ++++++++++
 net/core/stream.c             | 10 ++++++++++
 6 files changed, 63 insertions(+), 9 deletions(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 39c45a0..c4141a4 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -9,8 +9,12 @@
 #define EVENT_IO_BLOCK 20
 #define EVENT_IO_RESUME 21
 
-#define EVENT_NETWORK_BLOCK 30
-#define EVENT_NETWORK_RESUME 31
+#define EVENT_DATAGRAM_BLOCK 30
+#define EVENT_DATAGRAM_RESUME 31
+#define EVENT_STREAM_BLOCK 32
+#define EVENT_STREAM_RESUME 33
+#define EVENT_SOCK_BLOCK 34
+#define EVENT_SOCK_RESUME 35
 
 #define EVENT_SEMAPHORE_LOCK 40
 #define EVENT_SEMAPHORE_WAIT 41
@@ -53,8 +57,12 @@ struct network_resume_event {
 void event_log_header_init(struct event_hdr* event, u8 type);
 void event_log_simple(u8 event_type);
 void event_log_context_switch(pid_t old, pid_t new);
-void event_log_network_block(void);
-void event_log_network_resume(void);
+void event_log_datagram_block(void);
+void event_log_datagram_resume(void);
+void event_log_stream_block(void);
+void event_log_stream_resume(void);
+void event_log_sock_block(void);
+void event_log_sock_resume(void);
 void event_log_fork(pid_t pid, pid_t tgid);
 #endif
 
diff --git a/kernel/eventlogging/events.c b/kernel/eventlogging/events.c
index 54280af..5a63d7d 100644
--- a/kernel/eventlogging/events.c
+++ b/kernel/eventlogging/events.c
@@ -36,12 +36,28 @@ void event_log_context_switch(pid_t old, pid_t new) {
   local_irq_restore(flags);
 }
 
-void event_log_network_block(void) {
-  event_log_simple(EVENT_NETWORK_BLOCK);
+void event_log_datagram_block(void) {
+  event_log_simple(EVENT_DATAGRAM_BLOCK);
 }
 
-void event_log_network_resume(void) {
-  event_log_simple(EVENT_NETWORK_RESUME);
+void event_log_datagram_resume(void) {
+  event_log_simple(EVENT_DATAGRAM_RESUME);
+}
+
+void event_log_stream_block(void) {
+  event_log_simple(EVENT_STREAM_BLOCK);
+}
+
+void event_log_stream_resume(void) {
+  event_log_simple(EVENT_STREAM_RESUME);
+}
+
+void event_log_sock_block(void) {
+  event_log_simple(EVENT_SOCK_BLOCK);
+}
+
+void event_log_sock_resume(void) {
+  event_log_simple(EVENT_SOCK_RESUME);
 }
 
 void event_log_fork(pid_t pid, pid_t tgid) {
diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index 470fbf8..f516e29 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -7,7 +7,7 @@
 #include "proc_fs.h"
 
 // 2^12 = 16 MB with 4096 page size
-#define BUFFER_ORDER 2
+#define BUFFER_ORDER 1
 
 static DEFINE_PER_CPU(struct sbuffer*, sbuffers);
 static DEFINE_PER_CPU(unsigned int, missed_events);
diff --git a/net/core/datagram.c b/net/core/datagram.c
index 18ac112..e1ed3ad 100644
--- a/net/core/datagram.c
+++ b/net/core/datagram.c
@@ -58,6 +58,10 @@
 #include <net/tcp_states.h>
 #include <trace/events/skb.h>
 
+#ifdef CONFIG_EVENT_LOGGING
+#include <eventlogging/events.h>
+#endif
+
 /*
  *	Is a socket 'connection oriented' ?
  */
@@ -113,7 +117,13 @@ static int wait_for_packet(struct sock *sk, int *err, long *timeo_p)
 		goto interrupted;
 
 	error = 0;
+#ifdef CONFIG_EVENT_LOGGING
+	event_log_datagram_block();
+#endif
 	*timeo_p = schedule_timeout(*timeo_p);
+#ifdef CONFIG_EVENT_LOGGING
+	event_log_datagram_resume();
+#endif
 out:
 	finish_wait(sk_sleep(sk), &wait);
 	return error;
diff --git a/net/core/sock.c b/net/core/sock.c
index aebb419..a336dde 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -132,6 +132,10 @@
 #include <net/tcp.h>
 #endif
 
+#ifdef CONFIG_EVENT_LOGGING
+#include <eventlogging/events.h>
+#endif
+
 /*
  * Each address family might have different locking rules, so we have
  * one slock key per address family:
@@ -1657,7 +1661,13 @@ int sk_wait_data(struct sock *sk, long *timeo)
 
 	prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
 	set_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
+#ifdef CONFIG_EVENT_LOGGING
+	event_log_sock_block();
+#endif	
 	rc = sk_wait_event(sk, timeo, !skb_queue_empty(&sk->sk_receive_queue));
+#ifdef CONFIG_EVENT_LOGGING
+	event_log_sock_resume();
+#endif
 	clear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
 	finish_wait(sk_sleep(sk), &wait);
 	return rc;
diff --git a/net/core/stream.c b/net/core/stream.c
index f5df85d..1057214 100644
--- a/net/core/stream.c
+++ b/net/core/stream.c
@@ -19,6 +19,10 @@
 #include <linux/wait.h>
 #include <net/sock.h>
 
+#ifdef CONFIG_EVENT_LOGGING
+#include <eventlogging/events.h>
+#endif
+
 /**
  * sk_stream_write_space - stream socket write_space callback.
  * @sk: socket
@@ -71,10 +75,16 @@ int sk_stream_wait_connect(struct sock *sk, long *timeo_p)
 
 		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
 		sk->sk_write_pending++;
+#ifdef CONFIG_EVENT_LOGGING
+		event_log_stream_block();
+#endif
 		done = sk_wait_event(sk, timeo_p,
 				     !sk->sk_err &&
 				     !((1 << sk->sk_state) &
 				       ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)));
+#ifdef CONFIG_EVENT_LOGGING
+		event_log_stream_resume();
+#endif
 		finish_wait(sk_sleep(sk), &wait);
 		sk->sk_write_pending--;
 	} while (!done);
-- 
1.9.1


From 510638076367f150948f971824f1413d842d04d4 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 09:04:25 -0400
Subject: [PATCH 06/72] eventlogging: flush all buffers by writing to proc
 file.

---
 kernel/eventlogging/logging.c | 45 ++++++++++++++++++++++++++++++++++++++++++-
 kernel/eventlogging/logging.h |  1 +
 kernel/eventlogging/proc_fs.c | 11 +++++++++--
 kernel/eventlogging/proc_fs.h |  2 ++
 4 files changed, 56 insertions(+), 3 deletions(-)

diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index f516e29..274c9a8 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -1,5 +1,7 @@
 #include <linux/cpumask.h>
 #include <linux/percpu.h>
+#include <linux/smp.h>
+#include <linux/cpu.h>
 #include <linux/slab.h>
 
 #include "logging.h"
@@ -7,7 +9,7 @@
 #include "proc_fs.h"
 
 // 2^12 = 16 MB with 4096 page size
-#define BUFFER_ORDER 1
+#define BUFFER_ORDER 4
 
 static DEFINE_PER_CPU(struct sbuffer*, sbuffers);
 static DEFINE_PER_CPU(unsigned int, missed_events);
@@ -52,6 +54,47 @@ void log_event(void* data, int len) {
   sbuffer_write(buf, data, len);
 }
 
+/*
+ * Must be called with hotplugging disabled
+ * and 'cpu' offline.
+ */
+static void __flush_offline_cpu_buffer(int cpu) {
+  printk("eventlogging: flushing offline cpu: %d\n", cpu);
+  put_full(per_cpu(sbuffers, cpu));
+  per_cpu(sbuffers, cpu) = take_empty_try();
+}
+
+/*
+ * Must be called with hotplugging disabled.
+ */
+static void __flush_offline_cpus(void) {
+  int cpu;
+  for_each_cpu_not(cpu, cpu_online_mask) {
+    __flush_offline_cpu_buffer(cpu);
+  }
+}
+
+static void __flush_online_cpu(void* info) {
+  preempt_disable();
+  printk("eventlogging: flushing online cpu: %d\n", smp_processor_id());
+  __flush_cpu_buffer();
+  preempt_enable();
+}
+
+/*
+ * Might sleep, so must be called in sleepable context.
+ */
+void flush_all_cpus(void) {
+  get_online_cpus(); // Disable hotplugging
+  preempt_disable();
+
+  on_each_cpu(__flush_online_cpu, NULL, 1); // Only runs on online cpus
+  __flush_offline_cpus();
+
+  preempt_enable();
+  put_online_cpus(); // Enable hotplugging
+}
+
 static __init int init_alloc_buffers(void) {
   int ret = 0;
 
diff --git a/kernel/eventlogging/logging.h b/kernel/eventlogging/logging.h
index 1d00aa6..fbeb850 100644
--- a/kernel/eventlogging/logging.h
+++ b/kernel/eventlogging/logging.h
@@ -3,6 +3,7 @@
 
 #include "buffer.h"
 
+void flush_all_cpus(void);
 void log_event(void* data, int len);
 
 #endif
diff --git a/kernel/eventlogging/proc_fs.c b/kernel/eventlogging/proc_fs.c
index 4f36863..5ea069e 100644
--- a/kernel/eventlogging/proc_fs.c
+++ b/kernel/eventlogging/proc_fs.c
@@ -2,12 +2,13 @@
 #include <linux/sched.h>
 #include <linux/list.h>
 
+#include "logging.h"
 #include "buffer.h"
 #include "proc_fs.h"
 
 
 #define PFS_NAME "event_logging"
-#define PFS_PERMS S_IFREG|S_IROTH|S_IRGRP|S_IRUSR
+#define PFS_PERMS S_IFREG|S_IROTH|S_IRGRP|S_IRUSR|S_IWOTH|S_IWGRP|S_IWUSR
 static struct proc_dir_entry* el_pfs_entry;
 
 int event_logging_create_pfs(void) {
@@ -18,7 +19,7 @@ int event_logging_create_pfs(void) {
   el_pfs_entry->uid = 0;
   el_pfs_entry->gid = 0;
   el_pfs_entry->read_proc = event_logging_read_pfs;
-  el_pfs_entry->write_proc = NULL;
+  el_pfs_entry->write_proc = event_logging_write_pfs;
   return 0;
 
  err:
@@ -50,3 +51,9 @@ int event_logging_read_pfs(char* page, char** start, off_t off, int count, int*
   
   return len;
 }
+
+int event_logging_write_pfs(struct file* file, const char* buffer, unsigned long count, void *data) {
+  if (count > 0)
+    flush_all_cpus();
+  return count;
+}
diff --git a/kernel/eventlogging/proc_fs.h b/kernel/eventlogging/proc_fs.h
index a4138d1..879b3d9 100644
--- a/kernel/eventlogging/proc_fs.h
+++ b/kernel/eventlogging/proc_fs.h
@@ -1,10 +1,12 @@
 #ifndef EVENT_LOGGING_PROC_FS_H
 #define EVENT_LOGGING_PROC_FS_H
 
+#include <linux/proc_fs.h>
 #include "buffer.h"
 
 int event_logging_create_pfs(void);
 void event_logging_remove_pfs(void);
 int event_logging_read_pfs(char* page, char** start, off_t off, int count, int* eof, void* data);
+int event_logging_write_pfs(struct file* file, const char* buffer, unsigned long count, void* data);
 
 #endif
-- 
1.9.1


From 00935b40e46b04cac32ba8bb112f339cfa3a46f0 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 09:14:59 -0400
Subject: [PATCH 07/72] eventlogging: allocate buffers independent of number of
 cpus

---
 kernel/eventlogging/logging.c | 47 +++++++++++++++++++++----------------------
 1 file changed, 23 insertions(+), 24 deletions(-)

diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index 274c9a8..a721bdd 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -8,8 +8,8 @@
 #include "buffer.h"
 #include "proc_fs.h"
 
-// 2^12 = 16 MB with 4096 page size
-#define BUFFER_ORDER 4
+#define BUFFER_ORDER   10  // 2^10 = 4 MB with 4096 page size
+#define NUM_BUFFERS 32  // 32 * 4 MB = 128 MB total
 
 static DEFINE_PER_CPU(struct sbuffer*, sbuffers);
 static DEFINE_PER_CPU(unsigned int, missed_events);
@@ -96,34 +96,33 @@ void flush_all_cpus(void) {
 }
 
 static __init int init_alloc_buffers(void) {
-  int ret = 0;
-
-  int cpu;
-  for_each_cpu(cpu, cpu_possible_mask) {
-    // Create two buffers, one to use now and one for the empty list
-    int i;
-    struct sbuffer* buf[2];
-    for (i = 0; i < 2; ++i) {
-      buf[i] = (struct sbuffer*) kmalloc(sizeof(struct sbuffer), GFP_ATOMIC);
-      if (0 == buf[i]) {
-	ret = -ENOMEM;
-	goto err;
-      }
-      sbuffer_init(buf[i], BUFFER_ORDER);
+  int i, cpu;
+  int cnt = 0;
+  
+  /* Allocate all buffers */
+  for(i = 0; i < NUM_BUFFERS; ++i) {
+    struct sbuffer* buf;
+
+    buf = (struct sbuffer*) kmalloc(sizeof(struct sbuffer), GFP_ATOMIC);
+    if (0 == buf) {
+      printk("eventlogging: failed to allocate buffer\n");
+      continue;
     }
 
-    // Attach buffers
-    per_cpu(sbuffers, cpu) = buf[0];
-    put_empty(buf[1]);
+    ++cnt;
+    sbuffer_init(buf, BUFFER_ORDER);
+    put_empty(buf);
+  }
+  printk("eventlogging: allocated %d buffers\n", cnt);
+
 
-    printk("eventlogging: allocated buffers for CPU %d\n", cpu);
+  /* Attach buffer to each cpu */
+  for_each_cpu(cpu, cpu_possible_mask) {
+    per_cpu(sbuffers, cpu) = take_empty_try();
+    printk("eventlogging: attached buffer to CPU %d\n", cpu);
   }
 
   return 0;
-
- err:
-  printk("eventlogging: failed to allocate buffer for CPU %d\n", cpu);
-  return ret;
 }
 
 static __init int init_proc_fs(void) {
-- 
1.9.1


From 9029ff8bf975b592b78659e7aa0992591bf3e702 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 09:36:50 -0400
Subject: [PATCH 08/72] eventlogging: learn to log mutex lock/wait.

---
 include/eventlogging/events.h | 14 ++++++++++++++
 kernel/eventlogging/events.c  | 24 ++++++++++++++++++++++++
 kernel/mutex.c                | 10 ++++++++++
 3 files changed, 48 insertions(+)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index c4141a4..1640d8d 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -53,6 +53,18 @@ struct network_resume_event {
   struct event_hdr hdr;
 }__attribute__((packed));
 
+struct mutex_lock_event {
+  struct event_hdr hdr;
+  __le32 lock;
+}__attribute__((packed));
+
+struct mutex_wait_event {
+  struct event_hdr hdr;
+  __le32 lock;
+}__attribute__((packed));
+
+
+
 #ifdef __KERNEL__
 void event_log_header_init(struct event_hdr* event, u8 type);
 void event_log_simple(u8 event_type);
@@ -64,6 +76,8 @@ void event_log_stream_resume(void);
 void event_log_sock_block(void);
 void event_log_sock_resume(void);
 void event_log_fork(pid_t pid, pid_t tgid);
+void event_log_mutex_lock(void* lock);
+void event_log_mutex_wait(void* lock);
 #endif
 
 #endif
diff --git a/kernel/eventlogging/events.c b/kernel/eventlogging/events.c
index 5a63d7d..7d285e5 100644
--- a/kernel/eventlogging/events.c
+++ b/kernel/eventlogging/events.c
@@ -71,3 +71,27 @@ void event_log_fork(pid_t pid, pid_t tgid) {
   log_event(&event, sizeof(struct fork_event));
   local_irq_restore(flags);
 }
+
+void event_log_mutex_lock(void* lock) {
+  unsigned long flags;
+  struct mutex_lock_event event;
+
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_MUTEX_LOCK);
+  event.lock = (__le32) lock;
+  local_irq_restore(flags);
+}
+
+void event_log_mutex_wait(void* lock) {
+  unsigned long flags;
+  struct mutex_wait_event event;
+
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_MUTEX_WAIT);
+  event.lock = (__le32) lock;
+  local_irq_restore(flags);
+}
+
+
+
+
diff --git a/kernel/mutex.c b/kernel/mutex.c
index d607ed5..d26daa2 100644
--- a/kernel/mutex.c
+++ b/kernel/mutex.c
@@ -24,6 +24,10 @@
 #include <linux/interrupt.h>
 #include <linux/debug_locks.h>
 
+#ifdef CONFIG_EVENT_LOGGING
+#include <eventlogging/events.h>
+#endif
+
 /*
  * In the DEBUG case we are using the "NULL fastpath" for mutexes,
  * which forces all calls into the slowpath:
@@ -239,6 +243,9 @@ __mutex_lock_common(struct mutex *lock, long state, unsigned int subclass,
 		__set_task_state(task, state);
 
 		/* didn't get the lock, go to sleep: */
+#ifdef CONFIG_EVENT_LOGGING
+		event_log_mutex_wait(lock);
+#endif
 		spin_unlock_mutex(&lock->wait_lock, flags);
 		preempt_enable_no_resched();
 		schedule();
@@ -248,6 +255,9 @@ __mutex_lock_common(struct mutex *lock, long state, unsigned int subclass,
 
 done:
 	lock_acquired(&lock->dep_map, ip);
+#ifdef CONFIG_EVENT_LOGGING
+	event_log_mutex_lock(lock);
+#endif
 	/* got the lock - rejoice! */
 	mutex_remove_waiter(lock, &waiter, current_thread_info());
 	mutex_set_owner(lock);
-- 
1.9.1


From 7ca0ca39185ec6b4638ef86e39186fb2e09199b6 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 10:00:36 -0400
Subject: [PATCH 09/72] eventlogging: learn to log semaphore lock/wait

---
 include/eventlogging/events.h | 12 ++++++++++-
 kernel/eventlogging/events.c  | 24 +++++++++++++++++++++
 kernel/semaphore.c            | 50 +++++++++++++++++++++++++++++++++++--------
 3 files changed, 76 insertions(+), 10 deletions(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 1640d8d..9d90545 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -63,7 +63,15 @@ struct mutex_wait_event {
   __le32 lock;
 }__attribute__((packed));
 
+struct sem_lock_event {
+  struct event_hdr hdr;
+  __le32 lock;
+}__attribute__((packed));
 
+struct sem_wait_event {
+  struct event_hdr hdr;
+  __le32 lock;
+}__attribute__((packed));
 
 #ifdef __KERNEL__
 void event_log_header_init(struct event_hdr* event, u8 type);
@@ -77,7 +85,9 @@ void event_log_sock_block(void);
 void event_log_sock_resume(void);
 void event_log_fork(pid_t pid, pid_t tgid);
 void event_log_mutex_lock(void* lock);
-void event_log_mutex_wait(void* lock);
+void event_log_mutex_wait(void* lock);;
+void event_log_sem_lock(void* lock);
+void event_log_sem_wait(void* lock);
 #endif
 
 #endif
diff --git a/kernel/eventlogging/events.c b/kernel/eventlogging/events.c
index 7d285e5..a911124 100644
--- a/kernel/eventlogging/events.c
+++ b/kernel/eventlogging/events.c
@@ -79,6 +79,7 @@ void event_log_mutex_lock(void* lock) {
   local_irq_save(flags);
   event_log_header_init(&event.hdr, EVENT_MUTEX_LOCK);
   event.lock = (__le32) lock;
+  log_event(&event, sizeof(struct mutex_lock_event));
   local_irq_restore(flags);
 }
 
@@ -89,6 +90,29 @@ void event_log_mutex_wait(void* lock) {
   local_irq_save(flags);
   event_log_header_init(&event.hdr, EVENT_MUTEX_WAIT);
   event.lock = (__le32) lock;
+  log_event(&event, sizeof(struct mutex_wait_event));
+  local_irq_restore(flags);
+}
+
+void event_log_sem_lock(void* lock) {
+  unsigned long flags;
+  struct sem_lock_event event;
+
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_SEMAPHORE_LOCK);
+  event.lock = (__le32) lock;
+  log_event(&event, sizeof(struct sem_lock_event));
+  local_irq_restore(flags);
+}
+
+void event_log_sem_wait(void* lock) {
+  unsigned long flags;
+  struct sem_wait_event event;
+
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_SEMAPHORE_WAIT);
+  event.lock = (__le32) lock;
+  log_event(&event, sizeof(struct sem_wait_event));
   local_irq_restore(flags);
 }
 
diff --git a/kernel/semaphore.c b/kernel/semaphore.c
index 94a62c0..12a48b9 100644
--- a/kernel/semaphore.c
+++ b/kernel/semaphore.c
@@ -33,6 +33,10 @@
 #include <linux/spinlock.h>
 #include <linux/ftrace.h>
 
+#ifdef CONFIG_EVENT_LOGGING
+#include <eventlogging/events.h>
+#endif
+
 static noinline void __down(struct semaphore *sem);
 static noinline int __down_interruptible(struct semaphore *sem);
 static noinline int __down_killable(struct semaphore *sem);
@@ -55,10 +59,15 @@ void down(struct semaphore *sem)
 	unsigned long flags;
 
 	spin_lock_irqsave(&sem->lock, flags);
-	if (likely(sem->count > 0))
+	if (likely(sem->count > 0)) {
+#ifdef CONFIG_EVENT_LOGGING
+	  event_log_sem_lock(sem);
+#endif
 		sem->count--;
-	else
+	}
+	else {
 		__down(sem);
+	}
 	spin_unlock_irqrestore(&sem->lock, flags);
 }
 EXPORT_SYMBOL(down);
@@ -78,10 +87,15 @@ int down_interruptible(struct semaphore *sem)
 	int result = 0;
 
 	spin_lock_irqsave(&sem->lock, flags);
-	if (likely(sem->count > 0))
+	if (likely(sem->count > 0)) {
+#ifdef CONFIG_EVENT_LOGGING
+	  event_log_sem_lock(sem);
+#endif
 		sem->count--;
-	else
+	}
+	else {
 		result = __down_interruptible(sem);
+	}
 	spin_unlock_irqrestore(&sem->lock, flags);
 
 	return result;
@@ -104,10 +118,15 @@ int down_killable(struct semaphore *sem)
 	int result = 0;
 
 	spin_lock_irqsave(&sem->lock, flags);
-	if (likely(sem->count > 0))
+	if (likely(sem->count > 0)) {
+#ifdef CONFIG_EVENT_LOGGING
+	  event_log_sem_lock(sem);
+#endif
 		sem->count--;
-	else
+	}
+	else {
 		result = __down_killable(sem);
+	}
 	spin_unlock_irqrestore(&sem->lock, flags);
 
 	return result;
@@ -134,8 +153,12 @@ int down_trylock(struct semaphore *sem)
 
 	spin_lock_irqsave(&sem->lock, flags);
 	count = sem->count - 1;
-	if (likely(count >= 0))
+	if (likely(count >= 0)) {
+#ifdef EVENT_CONFIG_LOGGING
+	  event_log_sem_lock(sem);
+#endif
 		sem->count = count;
+	}
 	spin_unlock_irqrestore(&sem->lock, flags);
 
 	return (count < 0);
@@ -158,10 +181,15 @@ int down_timeout(struct semaphore *sem, long jiffies)
 	int result = 0;
 
 	spin_lock_irqsave(&sem->lock, flags);
-	if (likely(sem->count > 0))
+	if (likely(sem->count > 0)) {
+#ifdef EVENT_CONFIG_LOGGING
+	  event_log_sem_lock(sem);
+#endif
 		sem->count--;
-	else
+	}
+	else {
 		result = __down_timeout(sem, jiffies);
+	}
 	spin_unlock_irqrestore(&sem->lock, flags);
 
 	return result;
@@ -211,6 +239,10 @@ static inline int __sched __down_common(struct semaphore *sem, long state,
 	waiter.task = task;
 	waiter.up = 0;
 
+#ifdef CONFIG_EVENT_LOGGING
+	event_log_sem_wait(sem);
+#endif
+
 	for (;;) {
 		if (signal_pending_state(state, task))
 			goto interrupted;
-- 
1.9.1


From b76495e0b781d888fa1106d3bb3484043ac6a702 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 10:01:16 -0400
Subject: [PATCH 10/72] eventlogging: align fields of struct event_header.

---
 include/eventlogging/events.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 9d90545..0dffa58 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -28,9 +28,9 @@
 struct event_hdr {
   __u8  event_type;
   __u8  cpu;
+  __le16 pid;
   __le32 tv_sec;
   __le32 tv_usec;
-  __le16 pid;
 }__attribute__((packed));
 
 struct context_switch_event {
-- 
1.9.1


From d78ece7fee9242dca4438957ecaa6ba76175a182 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 10:15:25 -0400
Subject: [PATCH 11/72] eventlogging: learn to log IO block/resume.

---
 include/eventlogging/events.h | 10 ++++++++++
 kernel/eventlogging/events.c  |  8 ++++++++
 kernel/sched.c                | 20 ++++++++++++++++++++
 3 files changed, 38 insertions(+)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 0dffa58..593daf3 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -73,6 +73,14 @@ struct sem_wait_event {
   __le32 lock;
 }__attribute__((packed));
 
+struct io_block_event {
+  struct event_hdr hdr;
+}__attribute__((packed));
+
+struct io_resume_event {
+  struct event_hdr hdr;
+}__attribute__((packed));
+
 #ifdef __KERNEL__
 void event_log_header_init(struct event_hdr* event, u8 type);
 void event_log_simple(u8 event_type);
@@ -88,6 +96,8 @@ void event_log_mutex_lock(void* lock);
 void event_log_mutex_wait(void* lock);;
 void event_log_sem_lock(void* lock);
 void event_log_sem_wait(void* lock);
+void event_log_io_block(void);
+void event_log_io_resume(void);
 #endif
 
 #endif
diff --git a/kernel/eventlogging/events.c b/kernel/eventlogging/events.c
index a911124..c3d00fc 100644
--- a/kernel/eventlogging/events.c
+++ b/kernel/eventlogging/events.c
@@ -60,6 +60,14 @@ void event_log_sock_resume(void) {
   event_log_simple(EVENT_SOCK_RESUME);
 }
 
+void event_log_io_block(void) {
+  event_log_simple(EVENT_IO_BLOCK);
+}
+
+void event_log_io_resume(void) {
+  event_log_simple(EVENT_IO_RESUME);
+}
+
 void event_log_fork(pid_t pid, pid_t tgid) {
   unsigned long flags;
   struct fork_event event;
diff --git a/kernel/sched.c b/kernel/sched.c
index d488880..1a527a0 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -73,6 +73,10 @@
 #include <linux/slab.h>
 #include <linux/cpuacct.h>
 
+#ifdef CONFIG_EVENT_LOGGING
+#include <eventlogging/events.h>
+#endif
+
 #include <asm/tlb.h>
 #include <asm/irq_regs.h>
 #include <asm/mutex.h>
@@ -3144,6 +3148,10 @@ context_switch(struct rq *rq, struct task_struct *prev,
 {
 	struct mm_struct *mm, *oldmm;
 
+	#ifdef CONFIG_EVENT_LOGGING
+	//event_log_context_switch(prev->pid, next->pid);
+	#endif
+
 	prepare_task_switch(rq, prev, next);
 
 	mm = next->mm;
@@ -5686,7 +5694,13 @@ void __sched io_schedule(void)
 	atomic_inc(&rq->nr_iowait);
 	blk_flush_plug(current);
 	current->in_iowait = 1;
+#ifdef CONFIG_EVENT_LOGGING
+	event_log_io_block();
+#endif
 	schedule();
+#ifdef CONFIG_EVENT_LOGGING
+	event_log_io_resume();
+#endif
 	current->in_iowait = 0;
 	atomic_dec(&rq->nr_iowait);
 	delayacct_blkio_end();
@@ -5702,7 +5716,13 @@ long __sched io_schedule_timeout(long timeout)
 	atomic_inc(&rq->nr_iowait);
 	blk_flush_plug(current);
 	current->in_iowait = 1;
+#ifdef CONFIG_EVENT_LOGGING
+	event_log_io_block();
+#endif
 	ret = schedule_timeout(timeout);
+#ifdef CONFIG_EVENT_LOGGING
+	event_log_io_resume();
+#endif
 	current->in_iowait = 0;
 	atomic_dec(&rq->nr_iowait);
 	delayacct_blkio_end();
-- 
1.9.1


From 17e3304372b69abf38f1df8e3f5741edbf9abc0e Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 13:02:39 -0400
Subject: [PATCH 12/72] eventlogging: fix makefile to obey event logging config

---
 kernel/Makefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/kernel/Makefile b/kernel/Makefile
index 9d5a515..d813ba8 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -73,7 +73,7 @@ obj-$(CONFIG_AUDITSYSCALL) += auditsc.o
 obj-$(CONFIG_AUDIT_WATCH) += audit_watch.o
 obj-$(CONFIG_AUDIT_TREE) += audit_tree.o
 obj-$(CONFIG_GCOV_KERNEL) += gcov/
-obj-y += eventlogging/
+obj-$(CONFIG_EVENT_LOGGING) += eventlogging/
 obj-$(CONFIG_KPROBES) += kprobes.o
 obj-$(CONFIG_KGDB) += debug/
 obj-$(CONFIG_DETECT_HUNG_TASK) += hung_task.o
-- 
1.9.1


From fbede2da975f6c421543e9acc0166ad77b10a575 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 13:03:13 -0400
Subject: [PATCH 13/72] eventlogging: add defconfig for Nexus 7

---
 .../configs/tegra3_android_eventlogging_defconfig  | 515 +++++++++++++++++++++
 1 file changed, 515 insertions(+)
 create mode 100644 arch/arm/configs/tegra3_android_eventlogging_defconfig

diff --git a/arch/arm/configs/tegra3_android_eventlogging_defconfig b/arch/arm/configs/tegra3_android_eventlogging_defconfig
new file mode 100644
index 0000000..7a21688
--- /dev/null
+++ b/arch/arm/configs/tegra3_android_eventlogging_defconfig
@@ -0,0 +1,515 @@
+
+CONFIG_EXPERIMENTAL=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_PANIC_TIMEOUT=10
+# CONFIG_SYSCTL_SYSCALL is not set
+# CONFIG_ELF_CORE is not set
+CONFIG_ASHMEM=y
+CONFIG_EMBEDDED=y
+CONFIG_SLAB=y
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_ARCH_TEGRA=y
+CONFIG_GPIO_PCA953X=y
+CONFIG_ARCH_TEGRA_3x_SOC=y
+CONFIG_TEGRA_PCI=y
+CONFIG_MACH_CARDHU=y
+CONFIG_MACH_TEGRA_ENTERPRISE=y
+CONFIG_MACH_GROUPER=y
+CONFIG_TEGRA_PWM=y
+CONFIG_TEGRA_FIQ_DEBUGGER=y
+CONFIG_TEGRA_EMC_SCALING_ENABLE=y
+CONFIG_WIFI_CONTROL_FUNC=y
+CONFIG_TEGRA_CLOCK_DEBUG_WRITE=y
+CONFIG_USB_HOTPLUG=y
+CONFIG_TEGRA_DYNAMIC_PWRDET=y
+# CONFIG_TEGRA_THERMAL_SYSFS is not set
+CONFIG_TEGRA_PLLM_RESTRICTED=y
+CONFIG_ARM_ERRATA_742230=y
+CONFIG_ARM_ERRATA_743622=y
+CONFIG_ARM_ERRATA_751472=y
+CONFIG_ARM_ERRATA_752520=y
+CONFIG_FIQ_DEBUGGER_CONSOLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_SMP=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+CONFIG_HIGHMEM=y
+CONFIG_ARM_FLUSH_CONSOLE_ON_RESTART=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="tegra_wdt.heartbeat=30"
+CONFIG_CMDLINE_EXTEND=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_WAKELOCK=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM_DEBUG=y
+CONFIG_SUSPEND_TIME=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_INET_ESP=y
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_TARGET_LOG=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_SCH_INGRESS=y
+CONFIG_NET_CLS_U32=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+CONFIG_NET_ACT_MIRRED=y
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_LL=y
+CONFIG_BT_BLUESLEEP=y
+CONFIG_CFG80211=y
+CONFIG_NL80211_TESTMODE=y
+CONFIG_RFKILL=y
+CONFIG_CAIF=y
+CONFIG_NFC=y
+CONFIG_PN544_NFC=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_MISC_DEVICES=y
+CONFIG_AD525X_DPOT=y
+CONFIG_AD525X_DPOT_I2C=y
+CONFIG_APDS9802ALS=y
+CONFIG_SENSORS_NCT1008=y
+CONFIG_UID_STAT=y
+CONFIG_BCM4330_RFKILL=y
+CONFIG_TEGRA_CRYPTO_DEV=y
+CONFIG_MAX1749_VIBRATOR=y
+CONFIG_EEPROM_AT24=y
+# CONFIG_MPU_SENSORS_TIMERIRQ is not set
+# CONFIG_MPU_SENSORS_MPU6050B1 is not set
+# CONFIG_MPU_SENSORS_AMI306 is not set
+
+#
+# Magnetometer sensors
+#
+# CONFIG_SENSORS_HMC5843 is not set
+CONFIG_AMI306=y
+
+#
+# Light sensors
+#
+CONFIG_SENSORS_ISL29028=y
+CONFIG_SENSORS_LTR558=y
+
+#
+# Active energy metering IC
+#
+CONFIG_IIO=y
+CONFIG_IIO_BUFFER=y
+CONFIG_IIO_KFIFO_BUF=y
+CONFIG_IIO_TRIGGER=y
+CONFIG_IIO_CONSUMERS_PER_TRIGGER=2
+CONFIG_INV_MPU_IIO=y
+
+CONFIG_TEGRA_BB_SUPPORT=y
+CONFIG_TEGRA_BB_POWER=y
+CONFIG_TEGRA_BB_M7400=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_DM_UEVENT=y
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=y
+CONFIG_TUN=y
+# CONFIG_NETDEV_10000 is not set
+CONFIG_BCMDHD=y
+CONFIG_BCMDHD_FW_PATH="/system/vendor/firmware/fw_bcmdhd.bin"
+CONFIG_BCMDHD_NVRAM_PATH="/system/etc/nvram.txt"
+CONFIG_DHD_ENABLE_P2P=y
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_SMSC95XX=y
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_BELKIN is not set
+# CONFIG_USB_ARMLINUX is not set
+# CONFIG_USB_NET_ZAURUS is not set
+CONFIG_PPP=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+# CONFIG_INPUT_MOUSEDEV is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_KEYRESET=y
+CONFIG_INPUT_LID=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_TEGRA=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_JOYSTICK_XPAD_LEDS=y
+CONFIG_INPUT_TABLET=y
+CONFIG_TABLET_USB_ACECAD=y
+CONFIG_TABLET_USB_AIPTEK=y
+CONFIG_TABLET_USB_GTCO=y
+CONFIG_TABLET_USB_HANWANG=y
+CONFIG_TABLET_USB_KBTAB=y
+CONFIG_TABLET_USB_WACOM=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ELAN_TF_3K=y
+CONFIG_TOUCHSCREEN_RM31080A=y
+CONFIG_TOUCHSCREEN_SYN_RMI4_SPI=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_KEYCHORD=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_VT is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_TEGRA=y
+# CONFIG_HW_RANDOM is not set
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA954x=y
+# CONFIG_I2C_HELPER_AUTO is not set
+CONFIG_I2C_TEGRA=y
+CONFIG_SPI=y
+CONFIG_SPI_TEGRA=y
+CONFIG_SPI_SLAVE_TEGRA=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_CHARGER_SMB347=y
+CONFIG_BATTERY_BQ27541=y
+CONFIG_SENSORS_TEGRA_TSENSOR=y
+CONFIG_SENSORS_INA219=y
+CONFIG_SENSORS_AL3010=y
+CONFIG_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_TEGRA_WATCHDOG=y
+CONFIG_TEGRA_WATCHDOG_ENABLE_ON_PROBE=y
+CONFIG_MFD_TPS6586X=y
+CONFIG_MFD_TPS65910=y
+CONFIG_MFD_MAX77663=y
+CONFIG_MFD_TPS6591X=y
+CONFIG_MFD_TPS80031=y
+CONFIG_GPADC_TPS80031=y
+CONFIG_MFD_RICOH583=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_VIRTUAL_CONSUMER=y
+CONFIG_REGULATOR_MAX77663=y
+CONFIG_REGULATOR_TPS6586X=y
+CONFIG_REGULATOR_TPS65910=y
+CONFIG_REGULATOR_TPS62360=y
+CONFIG_REGULATOR_TPS6591X=y
+CONFIG_REGULATOR_TPS80031=y
+CONFIG_REGULATOR_RICOH583=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_VIDEO_DEV=y
+# CONFIG_RC_CORE is not set
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+# CONFIG_TEGRA_AVP is not set
+# CONFIG_TEGRA_MEDIASERVER is not set
+CONFIG_TEGRA_NVAVP=y
+CONFIG_VIDEO_MI1040=y
+CONFIG_USB_VIDEO_CLASS=y
+# CONFIG_USB_GSPCA is not set
+# CONFIG_RADIO_ADAPTERS is not set
+CONFIG_VIDEO_OUTPUT_CONTROL=y
+CONFIG_FB=y
+CONFIG_TEGRA_GRHOST=y
+CONFIG_TEGRA_DC=y
+CONFIG_TEGRA_DSI=y
+CONFIG_TEGRA_NVHDCP=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_BACKLIGHT_TEGRA_PWM=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_HDA_INTEL=y
+CONFIG_SND_HDA_PLATFORM_DRIVER=y
+CONFIG_SND_HDA_PLATFORM_NVIDIA_TEGRA=y
+CONFIG_SND_HDA_POWER_SAVE=y
+CONFIG_SND_HDA_POWER_SAVE_DEFAULT=10
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_TEGRA=y
+CONFIG_SND_SOC_TEGRA_RT5640=y
+CONFIG_HEADSET_FUNCTION=y
+CONFIG_HID_A4TECH=y
+CONFIG_HID_ACRUX=y
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EMS_FF=y
+CONFIG_HID_ELECOM=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_HOLTEK=y
+CONFIG_HOLTEK_FF=y
+CONFIG_HID_KEYTOUCH=y
+CONFIG_HID_KYE=y
+CONFIG_HID_UCLOGIC=y
+CONFIG_HID_WALTOP=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LCPOWER=y
+CONFIG_HID_LOGITECH=y
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+CONFIG_LOGIG940_FF=y
+CONFIG_LOGIWII_FF=y
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SPEEDLINK=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_WACOM=y
+CONFIG_HID_WIIMOTE=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_ZEROPLUS_FF=y
+CONFIG_HID_ZYDACRON=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_SUSPEND=y
+CONFIG_USB_OTG=y
+# CONFIG_USB_OTG_WHITELIST is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_ACM=y
+CONFIG_USB_WDM=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_LIBUSUAL=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_PL2303=y
+CONFIG_USB_SERIAL_OPTION=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_VBUS_DRAW=500
+CONFIG_USB_FSL_USB2=y
+CONFIG_USB_G_ANDROID=y
+CONFIG_USB_TEGRA_OTG=y
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_EMBEDDED_SDIO=y
+CONFIG_MMC_BLOCK_MINORS=16
+CONFIG_MMC_BLOCK_DEFERRED_RESUME=y
+CONFIG_MMC_TEST=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_TEGRA=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_SWITCH=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_MAX77663=y
+CONFIG_RTC_DRV_TPS6586X=y
+CONFIG_RTC_DRV_TPS6591x=y
+CONFIG_RTC_DRV_TPS80031=y
+CONFIG_RTC_DRV_RC5T583=y
+CONFIG_STAGING=y
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+# CONFIG_DNOTIFY is not set
+CONFIG_FUSE_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_TMPFS=y
+CONFIG_NFS_FS=y
+CONFIG_ROOT_NFS=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_EFI_PARTITION=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_LOCKUP_DETECTOR=y
+# CONFIG_DETECT_HUNG_TASK is not set
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_PREEMPT is not set
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_VM=y
+# CONFIG_EVENT_POWER_TRACING_DEPRECATED is not set
+CONFIG_ENABLE_DEFAULT_TRACERS=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_TRUSTED_FOUNDATIONS=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_TWOFISH=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_DEV_TEGRA_SE=y
+CONFIG_EVENT_LOGGING=y
\ No newline at end of file
-- 
1.9.1


From 3e5167eba037a99803bb40fea96711157048fd85 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 14:14:47 -0400
Subject: [PATCH 14/72] eventlogging: add per-event config options.

---
 .../configs/tegra3_android_eventlogging_defconfig  | 16 +++++-
 include/eventlogging/events.h                      | 39 ++++++++------
 kernel/eventlogging/Kconfig                        | 61 ++++++++++++++++++++++
 kernel/eventlogging/events.c                       | 36 ++++++++++---
 kernel/mutex.c                                     |  6 ---
 kernel/sched.c                                     | 14 +----
 kernel/semaphore.c                                 | 24 ++-------
 net/core/datagram.c                                |  6 ---
 net/core/sock.c                                    |  6 ---
 net/core/stream.c                                  |  6 ---
 10 files changed, 134 insertions(+), 80 deletions(-)

diff --git a/arch/arm/configs/tegra3_android_eventlogging_defconfig b/arch/arm/configs/tegra3_android_eventlogging_defconfig
index 7a21688..028d6f6 100644
--- a/arch/arm/configs/tegra3_android_eventlogging_defconfig
+++ b/arch/arm/configs/tegra3_android_eventlogging_defconfig
@@ -512,4 +512,18 @@ CONFIG_CRYPTO_SHA256=y
 CONFIG_CRYPTO_TWOFISH=y
 # CONFIG_CRYPTO_ANSI_CPRNG is not set
 CONFIG_CRYPTO_DEV_TEGRA_SE=y
-CONFIG_EVENT_LOGGING=y
\ No newline at end of file
+CONFIG_EVENT_LOGGING=y
+CONFIG_EVENT_CONTEXT_SWITCH=n
+CONFIG_EVENT_FORK=y
+CONFIG_EVENT_IO_BLOCK=y
+CONFIG_EVENT_IO_RESUME=y
+CONFIG_EVENT_DATAGRAM_BLOCK=y
+CONFIG_EVENT_DATAGRAM_RESUME=y
+CONFIG_EVENT_STREAM_BLOCK=y
+CONFIG_EVENT_STREAM_RESUME=y
+CONFIG_EVENT_SOCK_BLOCK=y
+CONFIG_EVENT_SOCK_RESUME=y
+CONFIG_EVENT_SEMAPHORE_LOCK=n
+CONFIG_EVENT_SEMAPHORE_WAIT=y
+CONFIG_EVENT_MUTEX_LOCK=n
+CONFIG_EVENT_MUTEX_WAIT=y
diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 593daf3..11573ff 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -82,22 +82,27 @@ struct io_resume_event {
 }__attribute__((packed));
 
 #ifdef __KERNEL__
-void event_log_header_init(struct event_hdr* event, u8 type);
-void event_log_simple(u8 event_type);
-void event_log_context_switch(pid_t old, pid_t new);
-void event_log_datagram_block(void);
-void event_log_datagram_resume(void);
-void event_log_stream_block(void);
-void event_log_stream_resume(void);
-void event_log_sock_block(void);
-void event_log_sock_resume(void);
-void event_log_fork(pid_t pid, pid_t tgid);
-void event_log_mutex_lock(void* lock);
-void event_log_mutex_wait(void* lock);;
-void event_log_sem_lock(void* lock);
-void event_log_sem_wait(void* lock);
-void event_log_io_block(void);
-void event_log_io_resume(void);
-#endif
 
+#ifdef CONFIG_EVENT_LOGGING
+#define DEFINE_EVENT_LOG_FUNC(name, ...) void event_log_##name(__VA_ARGS__)
+#else
+#define DEFINE_EVENT_LOG_FUNC()name, ...) void event_log_##name(__VA_ARGS__){}
 #endif
+
+DEFINE_EVENT_LOG_FUNC(context_switch, pid_t old, pid_t new);
+DEFINE_EVENT_LOG_FUNC(datagram_block, void);
+DEFINE_EVENT_LOG_FUNC(datagram_resume, void);
+DEFINE_EVENT_LOG_FUNC(stream_block, void);
+DEFINE_EVENT_LOG_FUNC(stream_resume, void);
+DEFINE_EVENT_LOG_FUNC(sock_block, void);
+DEFINE_EVENT_LOG_FUNC(sock_resume, void);
+DEFINE_EVENT_LOG_FUNC(fork, pid_t pid, pid_t tgid);
+DEFINE_EVENT_LOG_FUNC(mutex_lock, void* lock);
+DEFINE_EVENT_LOG_FUNC(mutex_wait, void* lock);;
+DEFINE_EVENT_LOG_FUNC(sem_lock, void* lock);
+DEFINE_EVENT_LOG_FUNC(sem_wait, void* lock);
+DEFINE_EVENT_LOG_FUNC(io_block, void);
+DEFINE_EVENT_LOG_FUNC(io_resume, void);
+
+#endif // __KERNEL__
+#endif // EVENTLOGGING_EVENTS_H
diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index d8935ad..be879f3 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -7,3 +7,64 @@ menuconfig EVENT_LOGGING
         bool "Event Logging Zhang/Bild"
         help
           Event tracing framework for Lide Zhang and David Bild.
+
+if EVENT_LOGGING
+
+config EVENT_CONTEXT_SWITCH
+       bool "Log context switches"
+       default no
+
+config EVENT_FORK
+       bool "Log forks"
+       default yes
+
+config EVENT_IO_BLOCK
+       bool "Log IO blocks"
+       default yes
+
+config EVENT_IO_RESUME
+       bool "Log IO resumes"
+       default yes
+
+config EVENT_DATAGRAM_BLOCK
+       bool "Log datagram blocks"
+       default yes
+
+config EVENT_DATAGRAM_RESUME
+       bool "Log datagram resumes"
+       default yes
+
+config EVENT_STREAM_BLOCK
+       bool "Log stream blocks"
+       default yes
+
+config EVENT_STREAM_RESUME
+       bool "Log stream resumes"
+       default yes
+
+config EVENT_SOCK_BLOCK
+       bool "Log socket blocks"
+       default yes
+
+config EVENT_SOCK_RESUME
+       bool "Log socket resumes"
+       default yes
+
+config EVENT_SEMAPHORE_LOCK
+       bool "Log semaphore locks"
+       default no
+
+config EVENT_SEMAPHORE_WAIT
+       bool "Log semaphore waits"
+       default yes
+
+config EVENT_MUTEX_LOCK
+       bool "Log mutex locks"
+       default no
+
+config EVENT_MUTEX_WAIT
+       bool "Log mutex waits"
+       default yes
+
+endif
+
diff --git a/kernel/eventlogging/events.c b/kernel/eventlogging/events.c
index c3d00fc..45c7542 100644
--- a/kernel/eventlogging/events.c
+++ b/kernel/eventlogging/events.c
@@ -5,7 +5,7 @@
 #include <eventlogging/events.h>
 #include "logging.h"
 
-void event_log_header_init(struct event_hdr* event, u8 type) {
+static inline void event_log_header_init(struct event_hdr* event, u8 type) {
   struct timeval tv;
   do_gettimeofday(&tv);
 
@@ -16,7 +16,7 @@ void event_log_header_init(struct event_hdr* event, u8 type) {
   event->pid = current->pid;
 }
 
-void event_log_simple(u8 event_type) {
+static inline void event_log_simple(u8 event_type) {
   unsigned long flags;
   struct event_hdr event;
   local_irq_save(flags);
@@ -26,6 +26,7 @@ void event_log_simple(u8 event_type) {
 }
 
 void event_log_context_switch(pid_t old, pid_t new) {
+#ifdef CONFIG_EVENT_CONTEXT_SWITCH
   unsigned long flags;
   struct context_switch_event event;
   local_irq_save(flags);
@@ -34,41 +35,59 @@ void event_log_context_switch(pid_t old, pid_t new) {
   event.new_pid = new;
   log_event(&event, sizeof(struct context_switch_event));
   local_irq_restore(flags);
+#endif
 }
 
 void event_log_datagram_block(void) {
+#ifdef CONFIG_EVENT_DATAGRAM_BLOCK
   event_log_simple(EVENT_DATAGRAM_BLOCK);
+#endif
 }
 
 void event_log_datagram_resume(void) {
+#ifdef CONFIG_EVENT_DATAGRAM_RESUME
   event_log_simple(EVENT_DATAGRAM_RESUME);
+#endif
 }
 
 void event_log_stream_block(void) {
+#ifdef CONFIG_EVENT_STREAM_BLOCK
   event_log_simple(EVENT_STREAM_BLOCK);
+#endif
 }
 
 void event_log_stream_resume(void) {
+#ifdef CONFIG_EVENT_STREAM_RESUME
   event_log_simple(EVENT_STREAM_RESUME);
+#endif
 }
 
 void event_log_sock_block(void) {
+#ifdef CONFIG_EVENT_SOCK_BLOCK
   event_log_simple(EVENT_SOCK_BLOCK);
+#endif
 }
 
 void event_log_sock_resume(void) {
+#ifdef CONFIG_EVENT_SOCK_RESUME
   event_log_simple(EVENT_SOCK_RESUME);
+#endif
 }
 
 void event_log_io_block(void) {
+#ifdef CONFIG_EVENT_IO_BLOCK
   event_log_simple(EVENT_IO_BLOCK);
+#endif
 }
 
 void event_log_io_resume(void) {
+#ifdef CONFIG_EVENT_IO_RESUME
   event_log_simple(EVENT_IO_RESUME);
+#endif
 }
 
 void event_log_fork(pid_t pid, pid_t tgid) {
+#ifdef CONFIG_EVENT_FORK
   unsigned long flags;
   struct fork_event event;
   
@@ -78,9 +97,11 @@ void event_log_fork(pid_t pid, pid_t tgid) {
   event.tgid = tgid;
   log_event(&event, sizeof(struct fork_event));
   local_irq_restore(flags);
+#endif
 }
 
 void event_log_mutex_lock(void* lock) {
+#ifdef CONFIG_EVENT_MUTEX_LOCK
   unsigned long flags;
   struct mutex_lock_event event;
 
@@ -89,9 +110,11 @@ void event_log_mutex_lock(void* lock) {
   event.lock = (__le32) lock;
   log_event(&event, sizeof(struct mutex_lock_event));
   local_irq_restore(flags);
+#endif
 }
 
 void event_log_mutex_wait(void* lock) {
+#ifdef CONFIG_EVENT_MUTEX_WAIT
   unsigned long flags;
   struct mutex_wait_event event;
 
@@ -100,9 +123,11 @@ void event_log_mutex_wait(void* lock) {
   event.lock = (__le32) lock;
   log_event(&event, sizeof(struct mutex_wait_event));
   local_irq_restore(flags);
+#endif
 }
 
 void event_log_sem_lock(void* lock) {
+#ifdef CONFIG_EVENT_SEMAPHORE_LOCK
   unsigned long flags;
   struct sem_lock_event event;
 
@@ -111,9 +136,11 @@ void event_log_sem_lock(void* lock) {
   event.lock = (__le32) lock;
   log_event(&event, sizeof(struct sem_lock_event));
   local_irq_restore(flags);
+#endif
 }
 
 void event_log_sem_wait(void* lock) {
+#ifdef CONFIG_EVENT_SEMAPHORE_WAIT
   unsigned long flags;
   struct sem_wait_event event;
 
@@ -122,8 +149,5 @@ void event_log_sem_wait(void* lock) {
   event.lock = (__le32) lock;
   log_event(&event, sizeof(struct sem_wait_event));
   local_irq_restore(flags);
+#endif
 }
-
-
-
-
diff --git a/kernel/mutex.c b/kernel/mutex.c
index d26daa2..e26d920 100644
--- a/kernel/mutex.c
+++ b/kernel/mutex.c
@@ -24,9 +24,7 @@
 #include <linux/interrupt.h>
 #include <linux/debug_locks.h>
 
-#ifdef CONFIG_EVENT_LOGGING
 #include <eventlogging/events.h>
-#endif
 
 /*
  * In the DEBUG case we are using the "NULL fastpath" for mutexes,
@@ -243,9 +241,7 @@ __mutex_lock_common(struct mutex *lock, long state, unsigned int subclass,
 		__set_task_state(task, state);
 
 		/* didn't get the lock, go to sleep: */
-#ifdef CONFIG_EVENT_LOGGING
 		event_log_mutex_wait(lock);
-#endif
 		spin_unlock_mutex(&lock->wait_lock, flags);
 		preempt_enable_no_resched();
 		schedule();
@@ -255,9 +251,7 @@ __mutex_lock_common(struct mutex *lock, long state, unsigned int subclass,
 
 done:
 	lock_acquired(&lock->dep_map, ip);
-#ifdef CONFIG_EVENT_LOGGING
 	event_log_mutex_lock(lock);
-#endif
 	/* got the lock - rejoice! */
 	mutex_remove_waiter(lock, &waiter, current_thread_info());
 	mutex_set_owner(lock);
diff --git a/kernel/sched.c b/kernel/sched.c
index 1a527a0..cea8991 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -73,9 +73,7 @@
 #include <linux/slab.h>
 #include <linux/cpuacct.h>
 
-#ifdef CONFIG_EVENT_LOGGING
 #include <eventlogging/events.h>
-#endif
 
 #include <asm/tlb.h>
 #include <asm/irq_regs.h>
@@ -3148,9 +3146,7 @@ context_switch(struct rq *rq, struct task_struct *prev,
 {
 	struct mm_struct *mm, *oldmm;
 
-	#ifdef CONFIG_EVENT_LOGGING
-	//event_log_context_switch(prev->pid, next->pid);
-	#endif
+	event_log_context_switch(prev->pid, next->pid);
 
 	prepare_task_switch(rq, prev, next);
 
@@ -5694,13 +5690,9 @@ void __sched io_schedule(void)
 	atomic_inc(&rq->nr_iowait);
 	blk_flush_plug(current);
 	current->in_iowait = 1;
-#ifdef CONFIG_EVENT_LOGGING
 	event_log_io_block();
-#endif
 	schedule();
-#ifdef CONFIG_EVENT_LOGGING
 	event_log_io_resume();
-#endif
 	current->in_iowait = 0;
 	atomic_dec(&rq->nr_iowait);
 	delayacct_blkio_end();
@@ -5716,13 +5708,9 @@ long __sched io_schedule_timeout(long timeout)
 	atomic_inc(&rq->nr_iowait);
 	blk_flush_plug(current);
 	current->in_iowait = 1;
-#ifdef CONFIG_EVENT_LOGGING
 	event_log_io_block();
-#endif
 	ret = schedule_timeout(timeout);
-#ifdef CONFIG_EVENT_LOGGING
 	event_log_io_resume();
-#endif
 	current->in_iowait = 0;
 	atomic_dec(&rq->nr_iowait);
 	delayacct_blkio_end();
diff --git a/kernel/semaphore.c b/kernel/semaphore.c
index 12a48b9..8d372cc 100644
--- a/kernel/semaphore.c
+++ b/kernel/semaphore.c
@@ -33,9 +33,7 @@
 #include <linux/spinlock.h>
 #include <linux/ftrace.h>
 
-#ifdef CONFIG_EVENT_LOGGING
 #include <eventlogging/events.h>
-#endif
 
 static noinline void __down(struct semaphore *sem);
 static noinline int __down_interruptible(struct semaphore *sem);
@@ -60,9 +58,7 @@ void down(struct semaphore *sem)
 
 	spin_lock_irqsave(&sem->lock, flags);
 	if (likely(sem->count > 0)) {
-#ifdef CONFIG_EVENT_LOGGING
-	  event_log_sem_lock(sem);
-#endif
+		event_log_sem_lock(sem);
 		sem->count--;
 	}
 	else {
@@ -88,9 +84,7 @@ int down_interruptible(struct semaphore *sem)
 
 	spin_lock_irqsave(&sem->lock, flags);
 	if (likely(sem->count > 0)) {
-#ifdef CONFIG_EVENT_LOGGING
-	  event_log_sem_lock(sem);
-#endif
+		event_log_sem_lock(sem);
 		sem->count--;
 	}
 	else {
@@ -119,9 +113,7 @@ int down_killable(struct semaphore *sem)
 
 	spin_lock_irqsave(&sem->lock, flags);
 	if (likely(sem->count > 0)) {
-#ifdef CONFIG_EVENT_LOGGING
-	  event_log_sem_lock(sem);
-#endif
+		event_log_sem_lock(sem);
 		sem->count--;
 	}
 	else {
@@ -154,9 +146,7 @@ int down_trylock(struct semaphore *sem)
 	spin_lock_irqsave(&sem->lock, flags);
 	count = sem->count - 1;
 	if (likely(count >= 0)) {
-#ifdef EVENT_CONFIG_LOGGING
-	  event_log_sem_lock(sem);
-#endif
+		event_log_sem_lock(sem);
 		sem->count = count;
 	}
 	spin_unlock_irqrestore(&sem->lock, flags);
@@ -182,9 +172,7 @@ int down_timeout(struct semaphore *sem, long jiffies)
 
 	spin_lock_irqsave(&sem->lock, flags);
 	if (likely(sem->count > 0)) {
-#ifdef EVENT_CONFIG_LOGGING
-	  event_log_sem_lock(sem);
-#endif
+		event_log_sem_lock(sem);
 		sem->count--;
 	}
 	else {
@@ -239,9 +227,7 @@ static inline int __sched __down_common(struct semaphore *sem, long state,
 	waiter.task = task;
 	waiter.up = 0;
 
-#ifdef CONFIG_EVENT_LOGGING
 	event_log_sem_wait(sem);
-#endif
 
 	for (;;) {
 		if (signal_pending_state(state, task))
diff --git a/net/core/datagram.c b/net/core/datagram.c
index e1ed3ad..526e594 100644
--- a/net/core/datagram.c
+++ b/net/core/datagram.c
@@ -58,9 +58,7 @@
 #include <net/tcp_states.h>
 #include <trace/events/skb.h>
 
-#ifdef CONFIG_EVENT_LOGGING
 #include <eventlogging/events.h>
-#endif
 
 /*
  *	Is a socket 'connection oriented' ?
@@ -117,13 +115,9 @@ static int wait_for_packet(struct sock *sk, int *err, long *timeo_p)
 		goto interrupted;
 
 	error = 0;
-#ifdef CONFIG_EVENT_LOGGING
 	event_log_datagram_block();
-#endif
 	*timeo_p = schedule_timeout(*timeo_p);
-#ifdef CONFIG_EVENT_LOGGING
 	event_log_datagram_resume();
-#endif
 out:
 	finish_wait(sk_sleep(sk), &wait);
 	return error;
diff --git a/net/core/sock.c b/net/core/sock.c
index a336dde..aec9fb3 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -132,9 +132,7 @@
 #include <net/tcp.h>
 #endif
 
-#ifdef CONFIG_EVENT_LOGGING
 #include <eventlogging/events.h>
-#endif
 
 /*
  * Each address family might have different locking rules, so we have
@@ -1661,13 +1659,9 @@ int sk_wait_data(struct sock *sk, long *timeo)
 
 	prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
 	set_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
-#ifdef CONFIG_EVENT_LOGGING
 	event_log_sock_block();
-#endif	
 	rc = sk_wait_event(sk, timeo, !skb_queue_empty(&sk->sk_receive_queue));
-#ifdef CONFIG_EVENT_LOGGING
 	event_log_sock_resume();
-#endif
 	clear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
 	finish_wait(sk_sleep(sk), &wait);
 	return rc;
diff --git a/net/core/stream.c b/net/core/stream.c
index 1057214..d39f3c4 100644
--- a/net/core/stream.c
+++ b/net/core/stream.c
@@ -19,9 +19,7 @@
 #include <linux/wait.h>
 #include <net/sock.h>
 
-#ifdef CONFIG_EVENT_LOGGING
 #include <eventlogging/events.h>
-#endif
 
 /**
  * sk_stream_write_space - stream socket write_space callback.
@@ -75,16 +73,12 @@ int sk_stream_wait_connect(struct sock *sk, long *timeo_p)
 
 		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
 		sk->sk_write_pending++;
-#ifdef CONFIG_EVENT_LOGGING
 		event_log_stream_block();
-#endif
 		done = sk_wait_event(sk, timeo_p,
 				     !sk->sk_err &&
 				     !((1 << sk->sk_state) &
 				       ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)));
-#ifdef CONFIG_EVENT_LOGGING
 		event_log_stream_resume();
-#endif
 		finish_wait(sk_sleep(sk), &wait);
 		sk->sk_write_pending--;
 	} while (!done);
-- 
1.9.1


From 645cab64b6286ca414db6c9b233b35b0108f3a79 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 14:55:23 -0400
Subject: [PATCH 15/72] eventlogging: log sync event at start of each buffer

---
 include/eventlogging/events.h |  9 +++++++++
 kernel/eventlogging/events.c  |  2 +-
 kernel/eventlogging/logging.c | 36 ++++++++++++++++++++++++++----------
 3 files changed, 36 insertions(+), 11 deletions(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 11573ff..e93987a 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -3,6 +3,10 @@
 
 #include <linux/types.h>
 
+#define EVENT_LOG_MAGIC "michigan"
+
+#define EVENT_SYNC_LOG 0
+
 #define EVENT_CONTEXT_SWITCH 10
 #define EVENT_FORK 15
 
@@ -33,6 +37,11 @@ struct event_hdr {
   __le32 tv_usec;
 }__attribute__((packed));
 
+struct sync_log_event {
+  struct event_hdr hdr;
+  char magic[8];
+}__attribute__((packed));
+
 struct context_switch_event {
   struct event_hdr hdr;
   __le16 old_pid;
diff --git a/kernel/eventlogging/events.c b/kernel/eventlogging/events.c
index 45c7542..c34b587 100644
--- a/kernel/eventlogging/events.c
+++ b/kernel/eventlogging/events.c
@@ -5,7 +5,7 @@
 #include <eventlogging/events.h>
 #include "logging.h"
 
-static inline void event_log_header_init(struct event_hdr* event, u8 type) {
+inline void event_log_header_init(struct event_hdr* event, u8 type) {
   struct timeval tv;
   do_gettimeofday(&tv);
 
diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index a721bdd..e8a468c 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -4,22 +4,39 @@
 #include <linux/cpu.h>
 #include <linux/slab.h>
 
+#include <eventlogging/events.h>
+
 #include "logging.h"
 #include "buffer.h"
 #include "proc_fs.h"
 
+extern void event_log_header_init(struct event_hdr* event, u8 type);
+
 #define BUFFER_ORDER   10  // 2^10 = 4 MB with 4096 page size
 #define NUM_BUFFERS 32  // 32 * 4 MB = 128 MB total
 
 static DEFINE_PER_CPU(struct sbuffer*, sbuffers);
 static DEFINE_PER_CPU(unsigned int, missed_events);
 
-static struct sbuffer* __get_cpu_buffer(void) {
+inline static void log_sync_event(struct sbuffer* buf) {
+  struct sync_log_event event;
+  event_log_header_init(&event.hdr, EVENT_SYNC_LOG);
+  memcpy(&event.magic, EVENT_LOG_MAGIC, 8);
+  sbuffer_write(buf, (void*)&event, sizeof(struct sync_log_event));
+}
+
+inline static struct sbuffer* __get_new_cpu_buffer(void) {
+  struct sbuffer* buf = take_empty_try();
+  if (NULL != buf)
+    log_sync_event(buf);
+  return buf;
+}
+
+inline static struct sbuffer* __get_cpu_buffer(void) {
   struct sbuffer* buf = __get_cpu_var(sbuffers);
-  if (NULL == buf) {
-    buf = take_empty_try();
-    __get_cpu_var(sbuffers) = buf;
-  }
+  if (NULL == buf) 
+    buf = __get_new_cpu_buffer();
+  __get_cpu_var(sbuffers) = buf;
   return buf;
 }
 
@@ -61,7 +78,7 @@ void log_event(void* data, int len) {
 static void __flush_offline_cpu_buffer(int cpu) {
   printk("eventlogging: flushing offline cpu: %d\n", cpu);
   put_full(per_cpu(sbuffers, cpu));
-  per_cpu(sbuffers, cpu) = take_empty_try();
+  per_cpu(sbuffers, cpu) = NULL;
 }
 
 /*
@@ -115,11 +132,10 @@ static __init int init_alloc_buffers(void) {
   }
   printk("eventlogging: allocated %d buffers\n", cnt);
 
-
-  /* Attach buffer to each cpu */
+  /* Set up CPUs to grab new buffer on first event */
   for_each_cpu(cpu, cpu_possible_mask) {
-    per_cpu(sbuffers, cpu) = take_empty_try();
-    printk("eventlogging: attached buffer to CPU %d\n", cpu);
+    per_cpu(sbuffers, cpu) = NULL; 
+    printk("eventlogging: prepare buffer for CPU %d\n", cpu);
   }
 
   return 0;
-- 
1.9.1


From 39a32b21c51baa807c84f265e370f790e21bd9f2 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 15:26:11 -0400
Subject: [PATCH 16/72] eventlogging: check for null buffer when flushing.

---
 kernel/eventlogging/logging.c | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index e8a468c..d9b1635 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -41,7 +41,9 @@ inline static struct sbuffer* __get_cpu_buffer(void) {
 }
 
 static struct sbuffer* __flush_cpu_buffer(void) {
-  put_full(__get_cpu_var(sbuffers));
+  struct sbuffer* buf = __get_cpu_var(sbuffers);
+  if (NULL != buf)
+    put_full(buf);
   __get_cpu_var(sbuffers) = NULL;
   return __get_cpu_buffer();
 }
@@ -76,8 +78,11 @@ void log_event(void* data, int len) {
  * and 'cpu' offline.
  */
 static void __flush_offline_cpu_buffer(int cpu) {
+  struct sbuffer* buf = per_cpu(sbuffers, cpu);
   printk("eventlogging: flushing offline cpu: %d\n", cpu);
-  put_full(per_cpu(sbuffers, cpu));
+  if (NULL == buf)
+    return;
+  put_full(buf);
   per_cpu(sbuffers, cpu) = NULL;
 }
 
-- 
1.9.1


From 4fa0e04c5a1d1344314bb4d1ade6583237e07756 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 16:51:57 -0400
Subject: [PATCH 17/72] eventlogging: remove unneeded ifdefs from fork

---
 kernel/fork.c | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/kernel/fork.c b/kernel/fork.c
index ef684e8..8f358a3 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -69,9 +69,7 @@
 #include <linux/khugepaged.h>
 #include <linux/signalfd.h>
 
-#ifdef CONFIG_EVENT_LOGGING
 #include <eventlogging/events.h>
-#endif
 
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
@@ -1273,10 +1271,7 @@ static struct task_struct *copy_process(unsigned long clone_flags,
 	if (clone_flags & CLONE_THREAD)
 		p->tgid = current->tgid;
 
-#ifdef CONFIG_EVENT_LOGGING
 	event_log_fork(p->pid, p->tgid);
-#endif
-
 	p->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? child_tidptr : NULL;
 	/*
 	 * Clear TID on mm_release()?
-- 
1.9.1


From 0df40b52fd93dec456253529908ef92a1489d9aa Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 16:59:24 -0400
Subject: [PATCH 18/72] eventlogging: learn mutex wake/notify events.

---
 .../configs/tegra3_android_eventlogging_defconfig  |  2 ++
 include/eventlogging/events.h                      | 17 +++++++++++++-
 kernel/eventlogging/Kconfig                        |  8 +++++++
 kernel/eventlogging/events.c                       | 27 ++++++++++++++++++++++
 kernel/mutex.c                                     |  5 ++--
 5 files changed, 56 insertions(+), 3 deletions(-)

diff --git a/arch/arm/configs/tegra3_android_eventlogging_defconfig b/arch/arm/configs/tegra3_android_eventlogging_defconfig
index 028d6f6..30058ce 100644
--- a/arch/arm/configs/tegra3_android_eventlogging_defconfig
+++ b/arch/arm/configs/tegra3_android_eventlogging_defconfig
@@ -527,3 +527,5 @@ CONFIG_EVENT_SEMAPHORE_LOCK=n
 CONFIG_EVENT_SEMAPHORE_WAIT=y
 CONFIG_EVENT_MUTEX_LOCK=n
 CONFIG_EVENT_MUTEX_WAIT=y
+CONFIG_EVENT_MUTEX_WAKE=y
+CONFIG_EVENT_MUTEX_NOTIFY=y
diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index e93987a..5cbba75 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -25,6 +25,8 @@
 
 #define EVENT_MUTEX_LOCK 50
 #define EVENT_MUTEX_WAIT 51
+#define EVENT_MUTEX_WAKE 52
+#define EVENT_MUTEX_NOTIFY 53
 
 #define EVENT_IPC_LOCK 60
 #define EVENT_IPC_WAIT 11
@@ -72,6 +74,17 @@ struct mutex_wait_event {
   __le32 lock;
 }__attribute__((packed));
 
+struct mutex_wake_event {
+  struct event_hdr hdr;
+  __le32 lock;
+}__attribute__((packed));
+
+struct mutex_notify_event {
+  struct event_hdr hdr;
+  __le32 lock;
+  __le16 pid;
+}__attribute__((packed));
+
 struct sem_lock_event {
   struct event_hdr hdr;
   __le32 lock;
@@ -107,7 +120,9 @@ DEFINE_EVENT_LOG_FUNC(sock_block, void);
 DEFINE_EVENT_LOG_FUNC(sock_resume, void);
 DEFINE_EVENT_LOG_FUNC(fork, pid_t pid, pid_t tgid);
 DEFINE_EVENT_LOG_FUNC(mutex_lock, void* lock);
-DEFINE_EVENT_LOG_FUNC(mutex_wait, void* lock);;
+DEFINE_EVENT_LOG_FUNC(mutex_wait, void* lock);
+DEFINE_EVENT_LOG_FUNC(mutex_wake, void* lock);
+DEFINE_EVENT_LOG_FUNC(mutex_notify, void* lock, pid_t pid);
 DEFINE_EVENT_LOG_FUNC(sem_lock, void* lock);
 DEFINE_EVENT_LOG_FUNC(sem_wait, void* lock);
 DEFINE_EVENT_LOG_FUNC(io_block, void);
diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index be879f3..a2eb036 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -66,5 +66,13 @@ config EVENT_MUTEX_WAIT
        bool "Log mutex waits"
        default yes
 
+config EVENT_MUTEX_WAKE
+       bool "Log mutex wake"
+       default yes
+
+config EVENT_MUTEX_NOTIFY
+       bool "Log who wakes up a mutex"
+       default yes
+
 endif
 
diff --git a/kernel/eventlogging/events.c b/kernel/eventlogging/events.c
index c34b587..b41d350 100644
--- a/kernel/eventlogging/events.c
+++ b/kernel/eventlogging/events.c
@@ -126,6 +126,33 @@ void event_log_mutex_wait(void* lock) {
 #endif
 }
 
+void event_log_mutex_wake(void* lock) {
+#ifdef CONFIG_EVENT_MUTEX_WAKE
+  unsigned long flags;
+  struct mutex_wake_event event;
+  
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_MUTEX_WAKE);
+  event.lock = (__le32) lock;
+  log_event(&event, sizeof(struct mutex_wake_event));
+  local_irq_restore(flags);
+#endif
+}
+
+void event_log_mutex_notify(void* lock, pid_t pid) {
+#ifdef CONFIG_EVENT_MUTEX_WAKE
+  unsigned long flags;
+  struct mutex_notify_event event;
+  
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_MUTEX_NOTIFY);
+  event.lock = (__le32) lock;
+  event.pid = pid;
+  log_event(&event, sizeof(struct mutex_notify_event));
+  local_irq_restore(flags);
+#endif
+}
+
 void event_log_sem_lock(void* lock) {
 #ifdef CONFIG_EVENT_SEMAPHORE_LOCK
   unsigned long flags;
diff --git a/kernel/mutex.c b/kernel/mutex.c
index e26d920..8804b06 100644
--- a/kernel/mutex.c
+++ b/kernel/mutex.c
@@ -241,10 +241,11 @@ __mutex_lock_common(struct mutex *lock, long state, unsigned int subclass,
 		__set_task_state(task, state);
 
 		/* didn't get the lock, go to sleep: */
-		event_log_mutex_wait(lock);
 		spin_unlock_mutex(&lock->wait_lock, flags);
 		preempt_enable_no_resched();
+		event_log_mutex_wait(lock);
 		schedule();
+		event_log_mutex_wake(lock);
 		preempt_disable();
 		spin_lock_mutex(&lock->wait_lock, flags);
 	}
@@ -334,7 +335,7 @@ __mutex_unlock_common_slowpath(atomic_t *lock_count, int nested)
 					   struct mutex_waiter, list);
 
 		debug_mutex_wake_waiter(lock, waiter);
-
+		event_log_mutex_notify(lock, waiter->task->pid);
 		wake_up_process(waiter->task);
 	}
 
-- 
1.9.1


From efadddba3d51c2e1959fa00baf969457e63eb530 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 21:04:44 -0400
Subject: [PATCH 19/72] eventlogging: learn to log process name changes.

---
 arch/arm/configs/tegra3_android_eventlogging_defconfig |  1 +
 fs/exec.c                                              |  3 +++
 include/eventlogging/events.h                          |  7 +++++++
 kernel/eventlogging/Kconfig                            |  4 ++++
 kernel/eventlogging/events.c                           | 14 ++++++++++++++
 5 files changed, 29 insertions(+)

diff --git a/arch/arm/configs/tegra3_android_eventlogging_defconfig b/arch/arm/configs/tegra3_android_eventlogging_defconfig
index 30058ce..c8dbb42 100644
--- a/arch/arm/configs/tegra3_android_eventlogging_defconfig
+++ b/arch/arm/configs/tegra3_android_eventlogging_defconfig
@@ -529,3 +529,4 @@ CONFIG_EVENT_MUTEX_LOCK=n
 CONFIG_EVENT_MUTEX_WAIT=y
 CONFIG_EVENT_MUTEX_WAKE=y
 CONFIG_EVENT_MUTEX_NOTIFY=y
+CONFIG_EVENT_THREAD_NAME=y
diff --git a/fs/exec.c b/fs/exec.c
index 044c13f..2b402c8 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -56,6 +56,8 @@
 #include <linux/oom.h>
 #include <linux/compat.h>
 
+#include <eventlogging/events.h>
+
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
 #include <asm/tlb.h>
@@ -1067,6 +1069,7 @@ void set_task_comm(struct task_struct *tsk, char *buf)
 	strlcpy(tsk->comm, buf, sizeof(tsk->comm));
 	task_unlock(tsk);
 	perf_event_comm(tsk);
+	event_log_thread_name(tsk);
 }
 
 int flush_old_exec(struct linux_binprm * bprm)
diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 5cbba75..3486d64 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -9,6 +9,7 @@
 
 #define EVENT_CONTEXT_SWITCH 10
 #define EVENT_FORK 15
+#define EVENT_THREAD_NAME 16
 
 #define EVENT_IO_BLOCK 20
 #define EVENT_IO_RESUME 21
@@ -56,6 +57,11 @@ struct fork_event {
   __le16 tgid;
 }__attribute__((packed));
 
+struct thread_name_event {
+  struct event_hdr hdr;
+  char comm[16];
+}__attribute__((packed));
+
 struct network_block_event {
   struct event_hdr hdr;
 }__attribute__((packed));
@@ -119,6 +125,7 @@ DEFINE_EVENT_LOG_FUNC(stream_resume, void);
 DEFINE_EVENT_LOG_FUNC(sock_block, void);
 DEFINE_EVENT_LOG_FUNC(sock_resume, void);
 DEFINE_EVENT_LOG_FUNC(fork, pid_t pid, pid_t tgid);
+DEFINE_EVENT_LOG_FUNC(thread_name, struct task_struct* task);
 DEFINE_EVENT_LOG_FUNC(mutex_lock, void* lock);
 DEFINE_EVENT_LOG_FUNC(mutex_wait, void* lock);
 DEFINE_EVENT_LOG_FUNC(mutex_wake, void* lock);
diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index a2eb036..3d13a76 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -74,5 +74,9 @@ config EVENT_MUTEX_NOTIFY
        bool "Log who wakes up a mutex"
        default yes
 
+config EVENT_THREAD_NAME
+       bool "Log when a process name is changed"
+       default yes
+
 endif
 
diff --git a/kernel/eventlogging/events.c b/kernel/eventlogging/events.c
index b41d350..1d7a7aa 100644
--- a/kernel/eventlogging/events.c
+++ b/kernel/eventlogging/events.c
@@ -100,6 +100,20 @@ void event_log_fork(pid_t pid, pid_t tgid) {
 #endif
 }
 
+void event_log_thread_name(struct task_struct* task) {
+#ifdef CONFIG_EVENT_THREAD_NAME
+   unsigned long flags;
+   struct thread_name_event event;
+  
+   local_irq_save(flags);
+   event_log_header_init(&event.hdr, EVENT_THREAD_NAME);
+   memcpy(event.comm, task->comm, min(16, TASK_COMM_LEN));
+   log_event(&event, sizeof(struct thread_name_event));
+   local_irq_restore(flags);
+#endif
+}
+
+
 void event_log_mutex_lock(void* lock) {
 #ifdef CONFIG_EVENT_MUTEX_LOCK
   unsigned long flags;
-- 
1.9.1


From fc99a5f1e3da3a8e0b97c6ecbea4fd6d58075b3b Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 21:14:39 -0400
Subject: [PATCH 20/72] eventlogging: learn to log missed event counts

---
 include/eventlogging/events.h |  6 ++++++
 kernel/eventlogging/logging.c | 22 +++++++++++++++++++---
 2 files changed, 25 insertions(+), 3 deletions(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 3486d64..726fdee 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -6,6 +6,7 @@
 #define EVENT_LOG_MAGIC "michigan"
 
 #define EVENT_SYNC_LOG 0
+#define EVENT_MISSED_COUNT 1
 
 #define EVENT_CONTEXT_SWITCH 10
 #define EVENT_FORK 15
@@ -45,6 +46,11 @@ struct sync_log_event {
   char magic[8];
 }__attribute__((packed));
 
+struct missed_count_event {
+  struct event_hdr hdr;
+  __le32 count;
+}__attribute__((packed));
+
 struct context_switch_event {
   struct event_hdr hdr;
   __le16 old_pid;
diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index d9b1635..9056fe7 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -12,12 +12,23 @@
 
 extern void event_log_header_init(struct event_hdr* event, u8 type);
 
-#define BUFFER_ORDER   10  // 2^10 = 4 MB with 4096 page size
-#define NUM_BUFFERS 32  // 32 * 4 MB = 128 MB total
+#define BUFFER_ORDER 10  // 2^10 = 4 MB with 4096 page size
+#define NUM_BUFFERS  32  // 32 * 4 MB = 128 MB total
 
 static DEFINE_PER_CPU(struct sbuffer*, sbuffers);
 static DEFINE_PER_CPU(unsigned int, missed_events);
 
+inline static void log_missed_count_event(struct sbuffer* buf) {
+  struct missed_count_event event;
+  int cnt = __get_cpu_var(missed_events);
+  if (0 == cnt)
+    return;
+  event_log_header_init(&event.hdr, EVENT_MISSED_COUNT);
+  event.count = __get_cpu_var(missed_events);
+  sbuffer_write(buf, (void*)&event, sizeof(struct missed_count_event));
+  __get_cpu_var(missed_events) = 0;
+}
+
 inline static void log_sync_event(struct sbuffer* buf) {
   struct sync_log_event event;
   event_log_header_init(&event.hdr, EVENT_SYNC_LOG);
@@ -25,10 +36,15 @@ inline static void log_sync_event(struct sbuffer* buf) {
   sbuffer_write(buf, (void*)&event, sizeof(struct sync_log_event));
 }
 
+static void init_new_buffer(struct sbuffer* buf) {
+  log_sync_event(buf);
+  log_missed_count_event(buf);
+}
+
 inline static struct sbuffer* __get_new_cpu_buffer(void) {
   struct sbuffer* buf = take_empty_try();
   if (NULL != buf)
-    log_sync_event(buf);
+    init_new_buffer(buf);
   return buf;
 }
 
-- 
1.9.1


From 94fd8af3b3d65df3f8b74085bf1f15f101b3edc3 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 24 Sep 2012 21:35:56 -0400
Subject: [PATCH 21/72] eventlogging: learn to log process exits

---
 arch/arm/configs/tegra3_android_eventlogging_defconfig | 1 +
 include/eventlogging/events.h                          | 6 ++++++
 kernel/eventlogging/Kconfig                            | 4 ++++
 kernel/eventlogging/events.c                           | 6 ++++++
 kernel/exit.c                                          | 3 +++
 5 files changed, 20 insertions(+)

diff --git a/arch/arm/configs/tegra3_android_eventlogging_defconfig b/arch/arm/configs/tegra3_android_eventlogging_defconfig
index c8dbb42..4c4dbe6 100644
--- a/arch/arm/configs/tegra3_android_eventlogging_defconfig
+++ b/arch/arm/configs/tegra3_android_eventlogging_defconfig
@@ -515,6 +515,7 @@ CONFIG_CRYPTO_DEV_TEGRA_SE=y
 CONFIG_EVENT_LOGGING=y
 CONFIG_EVENT_CONTEXT_SWITCH=n
 CONFIG_EVENT_FORK=y
+CONFIG_EVENT_EXIT=y
 CONFIG_EVENT_IO_BLOCK=y
 CONFIG_EVENT_IO_RESUME=y
 CONFIG_EVENT_DATAGRAM_BLOCK=y
diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 726fdee..b47b8f5 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -11,6 +11,7 @@
 #define EVENT_CONTEXT_SWITCH 10
 #define EVENT_FORK 15
 #define EVENT_THREAD_NAME 16
+#define EVENT_EXIT 17
 
 #define EVENT_IO_BLOCK 20
 #define EVENT_IO_RESUME 21
@@ -63,6 +64,10 @@ struct fork_event {
   __le16 tgid;
 }__attribute__((packed));
 
+struct exit_event {
+  struct event_hdr hdr;
+}__attribute__((packed));
+
 struct thread_name_event {
   struct event_hdr hdr;
   char comm[16];
@@ -131,6 +136,7 @@ DEFINE_EVENT_LOG_FUNC(stream_resume, void);
 DEFINE_EVENT_LOG_FUNC(sock_block, void);
 DEFINE_EVENT_LOG_FUNC(sock_resume, void);
 DEFINE_EVENT_LOG_FUNC(fork, pid_t pid, pid_t tgid);
+DEFINE_EVENT_LOG_FUNC(exit, void);
 DEFINE_EVENT_LOG_FUNC(thread_name, struct task_struct* task);
 DEFINE_EVENT_LOG_FUNC(mutex_lock, void* lock);
 DEFINE_EVENT_LOG_FUNC(mutex_wait, void* lock);
diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index 3d13a76..c14eb0e 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -18,6 +18,10 @@ config EVENT_FORK
        bool "Log forks"
        default yes
 
+config EVENT_EXIT
+       bool "Log when process exits"
+       default yes
+
 config EVENT_IO_BLOCK
        bool "Log IO blocks"
        default yes
diff --git a/kernel/eventlogging/events.c b/kernel/eventlogging/events.c
index 1d7a7aa..06f3076 100644
--- a/kernel/eventlogging/events.c
+++ b/kernel/eventlogging/events.c
@@ -100,6 +100,12 @@ void event_log_fork(pid_t pid, pid_t tgid) {
 #endif
 }
 
+void event_log_exit(void) {
+#ifdef CONFIG_EVENT_EXIT
+  event_log_simple(EVENT_EXIT);
+#endif
+}
+
 void event_log_thread_name(struct task_struct* task) {
 #ifdef CONFIG_EVENT_THREAD_NAME
    unsigned long flags;
diff --git a/kernel/exit.c b/kernel/exit.c
index 303bed2..4adf3ff 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -52,6 +52,8 @@
 #include <linux/hw_breakpoint.h>
 #include <linux/oom.h>
 
+#include <eventlogging/events.h>
+
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 #include <asm/pgtable.h>
@@ -905,6 +907,7 @@ NORET_TYPE void do_exit(long code)
 	int group_dead;
 
 	profile_task_exit(tsk);
+	event_log_exit();
 
 	WARN_ON(atomic_read(&tsk->fs_excl));
 	WARN_ON(blk_needs_flush_plug(tsk));
-- 
1.9.1


From 750c18118acc8a16df9dc324202c1b3e38741c6a Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Tue, 25 Sep 2012 13:07:05 -0400
Subject: [PATCH 22/72] eventlogging: learn to log idle start/end events

---
 .../configs/tegra3_android_eventlogging_defconfig  |  2 ++
 include/eventlogging/events.h                      | 14 +++++++++++
 kernel/eventlogging/Kconfig                        |  8 +++++++
 kernel/eventlogging/Makefile                       |  2 +-
 kernel/eventlogging/events.c                       | 12 ++++++++++
 kernel/eventlogging/idle.c                         | 28 ++++++++++++++++++++++
 kernel/eventlogging/idle.h                         |  6 +++++
 kernel/eventlogging/logging.c                      |  4 ++++
 8 files changed, 75 insertions(+), 1 deletion(-)
 create mode 100644 kernel/eventlogging/idle.c
 create mode 100644 kernel/eventlogging/idle.h

diff --git a/arch/arm/configs/tegra3_android_eventlogging_defconfig b/arch/arm/configs/tegra3_android_eventlogging_defconfig
index 4c4dbe6..c38382d 100644
--- a/arch/arm/configs/tegra3_android_eventlogging_defconfig
+++ b/arch/arm/configs/tegra3_android_eventlogging_defconfig
@@ -514,6 +514,8 @@ CONFIG_CRYPTO_TWOFISH=y
 CONFIG_CRYPTO_DEV_TEGRA_SE=y
 CONFIG_EVENT_LOGGING=y
 CONFIG_EVENT_CONTEXT_SWITCH=n
+CONFIG_EVENT_IDLE_START=y
+CONFIG_EVENT_IDLE_END=y
 CONFIG_EVENT_FORK=y
 CONFIG_EVENT_EXIT=y
 CONFIG_EVENT_IO_BLOCK=y
diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index b47b8f5..f222c31 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -9,6 +9,10 @@
 #define EVENT_MISSED_COUNT 1
 
 #define EVENT_CONTEXT_SWITCH 10
+
+#define EVENT_IDLE_START 13
+#define EVENT_IDLE_END 14
+
 #define EVENT_FORK 15
 #define EVENT_THREAD_NAME 16
 #define EVENT_EXIT 17
@@ -58,6 +62,14 @@ struct context_switch_event {
   __le16 new_pid;
 }__attribute__((packed));
 
+struct idle_start_event {
+  struct event_hdr hdr;
+}__attribute__((packed));
+
+struct idle_end_event {
+  struct event_hdr hdr;
+}__attribute__((packed));
+
 struct fork_event {
   struct event_hdr hdr;
   __le16 pid;
@@ -129,6 +141,8 @@ struct io_resume_event {
 #endif
 
 DEFINE_EVENT_LOG_FUNC(context_switch, pid_t old, pid_t new);
+DEFINE_EVENT_LOG_FUNC(idle_start, void);
+DEFINE_EVENT_LOG_FUNC(idle_end, void);
 DEFINE_EVENT_LOG_FUNC(datagram_block, void);
 DEFINE_EVENT_LOG_FUNC(datagram_resume, void);
 DEFINE_EVENT_LOG_FUNC(stream_block, void);
diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index c14eb0e..cb6a127 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -14,6 +14,14 @@ config EVENT_CONTEXT_SWITCH
        bool "Log context switches"
        default no
 
+config EVENT_IDLE_START
+       bool "Log when idle loop starts"
+       default yes
+
+config EVENT_IDLE_END
+       bool "Log when idle loop stops"
+       default yes
+
 config EVENT_FORK
        bool "Log forks"
        default yes
diff --git a/kernel/eventlogging/Makefile b/kernel/eventlogging/Makefile
index b57a43f..7400d13 100644
--- a/kernel/eventlogging/Makefile
+++ b/kernel/eventlogging/Makefile
@@ -1 +1 @@
-obj-$(CONFIG_EVENT_LOGGING) := logging.o proc_fs.o buffer.o events.o
+obj-$(CONFIG_EVENT_LOGGING) := logging.o proc_fs.o buffer.o events.o idle.o
diff --git a/kernel/eventlogging/events.c b/kernel/eventlogging/events.c
index 06f3076..62a43ca 100644
--- a/kernel/eventlogging/events.c
+++ b/kernel/eventlogging/events.c
@@ -38,6 +38,18 @@ void event_log_context_switch(pid_t old, pid_t new) {
 #endif
 }
 
+void event_log_idle_start(void) {
+#ifdef CONFIG_EVENT_IDLE_START
+  event_log_simple(EVENT_IDLE_START);
+#endif
+}
+
+void event_log_idle_end(void) {
+#ifdef CONFIG_EVENT_IDLE_END
+  event_log_simple(EVENT_IDLE_END);
+#endif
+}
+
 void event_log_datagram_block(void) {
 #ifdef CONFIG_EVENT_DATAGRAM_BLOCK
   event_log_simple(EVENT_DATAGRAM_BLOCK);
diff --git a/kernel/eventlogging/idle.c b/kernel/eventlogging/idle.c
new file mode 100644
index 0000000..1c5428d
--- /dev/null
+++ b/kernel/eventlogging/idle.c
@@ -0,0 +1,28 @@
+#include <linux/cpu.h>
+#include <linux/notifier.h>
+
+#include <eventlogging/events.h>
+
+#if defined(CONFIG_EVENT_IDLE_START) || defined(CONFIG_EVENT_IDLE_STOP)
+static struct notifier_block idle_notifier;
+
+static int idle_notifier_call(struct notifier_block* self, unsigned long event, void* data) {
+  switch (event) {
+  case IDLE_START:
+    event_log_idle_start();
+    break;
+  case IDLE_END:
+    event_log_idle_end();
+    break;
+  }
+  return 0;
+}
+
+__init int init_idle_notifier(void) {
+  idle_notifier.notifier_call = idle_notifier_call;
+  idle_notifier_register(&idle_notifier);
+  return 0;
+}
+#else
+__init int init_idle_notifier(void) {}
+#endif
diff --git a/kernel/eventlogging/idle.h b/kernel/eventlogging/idle.h
new file mode 100644
index 0000000..503c1d9
--- /dev/null
+++ b/kernel/eventlogging/idle.h
@@ -0,0 +1,6 @@
+#ifndef EVENT_LOGGING_IDLE_H
+#define EVENT_LOGGING_IDLE_H
+
+__init int init_idle_notifier(void);
+
+#endif
diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index 9056fe7..127c00b 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -9,6 +9,7 @@
 #include "logging.h"
 #include "buffer.h"
 #include "proc_fs.h"
+#include "idle.h"
 
 extern void event_log_header_init(struct event_hdr* event, u8 type);
 
@@ -167,4 +168,7 @@ static __init int init_proc_fs(void) {
 }
 
 early_initcall(init_alloc_buffers);
+early_initcall(init_idle_notifier);
 fs_initcall(init_proc_fs);
+
+
-- 
1.9.1


From ca6082aa8aeff8a6288352b7e685f4b5660bd7e9 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Tue, 25 Sep 2012 22:59:52 -0400
Subject: [PATCH 23/72] eventlogging: move log functions to header file to be
 inlined

---
 include/eventlogging/events.h | 236 +++++++++++++++++++++++++++++++++++++-----
 kernel/eventlogging/Makefile  |   2 +-
 kernel/eventlogging/events.c  | 212 -------------------------------------
 kernel/eventlogging/idle.c    |   2 +-
 kernel/eventlogging/logging.c |   2 -
 5 files changed, 213 insertions(+), 241 deletions(-)
 delete mode 100644 kernel/eventlogging/events.c

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index f222c31..e5d1b64 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -134,32 +134,218 @@ struct io_resume_event {
 
 #ifdef __KERNEL__
 
+#include <linux/time.h>
+#include <linux/sched.h>
+#include <linux/smp.h>
+
 #ifdef CONFIG_EVENT_LOGGING
-#define DEFINE_EVENT_LOG_FUNC(name, ...) void event_log_##name(__VA_ARGS__)
-#else
-#define DEFINE_EVENT_LOG_FUNC()name, ...) void event_log_##name(__VA_ARGS__){}
-#endif
-
-DEFINE_EVENT_LOG_FUNC(context_switch, pid_t old, pid_t new);
-DEFINE_EVENT_LOG_FUNC(idle_start, void);
-DEFINE_EVENT_LOG_FUNC(idle_end, void);
-DEFINE_EVENT_LOG_FUNC(datagram_block, void);
-DEFINE_EVENT_LOG_FUNC(datagram_resume, void);
-DEFINE_EVENT_LOG_FUNC(stream_block, void);
-DEFINE_EVENT_LOG_FUNC(stream_resume, void);
-DEFINE_EVENT_LOG_FUNC(sock_block, void);
-DEFINE_EVENT_LOG_FUNC(sock_resume, void);
-DEFINE_EVENT_LOG_FUNC(fork, pid_t pid, pid_t tgid);
-DEFINE_EVENT_LOG_FUNC(exit, void);
-DEFINE_EVENT_LOG_FUNC(thread_name, struct task_struct* task);
-DEFINE_EVENT_LOG_FUNC(mutex_lock, void* lock);
-DEFINE_EVENT_LOG_FUNC(mutex_wait, void* lock);
-DEFINE_EVENT_LOG_FUNC(mutex_wake, void* lock);
-DEFINE_EVENT_LOG_FUNC(mutex_notify, void* lock, pid_t pid);
-DEFINE_EVENT_LOG_FUNC(sem_lock, void* lock);
-DEFINE_EVENT_LOG_FUNC(sem_wait, void* lock);
-DEFINE_EVENT_LOG_FUNC(io_block, void);
-DEFINE_EVENT_LOG_FUNC(io_resume, void);
+extern void log_event(void* data, int len);
+#endif
+
+static inline void event_log_header_init(struct event_hdr* event, u8 type) {
+  struct timeval tv;
+  do_gettimeofday(&tv);
+
+  event->event_type = type;
+  event->tv_sec = tv.tv_sec;
+  event->tv_usec = tv.tv_usec;
+  event->cpu = smp_processor_id();
+  event->pid = current->pid;
+}
+
+static inline void event_log_simple(u8 event_type) {
+  unsigned long flags;
+  struct event_hdr event;
+  local_irq_save(flags);
+  event_log_header_init(&event, event_type);
+  log_event(&event, sizeof(struct event_hdr));
+  local_irq_restore(flags);
+}
+
+static inline void event_log_context_switch(pid_t old, pid_t new) {
+#ifdef CONFIG_EVENT_CONTEXT_SWITCH
+  unsigned long flags;
+  struct context_switch_event event;
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_CONTEXT_SWITCH);
+  event.old_pid = old;
+  event.new_pid = new;
+  log_event(&event, sizeof(struct context_switch_event));
+  local_irq_restore(flags);
+#endif
+}
+
+static inline void event_log_idle_start(void) {
+#ifdef CONFIG_EVENT_IDLE_START
+  event_log_simple(EVENT_IDLE_START);
+#endif
+}
+
+static inline void event_log_idle_end(void) {
+#ifdef CONFIG_EVENT_IDLE_END
+  event_log_simple(EVENT_IDLE_END);
+#endif
+}
+
+static inline void event_log_datagram_block(void) {
+#ifdef CONFIG_EVENT_DATAGRAM_BLOCK
+  event_log_simple(EVENT_DATAGRAM_BLOCK);
+#endif
+}
+
+static inline void event_log_datagram_resume(void) {
+#ifdef CONFIG_EVENT_DATAGRAM_RESUME
+  event_log_simple(EVENT_DATAGRAM_RESUME);
+#endif
+}
+
+static inline void event_log_stream_block(void) {
+#ifdef CONFIG_EVENT_STREAM_BLOCK
+  event_log_simple(EVENT_STREAM_BLOCK);
+#endif
+}
+
+static inline void event_log_stream_resume(void) {
+#ifdef CONFIG_EVENT_STREAM_RESUME
+  event_log_simple(EVENT_STREAM_RESUME);
+#endif
+}
+
+static inline void event_log_sock_block(void) {
+#ifdef CONFIG_EVENT_SOCK_BLOCK
+  event_log_simple(EVENT_SOCK_BLOCK);
+#endif
+}
+
+static inline void event_log_sock_resume(void) {
+#ifdef CONFIG_EVENT_SOCK_RESUME
+  event_log_simple(EVENT_SOCK_RESUME);
+#endif
+}
+
+static inline void event_log_io_block(void) {
+#ifdef CONFIG_EVENT_IO_BLOCK
+  event_log_simple(EVENT_IO_BLOCK);
+#endif
+}
+
+static inline void event_log_io_resume(void) {
+#ifdef CONFIG_EVENT_IO_RESUME
+  event_log_simple(EVENT_IO_RESUME);
+#endif
+}
+
+static inline void event_log_fork(pid_t pid, pid_t tgid) {
+#ifdef CONFIG_EVENT_FORK
+  unsigned long flags;
+  struct fork_event event;
+  
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_FORK);
+  event.pid = pid;
+  event.tgid = tgid;
+  log_event(&event, sizeof(struct fork_event));
+  local_irq_restore(flags);
+#endif
+}
+
+static inline void event_log_exit(void) {
+#ifdef CONFIG_EVENT_EXIT
+  event_log_simple(EVENT_EXIT);
+#endif
+}
+
+static inline void event_log_thread_name(struct task_struct* task) {
+#ifdef CONFIG_EVENT_THREAD_NAME
+   unsigned long flags;
+   struct thread_name_event event;
+  
+   local_irq_save(flags);
+   event_log_header_init(&event.hdr, EVENT_THREAD_NAME);
+   memcpy(event.comm, task->comm, min(16, TASK_COMM_LEN));
+   log_event(&event, sizeof(struct thread_name_event));
+   local_irq_restore(flags);
+#endif
+}
+
+static inline void event_log_mutex_lock(void* lock) {
+#ifdef CONFIG_EVENT_MUTEX_LOCK
+  unsigned long flags;
+  struct mutex_lock_event event;
+
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_MUTEX_LOCK);
+  event.lock = (__le32) lock;
+  log_event(&event, sizeof(struct mutex_lock_event));
+  local_irq_restore(flags);
+#endif
+}
+
+static inline void event_log_mutex_wait(void* lock) {
+#ifdef CONFIG_EVENT_MUTEX_WAIT
+  unsigned long flags;
+  struct mutex_wait_event event;
+
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_MUTEX_WAIT);
+  event.lock = (__le32) lock;
+  log_event(&event, sizeof(struct mutex_wait_event));
+  local_irq_restore(flags);
+#endif
+}
+
+static inline void event_log_mutex_wake(void* lock) {
+#ifdef CONFIG_EVENT_MUTEX_WAKE
+  unsigned long flags;
+  struct mutex_wake_event event;
+  
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_MUTEX_WAKE);
+  event.lock = (__le32) lock;
+  log_event(&event, sizeof(struct mutex_wake_event));
+  local_irq_restore(flags);
+#endif
+}
+
+static inline void event_log_mutex_notify(void* lock, pid_t pid) {
+#ifdef CONFIG_EVENT_MUTEX_WAKE
+  unsigned long flags;
+  struct mutex_notify_event event;
+  
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_MUTEX_NOTIFY);
+  event.lock = (__le32) lock;
+  event.pid = pid;
+  log_event(&event, sizeof(struct mutex_notify_event));
+  local_irq_restore(flags);
+#endif
+}
+
+static inline void event_log_sem_lock(void* lock) {
+#ifdef CONFIG_EVENT_SEMAPHORE_LOCK
+  unsigned long flags;
+  struct sem_lock_event event;
+
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_SEMAPHORE_LOCK);
+  event.lock = (__le32) lock;
+  log_event(&event, sizeof(struct sem_lock_event));
+  local_irq_restore(flags);
+#endif
+}
+
+static inline void event_log_sem_wait(void* lock) {
+#ifdef CONFIG_EVENT_SEMAPHORE_WAIT
+  unsigned long flags;
+  struct sem_wait_event event;
+
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_SEMAPHORE_WAIT);
+  event.lock = (__le32) lock;
+  log_event(&event, sizeof(struct sem_wait_event));
+  local_irq_restore(flags);
+#endif
+}
 
 #endif // __KERNEL__
 #endif // EVENTLOGGING_EVENTS_H
diff --git a/kernel/eventlogging/Makefile b/kernel/eventlogging/Makefile
index 7400d13..51ea68f 100644
--- a/kernel/eventlogging/Makefile
+++ b/kernel/eventlogging/Makefile
@@ -1 +1 @@
-obj-$(CONFIG_EVENT_LOGGING) := logging.o proc_fs.o buffer.o events.o idle.o
+obj-$(CONFIG_EVENT_LOGGING) := logging.o proc_fs.o buffer.o idle.o
diff --git a/kernel/eventlogging/events.c b/kernel/eventlogging/events.c
deleted file mode 100644
index 62a43ca..0000000
--- a/kernel/eventlogging/events.c
+++ /dev/null
@@ -1,212 +0,0 @@
-#include <linux/time.h>
-#include <linux/sched.h>
-#include <linux/smp.h>
-
-#include <eventlogging/events.h>
-#include "logging.h"
-
-inline void event_log_header_init(struct event_hdr* event, u8 type) {
-  struct timeval tv;
-  do_gettimeofday(&tv);
-
-  event->event_type = type;
-  event->tv_sec = tv.tv_sec;
-  event->tv_usec = tv.tv_usec;
-  event->cpu = smp_processor_id();
-  event->pid = current->pid;
-}
-
-static inline void event_log_simple(u8 event_type) {
-  unsigned long flags;
-  struct event_hdr event;
-  local_irq_save(flags);
-  event_log_header_init(&event, event_type);
-  log_event(&event, sizeof(struct event_hdr));
-  local_irq_restore(flags);
-}
-
-void event_log_context_switch(pid_t old, pid_t new) {
-#ifdef CONFIG_EVENT_CONTEXT_SWITCH
-  unsigned long flags;
-  struct context_switch_event event;
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_CONTEXT_SWITCH);
-  event.old_pid = old;
-  event.new_pid = new;
-  log_event(&event, sizeof(struct context_switch_event));
-  local_irq_restore(flags);
-#endif
-}
-
-void event_log_idle_start(void) {
-#ifdef CONFIG_EVENT_IDLE_START
-  event_log_simple(EVENT_IDLE_START);
-#endif
-}
-
-void event_log_idle_end(void) {
-#ifdef CONFIG_EVENT_IDLE_END
-  event_log_simple(EVENT_IDLE_END);
-#endif
-}
-
-void event_log_datagram_block(void) {
-#ifdef CONFIG_EVENT_DATAGRAM_BLOCK
-  event_log_simple(EVENT_DATAGRAM_BLOCK);
-#endif
-}
-
-void event_log_datagram_resume(void) {
-#ifdef CONFIG_EVENT_DATAGRAM_RESUME
-  event_log_simple(EVENT_DATAGRAM_RESUME);
-#endif
-}
-
-void event_log_stream_block(void) {
-#ifdef CONFIG_EVENT_STREAM_BLOCK
-  event_log_simple(EVENT_STREAM_BLOCK);
-#endif
-}
-
-void event_log_stream_resume(void) {
-#ifdef CONFIG_EVENT_STREAM_RESUME
-  event_log_simple(EVENT_STREAM_RESUME);
-#endif
-}
-
-void event_log_sock_block(void) {
-#ifdef CONFIG_EVENT_SOCK_BLOCK
-  event_log_simple(EVENT_SOCK_BLOCK);
-#endif
-}
-
-void event_log_sock_resume(void) {
-#ifdef CONFIG_EVENT_SOCK_RESUME
-  event_log_simple(EVENT_SOCK_RESUME);
-#endif
-}
-
-void event_log_io_block(void) {
-#ifdef CONFIG_EVENT_IO_BLOCK
-  event_log_simple(EVENT_IO_BLOCK);
-#endif
-}
-
-void event_log_io_resume(void) {
-#ifdef CONFIG_EVENT_IO_RESUME
-  event_log_simple(EVENT_IO_RESUME);
-#endif
-}
-
-void event_log_fork(pid_t pid, pid_t tgid) {
-#ifdef CONFIG_EVENT_FORK
-  unsigned long flags;
-  struct fork_event event;
-  
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_FORK);
-  event.pid = pid;
-  event.tgid = tgid;
-  log_event(&event, sizeof(struct fork_event));
-  local_irq_restore(flags);
-#endif
-}
-
-void event_log_exit(void) {
-#ifdef CONFIG_EVENT_EXIT
-  event_log_simple(EVENT_EXIT);
-#endif
-}
-
-void event_log_thread_name(struct task_struct* task) {
-#ifdef CONFIG_EVENT_THREAD_NAME
-   unsigned long flags;
-   struct thread_name_event event;
-  
-   local_irq_save(flags);
-   event_log_header_init(&event.hdr, EVENT_THREAD_NAME);
-   memcpy(event.comm, task->comm, min(16, TASK_COMM_LEN));
-   log_event(&event, sizeof(struct thread_name_event));
-   local_irq_restore(flags);
-#endif
-}
-
-
-void event_log_mutex_lock(void* lock) {
-#ifdef CONFIG_EVENT_MUTEX_LOCK
-  unsigned long flags;
-  struct mutex_lock_event event;
-
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_MUTEX_LOCK);
-  event.lock = (__le32) lock;
-  log_event(&event, sizeof(struct mutex_lock_event));
-  local_irq_restore(flags);
-#endif
-}
-
-void event_log_mutex_wait(void* lock) {
-#ifdef CONFIG_EVENT_MUTEX_WAIT
-  unsigned long flags;
-  struct mutex_wait_event event;
-
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_MUTEX_WAIT);
-  event.lock = (__le32) lock;
-  log_event(&event, sizeof(struct mutex_wait_event));
-  local_irq_restore(flags);
-#endif
-}
-
-void event_log_mutex_wake(void* lock) {
-#ifdef CONFIG_EVENT_MUTEX_WAKE
-  unsigned long flags;
-  struct mutex_wake_event event;
-  
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_MUTEX_WAKE);
-  event.lock = (__le32) lock;
-  log_event(&event, sizeof(struct mutex_wake_event));
-  local_irq_restore(flags);
-#endif
-}
-
-void event_log_mutex_notify(void* lock, pid_t pid) {
-#ifdef CONFIG_EVENT_MUTEX_WAKE
-  unsigned long flags;
-  struct mutex_notify_event event;
-  
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_MUTEX_NOTIFY);
-  event.lock = (__le32) lock;
-  event.pid = pid;
-  log_event(&event, sizeof(struct mutex_notify_event));
-  local_irq_restore(flags);
-#endif
-}
-
-void event_log_sem_lock(void* lock) {
-#ifdef CONFIG_EVENT_SEMAPHORE_LOCK
-  unsigned long flags;
-  struct sem_lock_event event;
-
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_SEMAPHORE_LOCK);
-  event.lock = (__le32) lock;
-  log_event(&event, sizeof(struct sem_lock_event));
-  local_irq_restore(flags);
-#endif
-}
-
-void event_log_sem_wait(void* lock) {
-#ifdef CONFIG_EVENT_SEMAPHORE_WAIT
-  unsigned long flags;
-  struct sem_wait_event event;
-
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_SEMAPHORE_WAIT);
-  event.lock = (__le32) lock;
-  log_event(&event, sizeof(struct sem_wait_event));
-  local_irq_restore(flags);
-#endif
-}
diff --git a/kernel/eventlogging/idle.c b/kernel/eventlogging/idle.c
index 1c5428d..60074a1 100644
--- a/kernel/eventlogging/idle.c
+++ b/kernel/eventlogging/idle.c
@@ -24,5 +24,5 @@ __init int init_idle_notifier(void) {
   return 0;
 }
 #else
-__init int init_idle_notifier(void) {}
+__init int init_idle_notifier(void) {return 0;}
 #endif
diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index 127c00b..80d08d6 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -11,8 +11,6 @@
 #include "proc_fs.h"
 #include "idle.h"
 
-extern void event_log_header_init(struct event_hdr* event, u8 type);
-
 #define BUFFER_ORDER 10  // 2^10 = 4 MB with 4096 page size
 #define NUM_BUFFERS  32  // 32 * 4 MB = 128 MB total
 
-- 
1.9.1


From 1087fe16b5795a30041b31de410d3ad1ec23ec3f Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Tue, 25 Sep 2012 23:21:28 -0400
Subject: [PATCH 24/72] eventlogging: log kernel thread name as creation

---
 kernel/kthread.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/kernel/kthread.c b/kernel/kthread.c
index 4ba7ccc..62dd466 100644
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@ -18,6 +18,8 @@
 #include <linux/freezer.h>
 #include <trace/events/sched.h>
 
+#include <eventlogging/events.h>
+
 static DEFINE_SPINLOCK(kthread_create_lock);
 static LIST_HEAD(kthread_create_list);
 struct task_struct *kthreadd_task;
@@ -174,6 +176,7 @@ struct task_struct *kthread_create_on_node(int (*threadfn)(void *data),
 		vsnprintf(create.result->comm, sizeof(create.result->comm),
 			  namefmt, args);
 		va_end(args);
+		event_log_thread_name(create.result);
 		/*
 		 * root may have changed our (kthreadd's) priority or CPU mask.
 		 * The kernel thread should not inherit these properties.
-- 
1.9.1


From 1658bcb16e65c3d50260358870fcccdc0c6bad3c Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Wed, 26 Sep 2012 00:27:39 -0400
Subject: [PATCH 25/72] eventlogging: explicity log pid in thread name event

The executing pid is not always the pid whose name is changed. E.g.,
init starts a lot of kernel threads and sets their names.  So, we need
to log the pid associated with the new name explicity.
---
 include/eventlogging/events.h | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index e5d1b64..0e322c3 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -82,6 +82,7 @@ struct exit_event {
 
 struct thread_name_event {
   struct event_hdr hdr;
+  __u16 pid;
   char comm[16];
 }__attribute__((packed));
 
@@ -138,6 +139,8 @@ struct io_resume_event {
 #include <linux/sched.h>
 #include <linux/smp.h>
 
+
+
 #ifdef CONFIG_EVENT_LOGGING
 extern void log_event(void* data, int len);
 #endif
@@ -262,6 +265,7 @@ static inline void event_log_thread_name(struct task_struct* task) {
   
    local_irq_save(flags);
    event_log_header_init(&event.hdr, EVENT_THREAD_NAME);
+   event.pid = task->pid;
    memcpy(event.comm, task->comm, min(16, TASK_COMM_LEN));
    log_event(&event, sizeof(struct thread_name_event));
    local_irq_restore(flags);
-- 
1.9.1


From cba27815f9b102481ae41866b09d2c3cbfe11222 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Wed, 26 Sep 2012 00:30:57 -0400
Subject: [PATCH 26/72] eventlogging: put all shared event logging methods in
 ifdef

---
 include/eventlogging/events.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 0e322c3..fda906a 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -143,7 +143,6 @@ struct io_resume_event {
 
 #ifdef CONFIG_EVENT_LOGGING
 extern void log_event(void* data, int len);
-#endif
 
 static inline void event_log_header_init(struct event_hdr* event, u8 type) {
   struct timeval tv;
@@ -164,6 +163,7 @@ static inline void event_log_simple(u8 event_type) {
   log_event(&event, sizeof(struct event_hdr));
   local_irq_restore(flags);
 }
+#endif
 
 static inline void event_log_context_switch(pid_t old, pid_t new) {
 #ifdef CONFIG_EVENT_CONTEXT_SWITCH
-- 
1.9.1


From dd4643af513b149f363e2283cd4893258d55e00e Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Wed, 26 Sep 2012 00:58:38 -0400
Subject: [PATCH 27/72] eventlogging: fix event type identifier for IPC wait

---
 include/eventlogging/events.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index fda906a..5dd8c9e 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -36,7 +36,7 @@
 #define EVENT_MUTEX_NOTIFY 53
 
 #define EVENT_IPC_LOCK 60
-#define EVENT_IPC_WAIT 11
+#define EVENT_IPC_WAIT 61
 
 struct event_hdr {
   __u8  event_type;
-- 
1.9.1


From 4339c5f194a2ba3a4ab568935e669d3fb098b7e8 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Wed, 26 Sep 2012 01:30:49 -0400
Subject: [PATCH 28/72] eventlogging: learn to log cpu hotplug events

---
 .../configs/tegra3_android_eventlogging_defconfig  |  3 ++
 include/eventlogging/events.h                      | 39 +++++++++++++++++++++
 kernel/eventlogging/Kconfig                        | 12 +++++++
 kernel/eventlogging/Makefile                       |  2 +-
 kernel/eventlogging/hotcpu.c                       | 40 ++++++++++++++++++++++
 kernel/eventlogging/hotcpu.h                       |  6 ++++
 kernel/eventlogging/logging.c                      |  2 ++
 7 files changed, 103 insertions(+), 1 deletion(-)
 create mode 100644 kernel/eventlogging/hotcpu.c
 create mode 100644 kernel/eventlogging/hotcpu.h

diff --git a/arch/arm/configs/tegra3_android_eventlogging_defconfig b/arch/arm/configs/tegra3_android_eventlogging_defconfig
index c38382d..549c0f5 100644
--- a/arch/arm/configs/tegra3_android_eventlogging_defconfig
+++ b/arch/arm/configs/tegra3_android_eventlogging_defconfig
@@ -513,6 +513,9 @@ CONFIG_CRYPTO_TWOFISH=y
 # CONFIG_CRYPTO_ANSI_CPRNG is not set
 CONFIG_CRYPTO_DEV_TEGRA_SE=y
 CONFIG_EVENT_LOGGING=y
+CONFIG_EVENT_CPU_ONLINE=y
+CONFIG_EVENT_CPU_DOWN_PREPARE=y
+CONFIG_EVENT_CPU_DEAD=y
 CONFIG_EVENT_CONTEXT_SWITCH=n
 CONFIG_EVENT_IDLE_START=y
 CONFIG_EVENT_IDLE_END=y
diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 5dd8c9e..fcedd75 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -8,6 +8,10 @@
 #define EVENT_SYNC_LOG 0
 #define EVENT_MISSED_COUNT 1
 
+#define EVENT_CPU_ONLINE 5
+#define EVENT_CPU_DOWN_PREPARE 6
+#define EVENT_CPU_DEAD 7
+
 #define EVENT_CONTEXT_SWITCH 10
 
 #define EVENT_IDLE_START 13
@@ -62,6 +66,11 @@ struct context_switch_event {
   __le16 new_pid;
 }__attribute__((packed));
 
+struct hotcpu_event {
+  struct event_hdr hdr;
+  __u8 cpu;
+}__attribute__((packed));
+
 struct idle_start_event {
   struct event_hdr hdr;
 }__attribute__((packed));
@@ -178,6 +187,36 @@ static inline void event_log_context_switch(pid_t old, pid_t new) {
 #endif
 }
 
+#if defined(CONFIG_EVENT_CPU_ONLINE) || defined(CONFIG_EVENT_CPU_DEAD) || defined(CONFIG_EVENT_CPU_DOWN_PREPARE)
+static inline void event_log_hotcpu(unsigned int cpu, u8 event_type) {
+  unsigned long flags;
+  struct hotcpu_event event;
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, event_type);
+  event.cpu = cpu;
+  log_event(&event, sizeof(struct hotcpu_event));
+  local_irq_restore(flags);
+}
+#endif
+
+static inline void event_log_cpu_online(unsigned int cpu) {
+#ifdef CONFIG_EVENT_CPU_ONLINE
+  event_log_hotcpu(cpu, EVENT_CPU_ONLINE);
+#endif
+}
+
+static inline void event_log_cpu_down_prepare(unsigned int cpu) {
+#ifdef CONFIG_EVENT_CPU_DOWN_PREPARE
+  event_log_hotcpu(cpu, EVENT_CPU_DOWN_PREPARE);
+#endif
+}
+
+static inline void event_log_cpu_dead(unsigned int cpu) {
+#ifdef CONFIG_EVENT_CPU_DEAD
+  event_log_hotcpu(cpu, EVENT_CPU_DEAD);
+#endif
+}
+
 static inline void event_log_idle_start(void) {
 #ifdef CONFIG_EVENT_IDLE_START
   event_log_simple(EVENT_IDLE_START);
diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index cb6a127..32907ee 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -10,6 +10,18 @@ menuconfig EVENT_LOGGING
 
 if EVENT_LOGGING
 
+config EVENT_CPU_ONLINE
+       bool "Log when cpu comes online"
+       default yes
+
+config EVENT_CPU_DOWN_PREPARE
+       bool "Log when cpu prepares to go offline"
+       default yes
+
+config EVENT_CPU_DEAD
+       bool "Log when cpu goes offline"
+       default yes
+
 config EVENT_CONTEXT_SWITCH
        bool "Log context switches"
        default no
diff --git a/kernel/eventlogging/Makefile b/kernel/eventlogging/Makefile
index 51ea68f..3bb8914 100644
--- a/kernel/eventlogging/Makefile
+++ b/kernel/eventlogging/Makefile
@@ -1 +1 @@
-obj-$(CONFIG_EVENT_LOGGING) := logging.o proc_fs.o buffer.o idle.o
+obj-$(CONFIG_EVENT_LOGGING) := logging.o proc_fs.o buffer.o idle.o hotcpu.o
diff --git a/kernel/eventlogging/hotcpu.c b/kernel/eventlogging/hotcpu.c
new file mode 100644
index 0000000..ade6a24
--- /dev/null
+++ b/kernel/eventlogging/hotcpu.c
@@ -0,0 +1,40 @@
+#include <linux/cpu.h>
+#include <linux/notifier.h>
+
+#include <eventlogging/events.h>
+
+#if defined(CONFIG_EVENT_CPU_ONLINE) || defined(CONFIG_EVENT_CPU_DEAD) || defined(CONFIG_EVENT_CPU_DOWN_PREPARE)
+
+static int hotcpu_notifier_call(struct notifier_block* self, unsigned long event, void* hcpu) {
+  unsigned int cpu = (unsigned long) hcpu;
+
+  switch (event) {
+  case CPU_ONLINE:
+  case CPU_ONLINE_FROZEN:
+    event_log_cpu_online(cpu);
+    break;
+  case CPU_DOWN_PREPARE:
+  case CPU_DOWN_PREPARE_FROZEN:
+    event_log_cpu_down_prepare(cpu);
+    break;
+  case CPU_DEAD:
+  case CPU_DEAD_FROZEN:
+    event_log_cpu_dead(cpu);
+    break;
+  }
+  return NOTIFY_OK;
+}
+
+static struct notifier_block hotcpu_notifier = {
+  .notifier_call = hotcpu_notifier_call
+};
+
+__init int init_hotcpu_notifier(void) {
+  register_cpu_notifier(&hotcpu_notifier);
+  return 0;
+}
+#else
+__init int init_hotcpu_notifier(void){
+  return 0;
+}
+#endif
diff --git a/kernel/eventlogging/hotcpu.h b/kernel/eventlogging/hotcpu.h
new file mode 100644
index 0000000..1daa1ac
--- /dev/null
+++ b/kernel/eventlogging/hotcpu.h
@@ -0,0 +1,6 @@
+#ifndef EVENT_LOGGING_HOTCPU_H
+#define EVENT_LOGGING_HOTCPU_H
+
+__init int init_hotcpu_notifier(void);
+
+#endif
diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index 80d08d6..10e2ca2 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -10,6 +10,7 @@
 #include "buffer.h"
 #include "proc_fs.h"
 #include "idle.h"
+#include "hotcpu.h"
 
 #define BUFFER_ORDER 10  // 2^10 = 4 MB with 4096 page size
 #define NUM_BUFFERS  32  // 32 * 4 MB = 128 MB total
@@ -167,6 +168,7 @@ static __init int init_proc_fs(void) {
 
 early_initcall(init_alloc_buffers);
 early_initcall(init_idle_notifier);
+early_initcall(init_hotcpu_notifier);
 fs_initcall(init_proc_fs);
 
 
-- 
1.9.1


From 14f8d4dc28b7a02d2e6af9cab64d6126e30d13d3 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Wed, 26 Sep 2012 01:44:46 -0400
Subject: [PATCH 29/72] eventlogging: add context switch and remove idle events
 from defconfig

---
 arch/arm/configs/tegra3_android_eventlogging_defconfig | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/arch/arm/configs/tegra3_android_eventlogging_defconfig b/arch/arm/configs/tegra3_android_eventlogging_defconfig
index 549c0f5..50e148e 100644
--- a/arch/arm/configs/tegra3_android_eventlogging_defconfig
+++ b/arch/arm/configs/tegra3_android_eventlogging_defconfig
@@ -516,9 +516,9 @@ CONFIG_EVENT_LOGGING=y
 CONFIG_EVENT_CPU_ONLINE=y
 CONFIG_EVENT_CPU_DOWN_PREPARE=y
 CONFIG_EVENT_CPU_DEAD=y
-CONFIG_EVENT_CONTEXT_SWITCH=n
-CONFIG_EVENT_IDLE_START=y
-CONFIG_EVENT_IDLE_END=y
+CONFIG_EVENT_CONTEXT_SWITCH=y
+CONFIG_EVENT_IDLE_START=n
+CONFIG_EVENT_IDLE_END=n
 CONFIG_EVENT_FORK=y
 CONFIG_EVENT_EXIT=y
 CONFIG_EVENT_IO_BLOCK=y
-- 
1.9.1


From 31155458723236bf81e7d7e269cf2c8f47d66bb1 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Wed, 26 Sep 2012 01:57:57 -0400
Subject: [PATCH 30/72] eventlogging: learn to log suspend/resume events

---
 .../configs/tegra3_android_eventlogging_defconfig  |  2 ++
 include/eventlogging/events.h                      | 18 ++++++++++++
 kernel/eventlogging/Kconfig                        |  8 ++++++
 kernel/eventlogging/Makefile                       |  2 +-
 kernel/eventlogging/logging.c                      |  2 ++
 kernel/eventlogging/suspend.c                      | 32 ++++++++++++++++++++++
 kernel/eventlogging/suspend.h                      |  6 ++++
 7 files changed, 69 insertions(+), 1 deletion(-)
 create mode 100644 kernel/eventlogging/suspend.c
 create mode 100644 kernel/eventlogging/suspend.h

diff --git a/arch/arm/configs/tegra3_android_eventlogging_defconfig b/arch/arm/configs/tegra3_android_eventlogging_defconfig
index 50e148e..6b45d1a 100644
--- a/arch/arm/configs/tegra3_android_eventlogging_defconfig
+++ b/arch/arm/configs/tegra3_android_eventlogging_defconfig
@@ -516,6 +516,8 @@ CONFIG_EVENT_LOGGING=y
 CONFIG_EVENT_CPU_ONLINE=y
 CONFIG_EVENT_CPU_DOWN_PREPARE=y
 CONFIG_EVENT_CPU_DEAD=y
+CONFIG_EVENT_SUSPEND_PREPARE=y
+CONFIG_EVENT_POST_SUSPEND=y
 CONFIG_EVENT_CONTEXT_SWITCH=y
 CONFIG_EVENT_IDLE_START=n
 CONFIG_EVENT_IDLE_END=n
diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index fcedd75..93ce8d1 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -11,6 +11,8 @@
 #define EVENT_CPU_ONLINE 5
 #define EVENT_CPU_DOWN_PREPARE 6
 #define EVENT_CPU_DEAD 7
+#define EVENT_SUSPEND_PREPARE 8
+#define EVENT_POST_SUSPEND 9
 
 #define EVENT_CONTEXT_SWITCH 10
 
@@ -71,6 +73,10 @@ struct hotcpu_event {
   __u8 cpu;
 }__attribute__((packed));
 
+struct suspend_event {
+  struct event_hdr hdr;
+}__attribute__((packed));
+
 struct idle_start_event {
   struct event_hdr hdr;
 }__attribute__((packed));
@@ -217,6 +223,18 @@ static inline void event_log_cpu_dead(unsigned int cpu) {
 #endif
 }
 
+static inline void event_log_suspend_prepare(void) {
+#ifdef CONFIG_EVENT_SUSPEND_PREPARE
+  event_log_simple(EVENT_SUSPEND_PREPARE);
+#endif
+}
+
+static inline void event_log_post_suspend(void) {
+#ifdef CONFIG_EVENT_POST_SUSPEND
+  event_log_simple(EVENT_POST_SUSPEND);
+#endif
+}
+
 static inline void event_log_idle_start(void) {
 #ifdef CONFIG_EVENT_IDLE_START
   event_log_simple(EVENT_IDLE_START);
diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index 32907ee..26adf44 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -22,6 +22,14 @@ config EVENT_CPU_DEAD
        bool "Log when cpu goes offline"
        default yes
 
+config EVENT_SUSPEND_PREPARE
+       bool "Log when the system is preparing to suspend"
+       default yes
+
+config EVENT_POST_SUSPEND
+       bool "Log when the system resumes from suspend"
+       default yes
+
 config EVENT_CONTEXT_SWITCH
        bool "Log context switches"
        default no
diff --git a/kernel/eventlogging/Makefile b/kernel/eventlogging/Makefile
index 3bb8914..b06888f 100644
--- a/kernel/eventlogging/Makefile
+++ b/kernel/eventlogging/Makefile
@@ -1 +1 @@
-obj-$(CONFIG_EVENT_LOGGING) := logging.o proc_fs.o buffer.o idle.o hotcpu.o
+obj-$(CONFIG_EVENT_LOGGING) := logging.o proc_fs.o buffer.o idle.o hotcpu.o suspend.o
diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index 10e2ca2..9ff8584 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -11,6 +11,7 @@
 #include "proc_fs.h"
 #include "idle.h"
 #include "hotcpu.h"
+#include "suspend.h"
 
 #define BUFFER_ORDER 10  // 2^10 = 4 MB with 4096 page size
 #define NUM_BUFFERS  32  // 32 * 4 MB = 128 MB total
@@ -169,6 +170,7 @@ static __init int init_proc_fs(void) {
 early_initcall(init_alloc_buffers);
 early_initcall(init_idle_notifier);
 early_initcall(init_hotcpu_notifier);
+early_initcall(init_suspend_notifier);
 fs_initcall(init_proc_fs);
 
 
diff --git a/kernel/eventlogging/suspend.c b/kernel/eventlogging/suspend.c
new file mode 100644
index 0000000..24667b8
--- /dev/null
+++ b/kernel/eventlogging/suspend.c
@@ -0,0 +1,32 @@
+#include <linux/suspend.h>
+#include <linux/notifier.h>
+
+#include <eventlogging/events.h>
+
+#if defined(CONFIG_EVENT_SUSPEND_PREPARE) || defined(CONFIG_EVENT_POST_SUSPEND)
+
+static int suspend_notifier_call(struct notifier_block* self, unsigned long event, void* empty) {
+  switch (event) {
+  case PM_SUSPEND_PREPARE:
+    event_log_suspend_prepare();
+    break;
+  case PM_POST_SUSPEND:
+    event_log_post_suspend();
+    break;
+  }
+  return NOTIFY_OK;
+}
+
+static struct notifier_block suspend_notifier = {
+  .notifier_call = suspend_notifier_call
+};
+
+__init int init_suspend_notifier(void) {
+  register_pm_notifier(&suspend_notifier);
+  return 0;
+}
+#else
+__init int init_suspend_notifier(void){
+  return 0;
+}
+#endif
diff --git a/kernel/eventlogging/suspend.h b/kernel/eventlogging/suspend.h
new file mode 100644
index 0000000..f79ad46
--- /dev/null
+++ b/kernel/eventlogging/suspend.h
@@ -0,0 +1,6 @@
+#ifndef EVENT_LOGGING_SUSPEND_H
+#define EVENT_LOGGING_SUSPEND_H
+
+__init int init_suspend_notifier(void);
+
+#endif
-- 
1.9.1


From 3fc6c0a946a19a258a4230b03be6bdff4faacc35 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Wed, 26 Sep 2012 02:09:14 -0400
Subject: [PATCH 31/72] eventlogging: wake_up in put_full can deadlock, so
 don't wakeup for now

---
 kernel/eventlogging/buffer.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/kernel/eventlogging/buffer.c b/kernel/eventlogging/buffer.c
index 9f3314e..dd67335 100644
--- a/kernel/eventlogging/buffer.c
+++ b/kernel/eventlogging/buffer.c
@@ -88,7 +88,7 @@ void put_full(struct sbuffer* buf) {
   spin_lock_irqsave(&full_lock, flags);
   list_add_tail(&buf->list, &full_list);
   spin_unlock_irqrestore(&full_lock, flags);
-  wake_up_interruptible(&full_wait);
+  //wake_up_interruptible(&full_wait);
 }
 
 struct sbuffer* take_empty_try(void) {
-- 
1.9.1


From 93a6d500c97bf7c406d3cb279d9b7fb097eb6768 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Wed, 26 Sep 2012 21:21:01 -0400
Subject: [PATCH 32/72] eventlogging: learn to log wake lock/unlock events

---
 .../configs/tegra3_android_eventlogging_defconfig  |  2 ++
 include/eventlogging/events.h                      | 40 +++++++++++++++++++++-
 kernel/eventlogging/Kconfig                        |  8 +++++
 kernel/power/wakelock.c                            |  5 +++
 4 files changed, 54 insertions(+), 1 deletion(-)

diff --git a/arch/arm/configs/tegra3_android_eventlogging_defconfig b/arch/arm/configs/tegra3_android_eventlogging_defconfig
index 6b45d1a..cf1d1e0 100644
--- a/arch/arm/configs/tegra3_android_eventlogging_defconfig
+++ b/arch/arm/configs/tegra3_android_eventlogging_defconfig
@@ -516,6 +516,8 @@ CONFIG_EVENT_LOGGING=y
 CONFIG_EVENT_CPU_ONLINE=y
 CONFIG_EVENT_CPU_DOWN_PREPARE=y
 CONFIG_EVENT_CPU_DEAD=y
+CONFIG_EVENT_WAKE_LOCK=y
+CONFIG_EVENT_WAKE_UNLOCK=y
 CONFIG_EVENT_SUSPEND_PREPARE=y
 CONFIG_EVENT_POST_SUSPEND=y
 CONFIG_EVENT_CONTEXT_SWITCH=y
diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 93ce8d1..d3240ec 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -18,7 +18,6 @@
 
 #define EVENT_IDLE_START 13
 #define EVENT_IDLE_END 14
-
 #define EVENT_FORK 15
 #define EVENT_THREAD_NAME 16
 #define EVENT_EXIT 17
@@ -44,6 +43,9 @@
 #define EVENT_IPC_LOCK 60
 #define EVENT_IPC_WAIT 61
 
+#define EVENT_WAKE_LOCK 70
+#define EVENT_WAKE_UNLOCK 71
+
 struct event_hdr {
   __u8  event_type;
   __u8  cpu;
@@ -73,6 +75,17 @@ struct hotcpu_event {
   __u8 cpu;
 }__attribute__((packed));
 
+struct wake_lock_event {
+  struct event_hdr hdr;
+  __le32 lock;
+  __le32 timeout;
+}__attribute__((packed));
+
+struct wake_unlock_event {
+  struct event_hdr hdr;
+  __le32 lock;
+}__attribute__((packed));
+
 struct suspend_event {
   struct event_hdr hdr;
 }__attribute__((packed));
@@ -295,6 +308,31 @@ static inline void event_log_io_resume(void) {
 #endif
 }
 
+static inline void event_log_wake_lock(void* lock, long timeout) {
+#ifdef CONFIG_EVENT_WAKE_LOCK
+  unsigned long flags;
+  struct wake_lock_event event;
+  
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_WAKE_LOCK);
+  event.lock = (__le32) lock;
+  event.timeout = timeout;
+  log_event(&event, sizeof(struct wake_lock_event));
+  local_irq_restore(flags);
+#endif
+}
+
+static inline void event_log_wake_unlock(void* lock) {
+  unsigned long flags;
+  struct wake_unlock_event event;
+  
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_WAKE_UNLOCK);
+  event.lock = (__le32) lock;
+  log_event(&event, sizeof(struct wake_unlock_event));
+  local_irq_restore(flags);
+}
+
 static inline void event_log_fork(pid_t pid, pid_t tgid) {
 #ifdef CONFIG_EVENT_FORK
   unsigned long flags;
diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index 26adf44..7c900ba 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -22,6 +22,14 @@ config EVENT_CPU_DEAD
        bool "Log when cpu goes offline"
        default yes
 
+config EVENT_WAKE_LOCK
+       bool "Log when a kernel wakelock is acquired"
+       default yes
+
+config EVENT_WAKE_UNLOCK
+       bool "Log when a kernel wakelock is released"
+       default yes
+
 config EVENT_SUSPEND_PREPARE
        bool "Log when the system is preparing to suspend"
        default yes
diff --git a/kernel/power/wakelock.c b/kernel/power/wakelock.c
index 81e1b7c..3e077bc 100644
--- a/kernel/power/wakelock.c
+++ b/kernel/power/wakelock.c
@@ -24,6 +24,8 @@
 #endif
 #include "power.h"
 
+#include <eventlogging/events.h>
+
 enum {
 	DEBUG_EXIT_SUSPEND = 1U << 0,
 	DEBUG_WAKEUP = 1U << 1,
@@ -489,12 +491,14 @@ static void wake_lock_internal(
 
 void wake_lock(struct wake_lock *lock)
 {
+	event_log_wake_lock(lock, 0);
 	wake_lock_internal(lock, 0, 0);
 }
 EXPORT_SYMBOL(wake_lock);
 
 void wake_lock_timeout(struct wake_lock *lock, long timeout)
 {
+	event_log_wake_lock(lock, timeout);
 	wake_lock_internal(lock, timeout, 1);
 }
 EXPORT_SYMBOL(wake_lock_timeout);
@@ -505,6 +509,7 @@ void wake_unlock(struct wake_lock *lock)
 	unsigned long irqflags;
 	spin_lock_irqsave(&list_lock, irqflags);
 	type = lock->flags & WAKE_LOCK_TYPE_MASK;
+	event_log_wake_unlock(lock);
 #ifdef CONFIG_WAKELOCK_STAT
 	wake_unlock_stat_locked(lock, 0);
 #endif
-- 
1.9.1


From fe11818d446b413896447a674850eeacd005d95e Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Wed, 26 Sep 2012 21:27:19 -0400
Subject: [PATCH 33/72] eventlogging: remove suspend notifier logging

This reverts commit 3cc1e097aee1881b4d0798a8d135b868e1066a96.

The suspend notifier is executed at an indeterminate time between the
suspend request and the device actually suspending, so its log event
is not too useful.  A future commit will instead log at the suspend
start and just before the device sleeps (ditto for resume).
---
 .../configs/tegra3_android_eventlogging_defconfig  |  2 --
 include/eventlogging/events.h                      | 14 ----------
 kernel/eventlogging/Kconfig                        |  8 ------
 kernel/eventlogging/Makefile                       |  2 +-
 kernel/eventlogging/logging.c                      |  2 --
 kernel/eventlogging/suspend.c                      | 32 ----------------------
 kernel/eventlogging/suspend.h                      |  6 ----
 7 files changed, 1 insertion(+), 65 deletions(-)
 delete mode 100644 kernel/eventlogging/suspend.c
 delete mode 100644 kernel/eventlogging/suspend.h

diff --git a/arch/arm/configs/tegra3_android_eventlogging_defconfig b/arch/arm/configs/tegra3_android_eventlogging_defconfig
index cf1d1e0..1f4e3b1 100644
--- a/arch/arm/configs/tegra3_android_eventlogging_defconfig
+++ b/arch/arm/configs/tegra3_android_eventlogging_defconfig
@@ -518,8 +518,6 @@ CONFIG_EVENT_CPU_DOWN_PREPARE=y
 CONFIG_EVENT_CPU_DEAD=y
 CONFIG_EVENT_WAKE_LOCK=y
 CONFIG_EVENT_WAKE_UNLOCK=y
-CONFIG_EVENT_SUSPEND_PREPARE=y
-CONFIG_EVENT_POST_SUSPEND=y
 CONFIG_EVENT_CONTEXT_SWITCH=y
 CONFIG_EVENT_IDLE_START=n
 CONFIG_EVENT_IDLE_END=n
diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index d3240ec..2cb1901 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -11,8 +11,6 @@
 #define EVENT_CPU_ONLINE 5
 #define EVENT_CPU_DOWN_PREPARE 6
 #define EVENT_CPU_DEAD 7
-#define EVENT_SUSPEND_PREPARE 8
-#define EVENT_POST_SUSPEND 9
 
 #define EVENT_CONTEXT_SWITCH 10
 
@@ -236,18 +234,6 @@ static inline void event_log_cpu_dead(unsigned int cpu) {
 #endif
 }
 
-static inline void event_log_suspend_prepare(void) {
-#ifdef CONFIG_EVENT_SUSPEND_PREPARE
-  event_log_simple(EVENT_SUSPEND_PREPARE);
-#endif
-}
-
-static inline void event_log_post_suspend(void) {
-#ifdef CONFIG_EVENT_POST_SUSPEND
-  event_log_simple(EVENT_POST_SUSPEND);
-#endif
-}
-
 static inline void event_log_idle_start(void) {
 #ifdef CONFIG_EVENT_IDLE_START
   event_log_simple(EVENT_IDLE_START);
diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index 7c900ba..b11c3f6 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -30,14 +30,6 @@ config EVENT_WAKE_UNLOCK
        bool "Log when a kernel wakelock is released"
        default yes
 
-config EVENT_SUSPEND_PREPARE
-       bool "Log when the system is preparing to suspend"
-       default yes
-
-config EVENT_POST_SUSPEND
-       bool "Log when the system resumes from suspend"
-       default yes
-
 config EVENT_CONTEXT_SWITCH
        bool "Log context switches"
        default no
diff --git a/kernel/eventlogging/Makefile b/kernel/eventlogging/Makefile
index b06888f..3bb8914 100644
--- a/kernel/eventlogging/Makefile
+++ b/kernel/eventlogging/Makefile
@@ -1 +1 @@
-obj-$(CONFIG_EVENT_LOGGING) := logging.o proc_fs.o buffer.o idle.o hotcpu.o suspend.o
+obj-$(CONFIG_EVENT_LOGGING) := logging.o proc_fs.o buffer.o idle.o hotcpu.o
diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index 9ff8584..10e2ca2 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -11,7 +11,6 @@
 #include "proc_fs.h"
 #include "idle.h"
 #include "hotcpu.h"
-#include "suspend.h"
 
 #define BUFFER_ORDER 10  // 2^10 = 4 MB with 4096 page size
 #define NUM_BUFFERS  32  // 32 * 4 MB = 128 MB total
@@ -170,7 +169,6 @@ static __init int init_proc_fs(void) {
 early_initcall(init_alloc_buffers);
 early_initcall(init_idle_notifier);
 early_initcall(init_hotcpu_notifier);
-early_initcall(init_suspend_notifier);
 fs_initcall(init_proc_fs);
 
 
diff --git a/kernel/eventlogging/suspend.c b/kernel/eventlogging/suspend.c
deleted file mode 100644
index 24667b8..0000000
--- a/kernel/eventlogging/suspend.c
+++ /dev/null
@@ -1,32 +0,0 @@
-#include <linux/suspend.h>
-#include <linux/notifier.h>
-
-#include <eventlogging/events.h>
-
-#if defined(CONFIG_EVENT_SUSPEND_PREPARE) || defined(CONFIG_EVENT_POST_SUSPEND)
-
-static int suspend_notifier_call(struct notifier_block* self, unsigned long event, void* empty) {
-  switch (event) {
-  case PM_SUSPEND_PREPARE:
-    event_log_suspend_prepare();
-    break;
-  case PM_POST_SUSPEND:
-    event_log_post_suspend();
-    break;
-  }
-  return NOTIFY_OK;
-}
-
-static struct notifier_block suspend_notifier = {
-  .notifier_call = suspend_notifier_call
-};
-
-__init int init_suspend_notifier(void) {
-  register_pm_notifier(&suspend_notifier);
-  return 0;
-}
-#else
-__init int init_suspend_notifier(void){
-  return 0;
-}
-#endif
diff --git a/kernel/eventlogging/suspend.h b/kernel/eventlogging/suspend.h
deleted file mode 100644
index f79ad46..0000000
--- a/kernel/eventlogging/suspend.h
+++ /dev/null
@@ -1,6 +0,0 @@
-#ifndef EVENT_LOGGING_SUSPEND_H
-#define EVENT_LOGGING_SUSPEND_H
-
-__init int init_suspend_notifier(void);
-
-#endif
-- 
1.9.1


From 73ee17fde62ea7b42d595319e543adeaf26d53e9 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Wed, 26 Sep 2012 21:47:06 -0400
Subject: [PATCH 34/72] eventlogging: learn log suspend/resume events

---
 .../configs/tegra3_android_eventlogging_defconfig  |  4 +++
 include/eventlogging/events.h                      | 29 ++++++++++++++++++++++
 kernel/eventlogging/Kconfig                        | 15 +++++++++++
 kernel/power/suspend.c                             | 13 +++++++---
 4 files changed, 58 insertions(+), 3 deletions(-)

diff --git a/arch/arm/configs/tegra3_android_eventlogging_defconfig b/arch/arm/configs/tegra3_android_eventlogging_defconfig
index 1f4e3b1..9416d9f 100644
--- a/arch/arm/configs/tegra3_android_eventlogging_defconfig
+++ b/arch/arm/configs/tegra3_android_eventlogging_defconfig
@@ -521,6 +521,10 @@ CONFIG_EVENT_WAKE_UNLOCK=y
 CONFIG_EVENT_CONTEXT_SWITCH=y
 CONFIG_EVENT_IDLE_START=n
 CONFIG_EVENT_IDLE_END=n
+CONFIG_EVENT_SUSPEND_START=y
+CONFIG_EVENT_SUSPEND=y
+CONFIG_EVENT_RESUME=y
+CONFIG_EVENT_RESUME_FINISH=y
 CONFIG_EVENT_FORK=y
 CONFIG_EVENT_EXIT=y
 CONFIG_EVENT_IO_BLOCK=y
diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 2cb1901..9853007 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -44,6 +44,11 @@
 #define EVENT_WAKE_LOCK 70
 #define EVENT_WAKE_UNLOCK 71
 
+#define EVENT_SUSPEND_START 75
+#define EVENT_SUSPEND 76
+#define EVENT_RESUME 77
+#define EVENT_RESUME_FINISH 78
+
 struct event_hdr {
   __u8  event_type;
   __u8  cpu;
@@ -246,6 +251,30 @@ static inline void event_log_idle_end(void) {
 #endif
 }
 
+static inline void event_log_suspend_start(void) {
+#ifdef CONFIG_EVENT_SUSPEND_START
+  event_log_simple(EVENT_SUSPEND_START);
+#endif
+}
+
+static inline void event_log_suspend(void) {
+#ifdef CONFIG_EVENT_SUSPEND
+  event_log_simple(EVENT_SUSPEND);
+#endif
+}
+
+static inline void event_log_resume(void) {
+#ifdef CONFIG_EVENT_RESUME
+  event_log_simple(EVENT_RESUME);
+#endif
+}
+
+static inline void event_log_resume_finish(void) {
+#ifdef CONFIG_EVENT_RESUME_FINISH
+  event_log_simple(EVENT_RESUME_FINISH);
+#endif
+}
+
 static inline void event_log_datagram_block(void) {
 #ifdef CONFIG_EVENT_DATAGRAM_BLOCK
   event_log_simple(EVENT_DATAGRAM_BLOCK);
diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index b11c3f6..a1e7fd2 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -22,6 +22,21 @@ config EVENT_CPU_DEAD
        bool "Log when cpu goes offline"
        default yes
 
+config EVENT_SUSPEND_START
+       bool "Log when a suspend request is issued"
+       default yes
+
+config EVENT_SUSPEND
+       bool "Log when the system enters suspend"
+       default yes
+
+config EVENT_RESUME
+       bool "Log when the system resumes"
+       default yes
+
+config EVENT_RESUME_FINISH
+       bool "Log when the resume has finished"
+
 config EVENT_WAKE_LOCK
        bool "Log when a kernel wakelock is acquired"
        default yes
diff --git a/kernel/power/suspend.c b/kernel/power/suspend.c
index 61e6347..245d630 100644
--- a/kernel/power/suspend.c
+++ b/kernel/power/suspend.c
@@ -27,6 +27,8 @@
 
 #include "power.h"
 
+#include <eventlogging/events.h>
+
 const char *const pm_states[PM_SUSPEND_MAX] = {
 #ifdef CONFIG_EARLYSUSPEND
 	[PM_SUSPEND_ON]		= "on",
@@ -166,6 +168,7 @@ static int suspend_enter(suspend_state_t state)
 	arch_suspend_disable_irqs();
 	BUG_ON(!irqs_disabled());
 
+	event_log_suspend();
 	error = syscore_suspend();
 	if (!error) {
 		if (!(suspend_test(TEST_CORE) || pm_wakeup_pending())) {
@@ -173,6 +176,7 @@ static int suspend_enter(suspend_state_t state)
 			events_check_enabled = false;
 		}
 		syscore_resume();
+		event_log_resume();
 	}
 
 	arch_suspend_enable_irqs();
@@ -276,6 +280,8 @@ int enter_state(suspend_state_t state)
 	if (!mutex_trylock(&pm_mutex))
 		return -EBUSY;
 
+	event_log_suspend_start();
+
 	printk(KERN_INFO "PM: Syncing filesystems ... ");
 	sys_sync();
 	printk("done.\n");
@@ -298,6 +304,7 @@ int enter_state(suspend_state_t state)
 	suspend_finish();
  Unlock:
 	mutex_unlock(&pm_mutex);
+	event_log_resume_finish();
 	return error;
 }
 
@@ -310,8 +317,8 @@ int enter_state(suspend_state_t state)
  */
 int pm_suspend(suspend_state_t state)
 {
-	if (state > PM_SUSPEND_ON && state < PM_SUSPEND_MAX)
-		return enter_state(state);
-	return -EINVAL;
+  if (state > PM_SUSPEND_ON && state < PM_SUSPEND_MAX)
+	return enter_state(state);
+  return -EINVAL;
 }
 EXPORT_SYMBOL(pm_suspend);
-- 
1.9.1


From 2a0c269655a3b2e5408aa43e4c8e8636b76c1855 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Thu, 27 Sep 2012 00:18:55 -0400
Subject: [PATCH 35/72] eventlogging: learn to log preempt tick events

---
 arch/arm/configs/tegra3_android_eventlogging_defconfig |  1 +
 include/eventlogging/events.h                          | 11 +++++++++++
 kernel/eventlogging/Kconfig                            |  4 ++++
 kernel/sched_fair.c                                    |  5 ++++-
 4 files changed, 20 insertions(+), 1 deletion(-)

diff --git a/arch/arm/configs/tegra3_android_eventlogging_defconfig b/arch/arm/configs/tegra3_android_eventlogging_defconfig
index 9416d9f..d2ad980 100644
--- a/arch/arm/configs/tegra3_android_eventlogging_defconfig
+++ b/arch/arm/configs/tegra3_android_eventlogging_defconfig
@@ -519,6 +519,7 @@ CONFIG_EVENT_CPU_DEAD=y
 CONFIG_EVENT_WAKE_LOCK=y
 CONFIG_EVENT_WAKE_UNLOCK=y
 CONFIG_EVENT_CONTEXT_SWITCH=y
+CONFIG_EVENT_PREEMPT_TICK=y
 CONFIG_EVENT_IDLE_START=n
 CONFIG_EVENT_IDLE_END=n
 CONFIG_EVENT_SUSPEND_START=y
diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 9853007..5259d3e 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -13,6 +13,7 @@
 #define EVENT_CPU_DEAD 7
 
 #define EVENT_CONTEXT_SWITCH 10
+#define EVENT_PREEMPT_TICK 11
 
 #define EVENT_IDLE_START 13
 #define EVENT_IDLE_END 14
@@ -73,6 +74,10 @@ struct context_switch_event {
   __le16 new_pid;
 }__attribute__((packed));
 
+struct preempt_tick_event {
+  struct event_hdr hdr;
+}__attribute__((packed));
+
 struct hotcpu_event {
   struct event_hdr hdr;
   __u8 cpu;
@@ -209,6 +214,12 @@ static inline void event_log_context_switch(pid_t old, pid_t new) {
 #endif
 }
 
+static inline void event_log_preempt_tick(void) {
+#ifdef CONFIG_EVENT_PREEMPT_TICK
+  event_log_simple(EVENT_PREEMPT_TICK);
+#endif
+}
+
 #if defined(CONFIG_EVENT_CPU_ONLINE) || defined(CONFIG_EVENT_CPU_DEAD) || defined(CONFIG_EVENT_CPU_DOWN_PREPARE)
 static inline void event_log_hotcpu(unsigned int cpu, u8 event_type) {
   unsigned long flags;
diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index a1e7fd2..0ac84df 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -49,6 +49,10 @@ config EVENT_CONTEXT_SWITCH
        bool "Log context switches"
        default no
 
+config EVENT_PREEMPT_TICK
+       bool "Log when a process is about to be preempted"
+       default yes
+
 config EVENT_IDLE_START
        bool "Log when idle loop starts"
        default yes
diff --git a/kernel/sched_fair.c b/kernel/sched_fair.c
index c768588..031272d 100644
--- a/kernel/sched_fair.c
+++ b/kernel/sched_fair.c
@@ -1100,6 +1100,7 @@ check_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr)
 	ideal_runtime = sched_slice(cfs_rq, curr);
 	delta_exec = curr->sum_exec_runtime - curr->prev_sum_exec_runtime;
 	if (delta_exec > ideal_runtime) {
+		event_log_preempt_tick();
 		resched_task(rq_of(cfs_rq)->curr);
 		/*
 		 * The current task ran long enough, ensure it doesn't get
@@ -1127,8 +1128,10 @@ check_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr)
 		if (delta < 0)
 			return;
 
-		if (delta > ideal_runtime)
+		if (delta > ideal_runtime) {
+			event_log_preempt_tick();
 			resched_task(rq_of(cfs_rq)->curr);
+		}
 	}
 }
 
-- 
1.9.1


From 656a7dafae6aeffbc3e977a1a624ac9357503600 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Fri, 28 Sep 2012 10:08:54 -0400
Subject: [PATCH 36/72] eventlogging: log waitqueue wait/wake events.

---
 .../configs/tegra3_android_eventlogging_defconfig  |  3 ++
 include/eventlogging/events.h                      | 32 +++++++++++++++--
 include/linux/wait.h                               | 20 +++++++++++
 kernel/eventlogging/Kconfig                        | 13 +++++++
 kernel/eventlogging/Makefile                       |  2 +-
 kernel/eventlogging/events.c                       | 41 ++++++++++++++++++++++
 kernel/wait.c                                      | 14 +++++---
 7 files changed, 118 insertions(+), 7 deletions(-)
 create mode 100644 kernel/eventlogging/events.c

diff --git a/arch/arm/configs/tegra3_android_eventlogging_defconfig b/arch/arm/configs/tegra3_android_eventlogging_defconfig
index d2ad980..a83a59b 100644
--- a/arch/arm/configs/tegra3_android_eventlogging_defconfig
+++ b/arch/arm/configs/tegra3_android_eventlogging_defconfig
@@ -520,6 +520,9 @@ CONFIG_EVENT_WAKE_LOCK=y
 CONFIG_EVENT_WAKE_UNLOCK=y
 CONFIG_EVENT_CONTEXT_SWITCH=y
 CONFIG_EVENT_PREEMPT_TICK=y
+CONFIG_EVENT_WAITQUEUE_WAIT=y
+CONFIG_EVENT_WAITQUEUE_WAKE=y
+CONFIG_EVENT_WAITQUEUE_NOTIFY=y
 CONFIG_EVENT_IDLE_START=n
 CONFIG_EVENT_IDLE_END=n
 CONFIG_EVENT_SUSPEND_START=y
diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 5259d3e..1c1f86d 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -39,6 +39,10 @@
 #define EVENT_MUTEX_WAKE 52
 #define EVENT_MUTEX_NOTIFY 53
 
+#define EVENT_WAITQUEUE_WAIT 55
+#define EVENT_WAITQUEUE_WAKE 56
+#define EVENT_WAITQUEUE_NOTIFY 57
+
 #define EVENT_IPC_LOCK 60
 #define EVENT_IPC_WAIT 61
 
@@ -130,6 +134,22 @@ struct network_resume_event {
   struct event_hdr hdr;
 }__attribute__((packed));
 
+struct waitqueue_wait_event {
+  struct event_hdr hdr;
+  __le32 wq;
+}__attribute__((packed));
+
+struct waitqueue_wake_event {
+  struct event_hdr hdr;
+  __le32 wq;
+}__attribute__((packed));
+
+struct waitqueue_notify_event {
+  struct event_hdr hdr;
+  __le32 wq;
+  __le16 pid;
+}__attribute__((packed));
+
 struct mutex_lock_event {
   struct event_hdr hdr;
   __le32 lock;
@@ -175,8 +195,6 @@ struct io_resume_event {
 #include <linux/sched.h>
 #include <linux/smp.h>
 
-
-
 #ifdef CONFIG_EVENT_LOGGING
 extern void log_event(void* data, int len);
 
@@ -393,6 +411,16 @@ static inline void event_log_thread_name(struct task_struct* task) {
 #endif
 }
 
+/* Can't be inlined due to #include ordering conflicts in wait.h and I
+ * don't want to figure that out right now.  Can do it later, but
+ * might involve a separate header file for the waitqueue events
+ * or externing (instead of #including) the depedencies
+ * for event_log_header_init().
+ */
+void event_log_waitqueue_wait(void* wq);
+void event_log_waitqueue_wake(void* wq);
+void event_log_waitqueue_notify(void* wq, pid_t pid);
+
 static inline void event_log_mutex_lock(void* lock) {
 #ifdef CONFIG_EVENT_MUTEX_LOCK
   unsigned long flags;
diff --git a/include/linux/wait.h b/include/linux/wait.h
index 3efc9f3..301614d 100644
--- a/include/linux/wait.h
+++ b/include/linux/wait.h
@@ -25,6 +25,24 @@
 #include <asm/system.h>
 #include <asm/current.h>
 
+#ifdef CONFIG_EVENT_WAITQUEUE_WAIT
+extern void event_log_waitqueue_wait(void* wq);
+#else
+#define event_log_waitqueue_wait(t) do{;}while(0);
+#endif
+
+#ifdef CONFIG_EVENT_WAITQUEUE_WAIT
+extern void event_log_waitqueue_wake(void* wq);
+#else
+#define event_log_waitqueue_wait(t) do{;}while(0);
+#endif
+
+#ifdef CONFIG_EVENT_WAITQUEUE_WAIT
+extern void event_log_waitqueue_notify(void* wq, pid_t pid);
+#else
+#define event_log_waitqueue_wait(t, p) do{;}while(0);
+#endif
+
 typedef struct __wait_queue wait_queue_t;
 typedef int (*wait_queue_func_t)(wait_queue_t *wait, unsigned mode, int flags, void *key);
 int default_wake_function(wait_queue_t *wait, unsigned mode, int flags, void *key);
@@ -395,7 +413,9 @@ do {									\
 			spin_unlock_irq(&(wq).lock);			\
 		else							\
 			spin_unlock(&(wq).lock);			\
+		event_log_waitqueue_wait(&wq);				\
 		schedule();						\
+		event_log_waitqueue_wake(&wq);				\
 		if (irq)						\
 			spin_lock_irq(&(wq).lock);			\
 		else							\
diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index 0ac84df..cf9db56 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -36,6 +36,19 @@ config EVENT_RESUME
 
 config EVENT_RESUME_FINISH
        bool "Log when the resume has finished"
+       default yes
+
+config EVENT_WAITQUEUE_WAIT
+       bool "Log wait queue event waits"
+       default yes
+
+config EVENT_WAITQUEUE_WAKE
+       bool "Log wait queue event wakes"
+       default yes
+
+config EVENT_WAITQUEUE_NOTIFY
+       bool "Log wait queue event notifies"
+       default yes
 
 config EVENT_WAKE_LOCK
        bool "Log when a kernel wakelock is acquired"
diff --git a/kernel/eventlogging/Makefile b/kernel/eventlogging/Makefile
index 3bb8914..30b0691 100644
--- a/kernel/eventlogging/Makefile
+++ b/kernel/eventlogging/Makefile
@@ -1 +1 @@
-obj-$(CONFIG_EVENT_LOGGING) := logging.o proc_fs.o buffer.o idle.o hotcpu.o
+obj-$(CONFIG_EVENT_LOGGING) := logging.o proc_fs.o buffer.o idle.o hotcpu.o events.o
diff --git a/kernel/eventlogging/events.c b/kernel/eventlogging/events.c
new file mode 100644
index 0000000..12cd421
--- /dev/null
+++ b/kernel/eventlogging/events.c
@@ -0,0 +1,41 @@
+#include <eventlogging/events.h>
+
+void event_log_waitqueue_wait(void* wq) {
+#ifdef CONFIG_EVENT_WAITQUEUE_WAIT
+  unsigned long flags;
+  struct waitqueue_wait_event event;
+  
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_WAITQUEUE_WAIT);
+  event.wq = (__le32) wq;
+  log_event(&event, sizeof(struct waitqueue_wait_event));
+  local_irq_restore(flags);
+#endif
+}
+
+void event_log_waitqueue_wake(void* wq) {
+#ifdef CONFIG_EVENT_WAITQUEUE_WAKE
+  unsigned long flags;
+  struct waitqueue_wake_event event;
+  
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_WAITQUEUE_WAKE);
+  event.wq = (__le32) wq;
+  log_event(&event, sizeof(struct waitqueue_wake_event));
+  local_irq_restore(flags);
+#endif
+}
+
+void event_log_waitqueue_notify(void* wq, pid_t pid) {
+#ifdef CONFIG_EVENT_WAITQUEUE_NOTIFY
+  unsigned long flags;
+  struct waitqueue_notify_event event;
+  
+  local_irq_save(flags);
+  event_log_header_init(&event.hdr, EVENT_WAITQUEUE_NOTIFY);
+  event.wq = (__le32) wq;
+  event.pid = pid;
+  log_event(&event, sizeof(struct waitqueue_notify_event));
+  local_irq_restore(flags);
+#endif
+}
diff --git a/kernel/wait.c b/kernel/wait.c
index f45ea8d..4abef37 100644
--- a/kernel/wait.c
+++ b/kernel/wait.c
@@ -68,11 +68,12 @@ void
 prepare_to_wait(wait_queue_head_t *q, wait_queue_t *wait, int state)
 {
 	unsigned long flags;
-
 	wait->flags &= ~WQ_FLAG_EXCLUSIVE;
 	spin_lock_irqsave(&q->lock, flags);
-	if (list_empty(&wait->task_list))
+	if (list_empty(&wait->task_list)) {
 		__add_wait_queue(q, wait);
+		event_log_waitqueue_wait(q);
+	}
 	set_current_state(state);
 	spin_unlock_irqrestore(&q->lock, flags);
 }
@@ -85,8 +86,10 @@ prepare_to_wait_exclusive(wait_queue_head_t *q, wait_queue_t *wait, int state)
 
 	wait->flags |= WQ_FLAG_EXCLUSIVE;
 	spin_lock_irqsave(&q->lock, flags);
-	if (list_empty(&wait->task_list))
+	if (list_empty(&wait->task_list)) {
 		__add_wait_queue_tail(q, wait);
+		event_log_waitqueue_wait(q);
+	}
 	set_current_state(state);
 	spin_unlock_irqrestore(&q->lock, flags);
 }
@@ -105,6 +108,7 @@ void finish_wait(wait_queue_head_t *q, wait_queue_t *wait)
 {
 	unsigned long flags;
 
+	event_log_waitqueue_wake(q);
 	__set_current_state(TASK_RUNNING);
 	/*
 	 * We can check for list emptiness outside the lock
@@ -152,8 +156,10 @@ void abort_exclusive_wait(wait_queue_head_t *q, wait_queue_t *wait,
 
 	__set_current_state(TASK_RUNNING);
 	spin_lock_irqsave(&q->lock, flags);
-	if (!list_empty(&wait->task_list))
+	if (!list_empty(&wait->task_list)) {
 		list_del_init(&wait->task_list);
+		event_log_waitqueue_wake(q);
+	}
 	else if (waitqueue_active(q))
 		__wake_up_locked_key(q, mode, key);
 	spin_unlock_irqrestore(&q->lock, flags);
-- 
1.9.1


From 4594a597027221ae4968e0df6d77da9ffbe47937 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Fri, 28 Sep 2012 11:00:15 -0400
Subject: [PATCH 37/72] eventlogging: log state of old task at context switch

---
 include/eventlogging/events.h | 5 ++++-
 kernel/sched.c                | 2 +-
 2 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 1c1f86d..6b06528 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -76,6 +76,8 @@ struct context_switch_event {
   struct event_hdr hdr;
   __le16 old_pid;
   __le16 new_pid;
+  __u8   state;
+  
 }__attribute__((packed));
 
 struct preempt_tick_event {
@@ -219,7 +221,7 @@ static inline void event_log_simple(u8 event_type) {
 }
 #endif
 
-static inline void event_log_context_switch(pid_t old, pid_t new) {
+static inline void event_log_context_switch(pid_t old, pid_t new, long state) {
 #ifdef CONFIG_EVENT_CONTEXT_SWITCH
   unsigned long flags;
   struct context_switch_event event;
@@ -227,6 +229,7 @@ static inline void event_log_context_switch(pid_t old, pid_t new) {
   event_log_header_init(&event.hdr, EVENT_CONTEXT_SWITCH);
   event.old_pid = old;
   event.new_pid = new;
+  event.state = (__u8) (0x0FF & state);
   log_event(&event, sizeof(struct context_switch_event));
   local_irq_restore(flags);
 #endif
diff --git a/kernel/sched.c b/kernel/sched.c
index cea8991..d6fa0df 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -3146,7 +3146,7 @@ context_switch(struct rq *rq, struct task_struct *prev,
 {
 	struct mm_struct *mm, *oldmm;
 
-	event_log_context_switch(prev->pid, next->pid);
+	event_log_context_switch(prev->pid, next->pid, prev->state);
 
 	prepare_task_switch(rq, prev, next);
 
-- 
1.9.1


From 9b6c877ae1247154d686d43f5e2f4a51115b9bbf Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Fri, 28 Sep 2012 11:25:08 -0400
Subject: [PATCH 38/72] eventlogging: learn to log yield event

---
 arch/arm/configs/tegra3_android_eventlogging_defconfig |  1 +
 include/eventlogging/events.h                          | 11 +++++++++++
 kernel/eventlogging/Kconfig                            |  4 ++++
 kernel/sched.c                                         |  5 ++++-
 4 files changed, 20 insertions(+), 1 deletion(-)

diff --git a/arch/arm/configs/tegra3_android_eventlogging_defconfig b/arch/arm/configs/tegra3_android_eventlogging_defconfig
index a83a59b..940e045 100644
--- a/arch/arm/configs/tegra3_android_eventlogging_defconfig
+++ b/arch/arm/configs/tegra3_android_eventlogging_defconfig
@@ -520,6 +520,7 @@ CONFIG_EVENT_WAKE_LOCK=y
 CONFIG_EVENT_WAKE_UNLOCK=y
 CONFIG_EVENT_CONTEXT_SWITCH=y
 CONFIG_EVENT_PREEMPT_TICK=y
+CONFIG_EVENT_YIELD=y
 CONFIG_EVENT_WAITQUEUE_WAIT=y
 CONFIG_EVENT_WAITQUEUE_WAKE=y
 CONFIG_EVENT_WAITQUEUE_NOTIFY=y
diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 6b06528..0debc0e 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -14,6 +14,7 @@
 
 #define EVENT_CONTEXT_SWITCH 10
 #define EVENT_PREEMPT_TICK 11
+#define EVENT_YIELD 12
 
 #define EVENT_IDLE_START 13
 #define EVENT_IDLE_END 14
@@ -84,6 +85,10 @@ struct preempt_tick_event {
   struct event_hdr hdr;
 }__attribute__((packed));
 
+struct yield_event {
+  struct event_hdr hdr;
+}__attribute__((packed));
+
 struct hotcpu_event {
   struct event_hdr hdr;
   __u8 cpu;
@@ -241,6 +246,12 @@ static inline void event_log_preempt_tick(void) {
 #endif
 }
 
+static inline void event_log_yield(void) {
+#ifdef CONFIG_EVENT_YIELD
+  event_log_simple(EVENT_YIELD);
+#endif
+}
+
 #if defined(CONFIG_EVENT_CPU_ONLINE) || defined(CONFIG_EVENT_CPU_DEAD) || defined(CONFIG_EVENT_CPU_DOWN_PREPARE)
 static inline void event_log_hotcpu(unsigned int cpu, u8 event_type) {
   unsigned long flags;
diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index cf9db56..7b3b456 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -66,6 +66,10 @@ config EVENT_PREEMPT_TICK
        bool "Log when a process is about to be preempted"
        default yes
 
+config EVENT_YIELD
+       bool "Log when a process yields the CPU"
+       default yes
+
 config EVENT_IDLE_START
        bool "Log when idle loop starts"
        default yes
diff --git a/kernel/sched.c b/kernel/sched.c
index d6fa0df..0c2f128 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -5535,6 +5535,7 @@ SYSCALL_DEFINE0(sched_yield)
 	do_raw_spin_unlock(&rq->lock);
 	preempt_enable_no_resched();
 
+	event_log_yield();
 	schedule();
 
 	return 0;
@@ -5671,8 +5672,10 @@ out:
 	double_rq_unlock(rq, p_rq);
 	local_irq_restore(flags);
 
-	if (yielded)
+	if (yielded) {
+		event_log_yield();
 		schedule();
+	}
 
 	return yielded;
 }
-- 
1.9.1


From 39d4f23b3e5d23dbe616cdeb528ea26d02d0334a Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Fri, 28 Sep 2012 13:27:35 -0400
Subject: [PATCH 39/72] eventlogging: learn to log preempt wakeup events

---
 arch/arm/configs/tegra3_android_eventlogging_defconfig |  1 +
 include/eventlogging/events.h                          | 11 +++++++++++
 kernel/eventlogging/Kconfig                            |  6 +++++-
 kernel/sched_fair.c                                    |  1 +
 4 files changed, 18 insertions(+), 1 deletion(-)

diff --git a/arch/arm/configs/tegra3_android_eventlogging_defconfig b/arch/arm/configs/tegra3_android_eventlogging_defconfig
index 940e045..f77ef40 100644
--- a/arch/arm/configs/tegra3_android_eventlogging_defconfig
+++ b/arch/arm/configs/tegra3_android_eventlogging_defconfig
@@ -520,6 +520,7 @@ CONFIG_EVENT_WAKE_LOCK=y
 CONFIG_EVENT_WAKE_UNLOCK=y
 CONFIG_EVENT_CONTEXT_SWITCH=y
 CONFIG_EVENT_PREEMPT_TICK=y
+CONFIG_EVENT_PREEMPT_WAKEUP=y
 CONFIG_EVENT_YIELD=y
 CONFIG_EVENT_WAITQUEUE_WAIT=y
 CONFIG_EVENT_WAITQUEUE_WAKE=y
diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 0debc0e..353b8ad 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -12,6 +12,7 @@
 #define EVENT_CPU_DOWN_PREPARE 6
 #define EVENT_CPU_DEAD 7
 
+#define EVENT_PREEMPT_WAKEUP 9
 #define EVENT_CONTEXT_SWITCH 10
 #define EVENT_PREEMPT_TICK 11
 #define EVENT_YIELD 12
@@ -85,6 +86,10 @@ struct preempt_tick_event {
   struct event_hdr hdr;
 }__attribute__((packed));
 
+struct preempt_wakeup_event {
+  struct event_hdr hdr;
+}__attribute__((packed));
+
 struct yield_event {
   struct event_hdr hdr;
 }__attribute__((packed));
@@ -246,6 +251,12 @@ static inline void event_log_preempt_tick(void) {
 #endif
 }
 
+static inline void event_log_preempt_wakeup(void) {
+#ifdef CONFIG_EVENT_PREEMPT_WAKEUP
+  event_log_simple(EVENT_PREEMPT_WAKEUP);
+#endif
+}
+
 static inline void event_log_yield(void) {
 #ifdef CONFIG_EVENT_YIELD
   event_log_simple(EVENT_YIELD);
diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index 7b3b456..139c0fa 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -63,7 +63,11 @@ config EVENT_CONTEXT_SWITCH
        default no
 
 config EVENT_PREEMPT_TICK
-       bool "Log when a process is about to be preempted"
+       bool "Log when a process is about to be preempted due to timeout"
+       default yes
+
+config EVENT_PREEMPT_WAKEUP
+       bool "Log when a process is about to be preempted due to wakeup"
        default yes
 
 config EVENT_YIELD
diff --git a/kernel/sched_fair.c b/kernel/sched_fair.c
index 031272d..7a289c8 100644
--- a/kernel/sched_fair.c
+++ b/kernel/sched_fair.c
@@ -1940,6 +1940,7 @@ static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_
 	return;
 
 preempt:
+	event_log_preempt_wakeup();
 	resched_task(curr);
 	/*
 	 * Only set the backward buddy when the current task is still
-- 
1.9.1


From aa7f80d6e5bcee3a9b471535b62cf545d871549d Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Fri, 28 Sep 2012 17:46:05 -0400
Subject: [PATCH 40/72] eventlogging: use msb of event pid to indicate
 interrupt context

---
 include/eventlogging/events.h | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 353b8ad..efd63ea 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -203,6 +203,7 @@ struct io_resume_event {
 
 #ifdef __KERNEL__
 
+#include <linux/hardirq.h>
 #include <linux/time.h>
 #include <linux/sched.h>
 #include <linux/smp.h>
@@ -218,7 +219,7 @@ static inline void event_log_header_init(struct event_hdr* event, u8 type) {
   event->tv_sec = tv.tv_sec;
   event->tv_usec = tv.tv_usec;
   event->cpu = smp_processor_id();
-  event->pid = current->pid;
+  event->pid = current->pid | (in_interrupt() ? 0x8000 : 0);
 }
 
 static inline void event_log_simple(u8 event_type) {
-- 
1.9.1


From 04d4a37d5978e7be59b87b2ee38b70fbefbe360f Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Fri, 28 Sep 2012 23:20:26 -0400
Subject: [PATCH 41/72] eventlogging: extract common queue structure and logic

---
 kernel/eventlogging/buffer.c  | 96 -----------------------------------------
 kernel/eventlogging/buffer.h  |  8 ----
 kernel/eventlogging/logging.c | 28 ++++++------
 kernel/eventlogging/proc_fs.c | 48 ++++++++++++++++-----
 kernel/eventlogging/queue.h   | 99 +++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 152 insertions(+), 127 deletions(-)
 create mode 100644 kernel/eventlogging/queue.h

diff --git a/kernel/eventlogging/buffer.c b/kernel/eventlogging/buffer.c
index dd67335..aeb52a8 100644
--- a/kernel/eventlogging/buffer.c
+++ b/kernel/eventlogging/buffer.c
@@ -6,14 +6,6 @@
 
 #include "buffer.h"
 
-static DEFINE_SPINLOCK(empty_lock);
-static LIST_HEAD(empty_list);
-
-static DEFINE_SPINLOCK(full_lock);
-static LIST_HEAD(full_list);
-
-static DECLARE_WAIT_QUEUE_HEAD(full_wait);
-
 // max order is likely 10 or 11
 int sbuffer_init(struct sbuffer* buf, unsigned int order) {
   void* addr;
@@ -76,92 +68,4 @@ int sbuffer_read(struct sbuffer* buf, char* page, int count) {
   return len;
 }
 
-void put_empty(struct sbuffer* buf) {
-  unsigned long flags;
-  spin_lock_irqsave(&empty_lock, flags);
-  list_add(&buf->list, &empty_list);
-  spin_unlock_irqrestore(&empty_lock, flags);
-}
-
-void put_full(struct sbuffer* buf) {
-  unsigned long flags;
-  spin_lock_irqsave(&full_lock, flags);
-  list_add_tail(&buf->list, &full_list);
-  spin_unlock_irqrestore(&full_lock, flags);
-  //wake_up_interruptible(&full_wait);
-}
-
-struct sbuffer* take_empty_try(void) {
-  struct sbuffer* ret = NULL;
-  unsigned long flags;
-  spin_lock_irqsave(&empty_lock, flags);
-  if (0 == list_empty(&empty_list)) {
-    ret = list_entry(empty_list.next, struct sbuffer, list);
-    list_del_init(&ret->list);
-  }
-  spin_unlock_irqrestore(&empty_lock, flags);
-  return ret;
-}
-
-struct sbuffer* __peek_full(void) {
-  if (0 == list_empty(&full_list))
-    return list_entry(full_list.next, struct sbuffer, list);
-  else
-    return NULL;
-}
-
-struct sbuffer* __take_full(void) {
-  struct sbuffer* ret;
-  ret = list_entry(full_list.next, struct sbuffer, list);
-  list_del_init(&ret->list);
-  return ret;
-}
-
-void recycle_if_empty(void) {
-  struct sbuffer* buf;
-  unsigned long flags;
-
-  spin_lock_irqsave(&full_lock, flags);
-  buf = __peek_full();
-  if (NULL == buf)
-    goto not_empty;
-  if (0 == sbuffer_empty(buf))
-    goto not_empty;
-  buf = __take_full();
-  spin_unlock_irqrestore(&full_lock, flags);
-  
-  sbuffer_clear(buf);
-  put_empty(buf);
-  return;
-
- not_empty:
-  spin_unlock_irqrestore(&full_lock, flags);
-}
-
-int __full_list_empty(void) {
-  int ret;
-  unsigned long flags;
-  spin_lock_irqsave(&full_lock, flags);
-  ret = list_empty(&full_list);
-  spin_unlock_irqrestore(&full_lock, flags);
-  return ret;
-}
-
-/*
- * Returns, but does not remove, the head of the list of full buffers.
- * If the list is empty, block until a buffer is available.  Will
- * return NULL if the waiting process is interrupted while waiting.
- */
-struct sbuffer* peek_full_blocking(void) {
-  struct sbuffer* ret = NULL;
-  unsigned long flags;
-  do {
-    spin_lock_irqsave(&full_lock, flags);
-    ret = __peek_full();
-    spin_unlock_irqrestore(&full_lock, flags);
-  } while ( NULL == ret && 
-	    0 == wait_event_interruptible(full_wait, 0 == __full_list_empty()) );
-  return ret;
-}
-
 
diff --git a/kernel/eventlogging/buffer.h b/kernel/eventlogging/buffer.h
index 703b1a3..4a29dc4 100644
--- a/kernel/eventlogging/buffer.h
+++ b/kernel/eventlogging/buffer.h
@@ -23,12 +23,4 @@ int sbuffer_write(struct sbuffer* buf, char* page, int count);
 int sbuffer_empty(struct sbuffer* buf); // any data to read?
 int sbuffer_read(struct sbuffer* buf, char* page, int count);
 
-
-void put_empty(struct sbuffer* buf);
-void put_full(struct sbuffer* buf);
-
-struct sbuffer* take_empty_try(void);
-struct sbuffer* peek_full_blocking(void);
-void recycle_if_empty(void); // move from full to empty, if empty
-
 #endif
diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index 10e2ca2..d9f22af 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -11,13 +11,17 @@
 #include "proc_fs.h"
 #include "idle.h"
 #include "hotcpu.h"
+#include "queue.h"
 
 #define BUFFER_ORDER 10  // 2^10 = 4 MB with 4096 page size
 #define NUM_BUFFERS  32  // 32 * 4 MB = 128 MB total
 
-static DEFINE_PER_CPU(struct sbuffer*, sbuffers);
+static DEFINE_PER_CPU(struct sbuffer*, cpu_buffers);
 static DEFINE_PER_CPU(unsigned int, missed_events);
 
+DEFINE_QUEUE(empty_buffers);
+DEFINE_QUEUE(full_buffers);
+
 inline static void log_missed_count_event(struct sbuffer* buf) {
   struct missed_count_event event;
   int cnt = __get_cpu_var(missed_events);
@@ -42,25 +46,25 @@ static void init_new_buffer(struct sbuffer* buf) {
 }
 
 inline static struct sbuffer* __get_new_cpu_buffer(void) {
-  struct sbuffer* buf = take_empty_try();
+  struct sbuffer* buf = queue_take_try(&empty_buffers);
   if (NULL != buf)
     init_new_buffer(buf);
   return buf;
 }
 
 inline static struct sbuffer* __get_cpu_buffer(void) {
-  struct sbuffer* buf = __get_cpu_var(sbuffers);
+  struct sbuffer* buf = __get_cpu_var(cpu_buffers);
   if (NULL == buf) 
     buf = __get_new_cpu_buffer();
-  __get_cpu_var(sbuffers) = buf;
+  __get_cpu_var(cpu_buffers) = buf;
   return buf;
 }
 
 static struct sbuffer* __flush_cpu_buffer(void) {
-  struct sbuffer* buf = __get_cpu_var(sbuffers);
+  struct sbuffer* buf = __get_cpu_var(cpu_buffers);
   if (NULL != buf)
-    put_full(buf);
-  __get_cpu_var(sbuffers) = NULL;
+    queue_put(&full_buffers, buf);
+  __get_cpu_var(cpu_buffers) = NULL;
   return __get_cpu_buffer();
 }
 
@@ -94,12 +98,12 @@ void log_event(void* data, int len) {
  * and 'cpu' offline.
  */
 static void __flush_offline_cpu_buffer(int cpu) {
-  struct sbuffer* buf = per_cpu(sbuffers, cpu);
+  struct sbuffer* buf = per_cpu(cpu_buffers, cpu);
   printk("eventlogging: flushing offline cpu: %d\n", cpu);
   if (NULL == buf)
     return;
-  put_full(buf);
-  per_cpu(sbuffers, cpu) = NULL;
+  queue_put(&full_buffers, buf); 
+  per_cpu(cpu_buffers, cpu) = NULL;
 }
 
 /*
@@ -149,13 +153,13 @@ static __init int init_alloc_buffers(void) {
 
     ++cnt;
     sbuffer_init(buf, BUFFER_ORDER);
-    put_empty(buf);
+    queue_put(&empty_buffers, buf);
   }
   printk("eventlogging: allocated %d buffers\n", cnt);
 
   /* Set up CPUs to grab new buffer on first event */
   for_each_cpu(cpu, cpu_possible_mask) {
-    per_cpu(sbuffers, cpu) = NULL; 
+    per_cpu(cpu_buffers, cpu) = NULL; 
     printk("eventlogging: prepare buffer for CPU %d\n", cpu);
   }
 
diff --git a/kernel/eventlogging/proc_fs.c b/kernel/eventlogging/proc_fs.c
index 5ea069e..f865129 100644
--- a/kernel/eventlogging/proc_fs.c
+++ b/kernel/eventlogging/proc_fs.c
@@ -1,16 +1,23 @@
 #include <linux/proc_fs.h>
 #include <linux/sched.h>
 #include <linux/list.h>
+#include <linux/mutex.h>
 
 #include "logging.h"
 #include "buffer.h"
+#include "queue.h"
 #include "proc_fs.h"
 
-
 #define PFS_NAME "event_logging"
 #define PFS_PERMS S_IFREG|S_IROTH|S_IRGRP|S_IRUSR|S_IWOTH|S_IWGRP|S_IWUSR
 static struct proc_dir_entry* el_pfs_entry;
 
+extern struct queue empty_buffers;
+extern struct queue full_buffers;
+
+static DEFINE_MUTEX(read_procfs);
+static struct sbuffer* read_buffer;
+
 int event_logging_create_pfs(void) {
   el_pfs_entry = create_proc_entry(PFS_NAME, PFS_PERMS, NULL);
   if (!el_pfs_entry)
@@ -31,25 +38,44 @@ void event_logging_remove_pfs(void) {
 }
 
 int event_logging_read_pfs(char* page, char** start, off_t off, int count, int* eof, void* data) {
-  int len;
-  struct sbuffer* buf;
+  int err, len;
 
   len = 0;
   *start = page;
   *eof = 1;
 
+  err = mutex_lock_interruptible(&read_procfs);
+  if (err)
+    goto err;
+
   while (len == 0) {
-    buf = peek_full_blocking();
-    if (buf == NULL)
-      return -ERESTARTSYS;
-
-    if (sbuffer_empty(buf)) 
-      recycle_if_empty();
-    else 
-      len += sbuffer_read(buf, page, count);
+    /* Return now-empty buffer to empty queue */
+    if (NULL != read_buffer && sbuffer_empty(read_buffer)) {
+      sbuffer_clear(read_buffer);
+      queue_put(&empty_buffers, read_buffer);
+      read_buffer = NULL;
+    }
+
+    /* Get a new buffer from the full queue */
+    if (NULL == read_buffer) {
+      read_buffer = queue_take_interruptible(&full_buffers);
+      if (IS_ERR(read_buffer)) {
+	err = PTR_ERR(read_buffer);
+	read_buffer = NULL;
+	goto err;
+      }
+    }
+    
+    /* Read from the buffer */
+    len += sbuffer_read(read_buffer, page, count);
   }
   
+  mutex_unlock(&read_procfs);
   return len;
+
+  err:
+    mutex_unlock(&read_procfs);
+    return err;
 }
 
 int event_logging_write_pfs(struct file* file, const char* buffer, unsigned long count, void *data) {
diff --git a/kernel/eventlogging/queue.h b/kernel/eventlogging/queue.h
new file mode 100644
index 0000000..bf59cbd
--- /dev/null
+++ b/kernel/eventlogging/queue.h
@@ -0,0 +1,99 @@
+#ifndef EVENT_LOGGING_QUEUE_H
+#define EVENT_LOGGING_QUEUE_H
+
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <linux/err.h>
+
+#include "buffer.h"
+
+struct queue {
+  struct list_head list;
+  spinlock_t lock;
+  unsigned long flags;
+  wait_queue_head_t wait;
+};
+
+#define DEFINE_QUEUE(name) struct queue name = {	\
+    .lock = __SPIN_LOCK_UNLOCKED(name.lock),		\
+    .list = LIST_HEAD_INIT(name.list),			\
+    .wait = __WAIT_QUEUE_HEAD_INITIALIZER(name.wait)	\
+  }						 
+
+static inline void queue_lock(struct queue* queue) {
+  spin_lock_irqsave(&queue->lock, queue->flags);
+}
+
+static inline void queue_unlock(struct queue* queue) {
+  spin_unlock_irqrestore(&queue->lock, queue->flags);
+}
+
+static inline int queue_empty(struct queue* queue) {
+  int ret;
+  queue_lock(queue);
+  ret = list_empty(&queue->list);
+  queue_unlock(queue);
+  return ret;
+}
+
+static inline void queue_put(struct queue* queue, struct sbuffer *buf) {
+  queue_lock(queue);
+  list_add_tail(&buf->list, &queue->list);
+  queue_unlock(queue);
+}
+
+static inline struct sbuffer* __queue_peek_try(struct queue* queue) {
+  if (!list_empty(&queue->list))
+    return list_entry(queue->list.next, struct sbuffer, list);
+  else
+    return NULL;
+}
+
+static inline struct sbuffer* queue_take_try(struct queue* queue) {
+  struct sbuffer* buf = NULL;
+  queue_lock(queue);
+  buf = __queue_peek_try(queue);
+  if (buf != NULL)
+    list_del_init(&buf->list);
+  queue_unlock(queue);
+  return buf;
+}
+
+static inline struct sbuffer* queue_take_interruptible(struct queue* queue) {
+  struct sbuffer* ret = NULL;
+  int err = 0;
+  do {
+    ret = queue_take_try(queue);
+  } while ( NULL == ret &&
+	    0 == (err = wait_event_interruptible(queue->wait, !queue_empty(queue))) );
+  
+  if (err)
+    return ERR_PTR(err);
+  else
+    return ret;
+}
+
+static inline struct sbuffer* queue_peek_try(struct queue* queue) {
+  struct sbuffer* buf = NULL;
+  queue_lock(queue);
+  buf = __queue_peek_try(queue);
+  queue_unlock(queue);
+  return buf;
+}
+
+static inline struct sbuffer* queue_peek_interruptible(struct queue* queue) {
+  struct sbuffer* ret = NULL;
+  int err = 0;
+  do {
+    ret = queue_peek_try(queue);
+  } while ( NULL == ret && 
+	    0 == (err = wait_event_interruptible(queue->wait, !queue_empty(queue))) );
+
+  if (err)
+    return ERR_PTR(err);
+  else
+    return ret;
+}
+
+#endif
-- 
1.9.1


From ec2258f7ea6af2c9e99a6a41347de5e9b69b4f55 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Fri, 28 Sep 2012 23:31:59 -0400
Subject: [PATCH 42/72] eventlogging: move procfile methods into logging.c

---
 kernel/eventlogging/Makefile  |  2 +-
 kernel/eventlogging/logging.c | 80 +++++++++++++++++++++++++++++++++++++---
 kernel/eventlogging/proc_fs.c | 85 -------------------------------------------
 kernel/eventlogging/proc_fs.h | 12 ------
 4 files changed, 75 insertions(+), 104 deletions(-)
 delete mode 100644 kernel/eventlogging/proc_fs.c
 delete mode 100644 kernel/eventlogging/proc_fs.h

diff --git a/kernel/eventlogging/Makefile b/kernel/eventlogging/Makefile
index 30b0691..2bdf9b1 100644
--- a/kernel/eventlogging/Makefile
+++ b/kernel/eventlogging/Makefile
@@ -1 +1 @@
-obj-$(CONFIG_EVENT_LOGGING) := logging.o proc_fs.o buffer.o idle.o hotcpu.o events.o
+obj-$(CONFIG_EVENT_LOGGING) := logging.o buffer.o idle.o hotcpu.o events.o
diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index d9f22af..0432def 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -3,12 +3,12 @@
 #include <linux/smp.h>
 #include <linux/cpu.h>
 #include <linux/slab.h>
+#include <linux/proc_fs.h>
 
 #include <eventlogging/events.h>
 
 #include "logging.h"
 #include "buffer.h"
-#include "proc_fs.h"
 #include "idle.h"
 #include "hotcpu.h"
 #include "queue.h"
@@ -19,8 +19,14 @@
 static DEFINE_PER_CPU(struct sbuffer*, cpu_buffers);
 static DEFINE_PER_CPU(unsigned int, missed_events);
 
-DEFINE_QUEUE(empty_buffers);
-DEFINE_QUEUE(full_buffers);
+static DEFINE_QUEUE(empty_buffers);
+static DEFINE_QUEUE(full_buffers);
+
+#define PFS_NAME "event_logging"
+#define PFS_PERMS S_IFREG|S_IROTH|S_IRGRP|S_IRUSR|S_IWOTH|S_IWGRP|S_IWUSR
+static struct proc_dir_entry* el_pfs_entry;
+static DEFINE_MUTEX(pfs_read_lock);
+static struct sbuffer* pfs_read_buffer;
 
 inline static void log_missed_count_event(struct sbuffer* buf) {
   struct missed_count_event event;
@@ -166,13 +172,75 @@ static __init int init_alloc_buffers(void) {
   return 0;
 }
 
-static __init int init_proc_fs(void) {
-  return event_logging_create_pfs();
+/* =========================== Proc FS Methods ============================== */
+
+static int event_logging_read_pfs(char* page, char** start, off_t off, int count, int* eof, void* data) {
+  int err, len;
+
+  len = 0;
+  *start = page;
+  *eof = 1;
+
+  err = mutex_lock_interruptible(&pfs_read_lock);
+  if (err)
+    goto err;
+
+  while (len == 0) {
+    /* Return now-empty buffer to empty queue */
+    if (NULL != pfs_read_buffer && sbuffer_empty(pfs_read_buffer)) {
+      sbuffer_clear(pfs_read_buffer);
+      queue_put(&empty_buffers, pfs_read_buffer);
+      pfs_read_buffer = NULL;
+    }
+
+    /* Get a new buffer from the full queue */
+    if (NULL == pfs_read_buffer) {
+      pfs_read_buffer = queue_take_interruptible(&full_buffers);
+      if (IS_ERR(pfs_read_buffer)) {
+	err = PTR_ERR(pfs_read_buffer);
+	pfs_read_buffer = NULL;
+	goto err;
+      }
+    }
+    
+    /* Read from the buffer */
+    len += sbuffer_read(pfs_read_buffer, page, count);
+  }
+  
+  mutex_unlock(&pfs_read_lock);
+  return len;
+
+  err:
+    mutex_unlock(&pfs_read_lock);
+    return err;
+}
+
+static int event_logging_write_pfs(struct file* file, const char* buffer, unsigned long count, void *data) {
+  if (count > 0)
+    flush_all_cpus();
+  return count;
 }
 
+static __init int event_logging_create_pfs(void) {
+  el_pfs_entry = create_proc_entry(PFS_NAME, PFS_PERMS, NULL);
+  if (!el_pfs_entry)
+    goto err;
+  
+  el_pfs_entry->uid = 0;
+  el_pfs_entry->gid = 0;
+  el_pfs_entry->read_proc = event_logging_read_pfs;
+  el_pfs_entry->write_proc = event_logging_write_pfs;
+  return 0;
+
+ err:
+  return -EINVAL;
+}
+
+/* ========================= Initialization Config ========================== */
+
 early_initcall(init_alloc_buffers);
 early_initcall(init_idle_notifier);
 early_initcall(init_hotcpu_notifier);
-fs_initcall(init_proc_fs);
+fs_initcall(event_logging_create_pfs);
 
 
diff --git a/kernel/eventlogging/proc_fs.c b/kernel/eventlogging/proc_fs.c
deleted file mode 100644
index f865129..0000000
--- a/kernel/eventlogging/proc_fs.c
+++ /dev/null
@@ -1,85 +0,0 @@
-#include <linux/proc_fs.h>
-#include <linux/sched.h>
-#include <linux/list.h>
-#include <linux/mutex.h>
-
-#include "logging.h"
-#include "buffer.h"
-#include "queue.h"
-#include "proc_fs.h"
-
-#define PFS_NAME "event_logging"
-#define PFS_PERMS S_IFREG|S_IROTH|S_IRGRP|S_IRUSR|S_IWOTH|S_IWGRP|S_IWUSR
-static struct proc_dir_entry* el_pfs_entry;
-
-extern struct queue empty_buffers;
-extern struct queue full_buffers;
-
-static DEFINE_MUTEX(read_procfs);
-static struct sbuffer* read_buffer;
-
-int event_logging_create_pfs(void) {
-  el_pfs_entry = create_proc_entry(PFS_NAME, PFS_PERMS, NULL);
-  if (!el_pfs_entry)
-    goto err;
-  
-  el_pfs_entry->uid = 0;
-  el_pfs_entry->gid = 0;
-  el_pfs_entry->read_proc = event_logging_read_pfs;
-  el_pfs_entry->write_proc = event_logging_write_pfs;
-  return 0;
-
- err:
-  return -EINVAL;
-}
-
-void event_logging_remove_pfs(void) {
-  remove_proc_entry(PFS_NAME, NULL);
-}
-
-int event_logging_read_pfs(char* page, char** start, off_t off, int count, int* eof, void* data) {
-  int err, len;
-
-  len = 0;
-  *start = page;
-  *eof = 1;
-
-  err = mutex_lock_interruptible(&read_procfs);
-  if (err)
-    goto err;
-
-  while (len == 0) {
-    /* Return now-empty buffer to empty queue */
-    if (NULL != read_buffer && sbuffer_empty(read_buffer)) {
-      sbuffer_clear(read_buffer);
-      queue_put(&empty_buffers, read_buffer);
-      read_buffer = NULL;
-    }
-
-    /* Get a new buffer from the full queue */
-    if (NULL == read_buffer) {
-      read_buffer = queue_take_interruptible(&full_buffers);
-      if (IS_ERR(read_buffer)) {
-	err = PTR_ERR(read_buffer);
-	read_buffer = NULL;
-	goto err;
-      }
-    }
-    
-    /* Read from the buffer */
-    len += sbuffer_read(read_buffer, page, count);
-  }
-  
-  mutex_unlock(&read_procfs);
-  return len;
-
-  err:
-    mutex_unlock(&read_procfs);
-    return err;
-}
-
-int event_logging_write_pfs(struct file* file, const char* buffer, unsigned long count, void *data) {
-  if (count > 0)
-    flush_all_cpus();
-  return count;
-}
diff --git a/kernel/eventlogging/proc_fs.h b/kernel/eventlogging/proc_fs.h
deleted file mode 100644
index 879b3d9..0000000
--- a/kernel/eventlogging/proc_fs.h
+++ /dev/null
@@ -1,12 +0,0 @@
-#ifndef EVENT_LOGGING_PROC_FS_H
-#define EVENT_LOGGING_PROC_FS_H
-
-#include <linux/proc_fs.h>
-#include "buffer.h"
-
-int event_logging_create_pfs(void);
-void event_logging_remove_pfs(void);
-int event_logging_read_pfs(char* page, char** start, off_t off, int count, int* eof, void* data);
-int event_logging_write_pfs(struct file* file, const char* buffer, unsigned long count, void* data);
-
-#endif
-- 
1.9.1


From dc61d333c14632c128c0f88469a5816525ab9d3a Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Sat, 29 Sep 2012 00:13:28 -0400
Subject: [PATCH 43/72] eventlogging: reserve space in buffer, rather than
 copying data to buffer.

---
 kernel/eventlogging/buffer.c  | 19 ++++++++---------
 kernel/eventlogging/buffer.h  |  3 +--
 kernel/eventlogging/logging.c | 48 +++++++++++++++++++++++++------------------
 3 files changed, 38 insertions(+), 32 deletions(-)

diff --git a/kernel/eventlogging/buffer.c b/kernel/eventlogging/buffer.c
index aeb52a8..0671b93 100644
--- a/kernel/eventlogging/buffer.c
+++ b/kernel/eventlogging/buffer.c
@@ -35,16 +35,15 @@ void sbuffer_clear(struct sbuffer* buf) {
   buf->wp = buf->start;
 }
 
-int sbuffer_avail(struct sbuffer* buf) {
-  return (buf->end - buf->wp);
-}
-
-int sbuffer_write(struct sbuffer* buf, char* page, int count) {
-  if (sbuffer_avail(buf) < count)
-    return 0;
-  memcpy(buf->wp, page, count);
-  buf->wp += count;
-  return count;
+/* Returns NULL if too full */
+void* sbuffer_reserve(struct sbuffer* buf, int len) {
+  void* old_wp = buf->wp;
+  if (buf->wp + len <= buf-> end) {
+    buf->wp += len;
+    return old_wp;
+  } else {
+    return NULL;
+  }
 }
 
 int sbuffer_empty(struct sbuffer* buf) {
diff --git a/kernel/eventlogging/buffer.h b/kernel/eventlogging/buffer.h
index 4a29dc4..1b51443 100644
--- a/kernel/eventlogging/buffer.h
+++ b/kernel/eventlogging/buffer.h
@@ -18,8 +18,7 @@ int sbuffer_init(struct sbuffer* buf, unsigned int order);
 void sbuffer_free(struct sbuffer* buf);
 
 void sbuffer_clear(struct sbuffer* buf);
-int sbuffer_avail(struct sbuffer* buf); // how much space to write?
-int sbuffer_write(struct sbuffer* buf, char* page, int count);
+void* sbuffer_reserve(struct sbuffer* buf, int len);
 int sbuffer_empty(struct sbuffer* buf); // any data to read?
 int sbuffer_read(struct sbuffer* buf, char* page, int count);
 
diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index 0432def..d6a2eac 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -29,21 +29,31 @@ static DEFINE_MUTEX(pfs_read_lock);
 static struct sbuffer* pfs_read_buffer;
 
 inline static void log_missed_count_event(struct sbuffer* buf) {
-  struct missed_count_event event;
-  int cnt = __get_cpu_var(missed_events);
+  int cnt;
+  struct missed_count_event* event;
+  
+  cnt = __get_cpu_var(missed_events);
   if (0 == cnt)
     return;
-  event_log_header_init(&event.hdr, EVENT_MISSED_COUNT);
-  event.count = __get_cpu_var(missed_events);
-  sbuffer_write(buf, (void*)&event, sizeof(struct missed_count_event));
+
+  event = (struct missed_count_event*) sbuffer_reserve(buf, sizeof(struct missed_count_event));
+  if (!event)
+    return; // Shouldn't happen in new buffer
+
+  event_log_header_init(&event->hdr, EVENT_MISSED_COUNT);
+  event->count = cnt;
   __get_cpu_var(missed_events) = 0;
 }
 
 inline static void log_sync_event(struct sbuffer* buf) {
-  struct sync_log_event event;
-  event_log_header_init(&event.hdr, EVENT_SYNC_LOG);
-  memcpy(&event.magic, EVENT_LOG_MAGIC, 8);
-  sbuffer_write(buf, (void*)&event, sizeof(struct sync_log_event));
+  struct sync_log_event* event;
+
+  event = (struct sync_log_event*) sbuffer_reserve(buf, sizeof(struct sync_log_event));
+  if (!event)
+    return; // Shouldn't happen in new buffer
+
+  event_log_header_init(&event->hdr, EVENT_SYNC_LOG);
+  memcpy(&event->magic, EVENT_LOG_MAGIC, 8);
 }
 
 static void init_new_buffer(struct sbuffer* buf) {
@@ -76,27 +86,25 @@ static struct sbuffer* __flush_cpu_buffer(void) {
 
 void log_event(void* data, int len) {
   struct sbuffer* buf;
-  unsigned long avail;
+  void* wp;
 
-  // Get buffer, if available
+  /* Get buffer, if available */
   buf = __get_cpu_buffer();
+ check_buf:
   if (NULL == buf) {
     __get_cpu_var(missed_events)++;
     return;
   }
 
-  // Flush and replace buffer, if not enough room for new event
-  avail = sbuffer_avail(buf);
-  if (avail < len) {
+  wp = sbuffer_reserve(buf, len);  
+  /* If full, get new buffer */
+  if (!wp) {
     buf = __flush_cpu_buffer();
-    if (NULL == buf) {
-      __get_cpu_var(missed_events)++;
-      return;
-    }
+    goto check_buf;
   }
   
-  // Write data
-  sbuffer_write(buf, data, len);
+  /* Write the data */
+  memcpy(wp, data, len);
 }
 
 /*
-- 
1.9.1


From 347e96de6b38621576f0b1c0f029184efe5422b0 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Sat, 29 Sep 2012 01:06:45 -0400
Subject: [PATCH 44/72] eventlogging: build events directly in buffer

---
 include/eventlogging/events.h | 167 +++++++++++++++---------------------------
 kernel/eventlogging/events.c  |  35 +++------
 kernel/eventlogging/logging.c |  20 ++---
 3 files changed, 79 insertions(+), 143 deletions(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index efd63ea..d239251 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -209,7 +209,18 @@ struct io_resume_event {
 #include <linux/smp.h>
 
 #ifdef CONFIG_EVENT_LOGGING
-extern void log_event(void* data, int len);
+extern void* reserve_event(int len);
+
+#define reserve(name) name = (typeof(name)) reserve_event(sizeof(*name))
+#define init_event(type, event_type, name) type* name;	\
+  unsigned long flags;					\
+  local_irq_save(flags);				\
+  reserve(name);					\
+  if (name) {							\
+    event_log_header_init((struct event_hdr*) name, event_type)
+
+#define finish_event() } \
+    local_irq_restore(flags)
 
 static inline void event_log_header_init(struct event_hdr* event, u8 type) {
   struct timeval tv;
@@ -223,26 +234,18 @@ static inline void event_log_header_init(struct event_hdr* event, u8 type) {
 }
 
 static inline void event_log_simple(u8 event_type) {
-  unsigned long flags;
-  struct event_hdr event;
-  local_irq_save(flags);
-  event_log_header_init(&event, event_type);
-  log_event(&event, sizeof(struct event_hdr));
-  local_irq_restore(flags);
+  init_event(struct event_hdr, event_type, event);
+  finish_event();
 }
 #endif
 
 static inline void event_log_context_switch(pid_t old, pid_t new, long state) {
 #ifdef CONFIG_EVENT_CONTEXT_SWITCH
-  unsigned long flags;
-  struct context_switch_event event;
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_CONTEXT_SWITCH);
-  event.old_pid = old;
-  event.new_pid = new;
-  event.state = (__u8) (0x0FF & state);
-  log_event(&event, sizeof(struct context_switch_event));
-  local_irq_restore(flags);
+  init_event(struct context_switch_event, EVENT_CONTEXT_SWITCH, event);
+  event->old_pid = old;
+  event->new_pid = new;
+  event->state = (__u8) (0x0FF & state);
+  finish_event();
 #endif
 }
 
@@ -266,13 +269,9 @@ static inline void event_log_yield(void) {
 
 #if defined(CONFIG_EVENT_CPU_ONLINE) || defined(CONFIG_EVENT_CPU_DEAD) || defined(CONFIG_EVENT_CPU_DOWN_PREPARE)
 static inline void event_log_hotcpu(unsigned int cpu, u8 event_type) {
-  unsigned long flags;
-  struct hotcpu_event event;
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, event_type);
-  event.cpu = cpu;
-  log_event(&event, sizeof(struct hotcpu_event));
-  local_irq_restore(flags);
+  init_event(struct hotcpu_event, EVENT_CPU_ONLINE, event);
+  event->cpu = cpu;
+  finish_event();
 }
 #endif
 
@@ -380,40 +379,27 @@ static inline void event_log_io_resume(void) {
 
 static inline void event_log_wake_lock(void* lock, long timeout) {
 #ifdef CONFIG_EVENT_WAKE_LOCK
-  unsigned long flags;
-  struct wake_lock_event event;
-  
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_WAKE_LOCK);
-  event.lock = (__le32) lock;
-  event.timeout = timeout;
-  log_event(&event, sizeof(struct wake_lock_event));
-  local_irq_restore(flags);
+  init_event(struct wake_lock_event, EVENT_WAKE_LOCK, event);
+  event->lock = (__le32) lock;
+  event->timeout = timeout;
+  finish_event();
 #endif
 }
 
 static inline void event_log_wake_unlock(void* lock) {
-  unsigned long flags;
-  struct wake_unlock_event event;
-  
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_WAKE_UNLOCK);
-  event.lock = (__le32) lock;
-  log_event(&event, sizeof(struct wake_unlock_event));
-  local_irq_restore(flags);
+#ifdef CONFIG_EVENT_WAKE_UNLOCK
+  init_event(struct wake_unlock_event, EVENT_WAKE_UNLOCK, event);
+  event->lock = (__le32) lock;
+  finish_event();
+#endif
 }
 
 static inline void event_log_fork(pid_t pid, pid_t tgid) {
 #ifdef CONFIG_EVENT_FORK
-  unsigned long flags;
-  struct fork_event event;
-  
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_FORK);
-  event.pid = pid;
-  event.tgid = tgid;
-  log_event(&event, sizeof(struct fork_event));
-  local_irq_restore(flags);
+  init_event(struct fork_event, EVENT_FORK, event);
+  event->pid = pid;
+  event->tgid = tgid;
+  finish_event();
 #endif
 }
 
@@ -425,15 +411,10 @@ static inline void event_log_exit(void) {
 
 static inline void event_log_thread_name(struct task_struct* task) {
 #ifdef CONFIG_EVENT_THREAD_NAME
-   unsigned long flags;
-   struct thread_name_event event;
-  
-   local_irq_save(flags);
-   event_log_header_init(&event.hdr, EVENT_THREAD_NAME);
-   event.pid = task->pid;
-   memcpy(event.comm, task->comm, min(16, TASK_COMM_LEN));
-   log_event(&event, sizeof(struct thread_name_event));
-   local_irq_restore(flags);
+  init_event(struct thread_name_event, EVENT_THREAD_NAME, event);
+  event->pid = task->pid;
+  memcpy(event->comm, task->comm, min(16, TASK_COMM_LEN));
+  finish_event(); 
 #endif
 }
 
@@ -449,80 +430,50 @@ void event_log_waitqueue_notify(void* wq, pid_t pid);
 
 static inline void event_log_mutex_lock(void* lock) {
 #ifdef CONFIG_EVENT_MUTEX_LOCK
-  unsigned long flags;
-  struct mutex_lock_event event;
-
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_MUTEX_LOCK);
-  event.lock = (__le32) lock;
-  log_event(&event, sizeof(struct mutex_lock_event));
-  local_irq_restore(flags);
+  init_event(struct mutex_lock_event, EVENT_MUTEX_LOCK, event);
+  event->lock = (__le32) lock;
+  finish_event();
 #endif
 }
 
 static inline void event_log_mutex_wait(void* lock) {
 #ifdef CONFIG_EVENT_MUTEX_WAIT
-  unsigned long flags;
-  struct mutex_wait_event event;
-
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_MUTEX_WAIT);
-  event.lock = (__le32) lock;
-  log_event(&event, sizeof(struct mutex_wait_event));
-  local_irq_restore(flags);
+  init_event(struct mutex_wait_event, EVENT_MUTEX_WAIT, event);
+  event->lock = (__le32) lock;
+  finish_event();
 #endif
 }
 
 static inline void event_log_mutex_wake(void* lock) {
 #ifdef CONFIG_EVENT_MUTEX_WAKE
-  unsigned long flags;
-  struct mutex_wake_event event;
-  
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_MUTEX_WAKE);
-  event.lock = (__le32) lock;
-  log_event(&event, sizeof(struct mutex_wake_event));
-  local_irq_restore(flags);
+  init_event(struct mutex_wake_event, EVENT_MUTEX_WAKE, event);
+  event->lock = (__le32) lock;
+  finish_event();
 #endif
 }
 
 static inline void event_log_mutex_notify(void* lock, pid_t pid) {
-#ifdef CONFIG_EVENT_MUTEX_WAKE
-  unsigned long flags;
-  struct mutex_notify_event event;
-  
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_MUTEX_NOTIFY);
-  event.lock = (__le32) lock;
-  event.pid = pid;
-  log_event(&event, sizeof(struct mutex_notify_event));
-  local_irq_restore(flags);
+#ifdef CONFIG_EVENT_MUTEX_NOTIFY
+  init_event(struct mutex_notify_event, EVENT_MUTEX_NOTIFY, event);
+  event->lock = (__le32) lock;
+  event->pid = pid;
+  finish_event();
 #endif
 }
 
 static inline void event_log_sem_lock(void* lock) {
 #ifdef CONFIG_EVENT_SEMAPHORE_LOCK
-  unsigned long flags;
-  struct sem_lock_event event;
-
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_SEMAPHORE_LOCK);
-  event.lock = (__le32) lock;
-  log_event(&event, sizeof(struct sem_lock_event));
-  local_irq_restore(flags);
+  init_event(struct sem_lock_event, EVENT_SEMAPHORE_LOCK, event);
+  event->lock = (__le32) lock;
+  finish_event();
 #endif
 }
 
 static inline void event_log_sem_wait(void* lock) {
 #ifdef CONFIG_EVENT_SEMAPHORE_WAIT
-  unsigned long flags;
-  struct sem_wait_event event;
-
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_SEMAPHORE_WAIT);
-  event.lock = (__le32) lock;
-  log_event(&event, sizeof(struct sem_wait_event));
-  local_irq_restore(flags);
+  init_event(struct sem_wait_event, EVENT_SEMAPHORE_WAIT, event);
+  event->lock = (__le32) lock;
+  finish_event();
 #endif
 }
 
diff --git a/kernel/eventlogging/events.c b/kernel/eventlogging/events.c
index 12cd421..7f4b3d2 100644
--- a/kernel/eventlogging/events.c
+++ b/kernel/eventlogging/events.c
@@ -2,40 +2,25 @@
 
 void event_log_waitqueue_wait(void* wq) {
 #ifdef CONFIG_EVENT_WAITQUEUE_WAIT
-  unsigned long flags;
-  struct waitqueue_wait_event event;
-  
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_WAITQUEUE_WAIT);
-  event.wq = (__le32) wq;
-  log_event(&event, sizeof(struct waitqueue_wait_event));
-  local_irq_restore(flags);
+  init_event(struct waitqueue_wait_event, EVENT_WAITQUEUE_WAIT, event);
+  event->wq = (__le32) wq;
+  finish_event();
 #endif
 }
 
 void event_log_waitqueue_wake(void* wq) {
 #ifdef CONFIG_EVENT_WAITQUEUE_WAKE
-  unsigned long flags;
-  struct waitqueue_wake_event event;
-  
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_WAITQUEUE_WAKE);
-  event.wq = (__le32) wq;
-  log_event(&event, sizeof(struct waitqueue_wake_event));
-  local_irq_restore(flags);
+  init_event(struct waitqueue_wake_event, EVENT_WAITQUEUE_WAKE, event);
+  event->wq = (__le32) wq;
+  finish_event();
 #endif
 }
 
 void event_log_waitqueue_notify(void* wq, pid_t pid) {
 #ifdef CONFIG_EVENT_WAITQUEUE_NOTIFY
-  unsigned long flags;
-  struct waitqueue_notify_event event;
-  
-  local_irq_save(flags);
-  event_log_header_init(&event.hdr, EVENT_WAITQUEUE_NOTIFY);
-  event.wq = (__le32) wq;
-  event.pid = pid;
-  log_event(&event, sizeof(struct waitqueue_notify_event));
-  local_irq_restore(flags);
+  init_event(struct waitqueue_notify_event, EVENT_WAITQUEUE_NOTIFY, event);
+  event->wq = (__le32) wq;
+  event->pid = pid;
+  finish_event();
 #endif
 }
diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index d6a2eac..8707f0b 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -84,27 +84,27 @@ static struct sbuffer* __flush_cpu_buffer(void) {
   return __get_cpu_buffer();
 }
 
-void log_event(void* data, int len) {
+/* If not enough space, returns NULL and logs a missed event. */
+void* reserve_event(int len) {
   struct sbuffer* buf;
   void* wp;
 
   /* Get buffer, if available */
   buf = __get_cpu_buffer();
- check_buf:
-  if (NULL == buf) {
+ check_buffer:
+  if (!buf) {
     __get_cpu_var(missed_events)++;
-    return;
+    return NULL;
   }
 
-  wp = sbuffer_reserve(buf, len);  
-  /* If full, get new buffer */
+  wp = sbuffer_reserve(buf, len);
+  /* if full, get new buffer */
   if (!wp) {
     buf = __flush_cpu_buffer();
-    goto check_buf;
+    goto check_buffer;
   }
-  
-  /* Write the data */
-  memcpy(wp, data, len);
+
+  return wp;
 }
 
 /*
-- 
1.9.1


From 6d7b29a7d5f639a67a81dfa864dfb2c917bfbaec Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Sat, 29 Sep 2012 20:37:51 -0400
Subject: [PATCH 45/72] eventlogging: use only 4 bits for cpu number

---
 include/eventlogging/events.h | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index d239251..665bef6 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -56,9 +56,14 @@
 #define EVENT_RESUME 77
 #define EVENT_RESUME_FINISH 78
 
+#define MAX8 ((1 << 7) - 1)
+#define MAX16 ((1 << 14) - 1)
+#define MAX24 ((1 << 22) -1 )
+
 struct event_hdr {
-  __u8  event_type;
-  __u8  cpu;
+  __u8 event_type;
+  __u8 cpu : 4;
+  __u8 flags : 4;
   __le16 pid;
   __le32 tv_sec;
   __le32 tv_usec;
-- 
1.9.1


From 5b467b0834e4f77c860280eba91d49392f40b582 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Sat, 29 Sep 2012 21:16:30 -0400
Subject: [PATCH 46/72] eventlogging: remove event header from per-event-type
 structs

---
 include/eventlogging/events.h | 68 +++++++++++++++++++------------------------
 kernel/eventlogging/logging.c | 42 +++++---------------------
 2 files changed, 38 insertions(+), 72 deletions(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 665bef6..14eada3 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -70,140 +70,114 @@ struct event_hdr {
 }__attribute__((packed));
 
 struct sync_log_event {
-  struct event_hdr hdr;
   char magic[8];
 }__attribute__((packed));
 
 struct missed_count_event {
-  struct event_hdr hdr;
   __le32 count;
 }__attribute__((packed));
 
 struct context_switch_event {
-  struct event_hdr hdr;
   __le16 old_pid;
   __le16 new_pid;
-  __u8   state;
-  
+  __u8   state;  
 }__attribute__((packed));
 
 struct preempt_tick_event {
-  struct event_hdr hdr;
 }__attribute__((packed));
 
 struct preempt_wakeup_event {
-  struct event_hdr hdr;
 }__attribute__((packed));
 
 struct yield_event {
-  struct event_hdr hdr;
 }__attribute__((packed));
 
 struct hotcpu_event {
-  struct event_hdr hdr;
   __u8 cpu;
 }__attribute__((packed));
 
 struct wake_lock_event {
-  struct event_hdr hdr;
   __le32 lock;
   __le32 timeout;
 }__attribute__((packed));
 
 struct wake_unlock_event {
-  struct event_hdr hdr;
   __le32 lock;
 }__attribute__((packed));
 
 struct suspend_event {
-  struct event_hdr hdr;
 }__attribute__((packed));
 
 struct idle_start_event {
-  struct event_hdr hdr;
 }__attribute__((packed));
 
 struct idle_end_event {
-  struct event_hdr hdr;
 }__attribute__((packed));
 
 struct fork_event {
-  struct event_hdr hdr;
   __le16 pid;
   __le16 tgid;
 }__attribute__((packed));
 
 struct exit_event {
-  struct event_hdr hdr;
 }__attribute__((packed));
 
 struct thread_name_event {
-  struct event_hdr hdr;
   __u16 pid;
   char comm[16];
 }__attribute__((packed));
 
 struct network_block_event {
-  struct event_hdr hdr;
 }__attribute__((packed));
 
 struct network_resume_event {
-  struct event_hdr hdr;
 }__attribute__((packed));
 
 struct waitqueue_wait_event {
-  struct event_hdr hdr;
   __le32 wq;
 }__attribute__((packed));
 
 struct waitqueue_wake_event {
-  struct event_hdr hdr;
   __le32 wq;
 }__attribute__((packed));
 
 struct waitqueue_notify_event {
-  struct event_hdr hdr;
   __le32 wq;
   __le16 pid;
 }__attribute__((packed));
 
 struct mutex_lock_event {
-  struct event_hdr hdr;
   __le32 lock;
 }__attribute__((packed));
 
 struct mutex_wait_event {
-  struct event_hdr hdr;
   __le32 lock;
 }__attribute__((packed));
 
 struct mutex_wake_event {
-  struct event_hdr hdr;
   __le32 lock;
 }__attribute__((packed));
 
 struct mutex_notify_event {
-  struct event_hdr hdr;
   __le32 lock;
   __le16 pid;
 }__attribute__((packed));
 
 struct sem_lock_event {
-  struct event_hdr hdr;
   __le32 lock;
 }__attribute__((packed));
 
 struct sem_wait_event {
-  struct event_hdr hdr;
   __le32 lock;
 }__attribute__((packed));
 
 struct io_block_event {
-  struct event_hdr hdr;
 }__attribute__((packed));
 
 struct io_resume_event {
-  struct event_hdr hdr;
+}__attribute__((packed));
+
+struct simple_event {
 }__attribute__((packed));
 
 #ifdef __KERNEL__
@@ -216,13 +190,17 @@ struct io_resume_event {
 #ifdef CONFIG_EVENT_LOGGING
 extern void* reserve_event(int len);
 
-#define reserve(name) name = (typeof(name)) reserve_event(sizeof(*name))
-#define init_event(type, event_type, name) type* name;	\
-  unsigned long flags;					\
-  local_irq_save(flags);				\
-  reserve(name);					\
-  if (name) {							\
-    event_log_header_init((struct event_hdr*) name, event_type)
+#define event_data(type, header) (type) (header + 1) 
+
+#define init_event(type, event_type, name)				\
+  struct event_hdr* header;						\
+  type* name;								\
+  unsigned long flags;							\
+  local_irq_save(flags);						\
+  header = (typeof(header)) reserve_event(sizeof(*header) + sizeof(*name)); \
+  name = event_data(typeof(name), header);				\
+  if (header) {								\
+  event_log_header_init((struct event_hdr*) name, event_type)
 
 #define finish_event() } \
     local_irq_restore(flags)
@@ -239,9 +217,23 @@ static inline void event_log_header_init(struct event_hdr* event, u8 type) {
 }
 
 static inline void event_log_simple(u8 event_type) {
-  init_event(struct event_hdr, event_type, event);
+  init_event(struct simple_event, event_type, event);
+  finish_event();
+}
+
+static inline void event_log_sync(void) {
+  init_event(struct sync_log_event, EVENT_SYNC_LOG, event);
+  memcpy(&event->magic, EVENT_LOG_MAGIC, 8);
   finish_event();
 }
+
+static inline void event_log_missed_count(int* count) {
+  init_event(struct missed_count_event, EVENT_MISSED_COUNT, event);
+  event->count = *count;
+  *count = 0;
+  finish_event();
+}
+
 #endif
 
 static inline void event_log_context_switch(pid_t old, pid_t new, long state) {
diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index 8707f0b..29fefc4 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -28,43 +28,18 @@ static struct proc_dir_entry* el_pfs_entry;
 static DEFINE_MUTEX(pfs_read_lock);
 static struct sbuffer* pfs_read_buffer;
 
-inline static void log_missed_count_event(struct sbuffer* buf) {
-  int cnt;
-  struct missed_count_event* event;
-  
-  cnt = __get_cpu_var(missed_events);
-  if (0 == cnt)
-    return;
-
-  event = (struct missed_count_event*) sbuffer_reserve(buf, sizeof(struct missed_count_event));
-  if (!event)
-    return; // Shouldn't happen in new buffer
-
-  event_log_header_init(&event->hdr, EVENT_MISSED_COUNT);
-  event->count = cnt;
-  __get_cpu_var(missed_events) = 0;
-}
-
-inline static void log_sync_event(struct sbuffer* buf) {
-  struct sync_log_event* event;
-
-  event = (struct sync_log_event*) sbuffer_reserve(buf, sizeof(struct sync_log_event));
-  if (!event)
-    return; // Shouldn't happen in new buffer
-
-  event_log_header_init(&event->hdr, EVENT_SYNC_LOG);
-  memcpy(&event->magic, EVENT_LOG_MAGIC, 8);
-}
-
-static void init_new_buffer(struct sbuffer* buf) {
-  log_sync_event(buf);
-  log_missed_count_event(buf);
+static void init_new_buffer(void) {
+  event_log_sync();
+  event_log_missed_count(&__get_cpu_var(missed_events));
 }
 
 inline static struct sbuffer* __get_new_cpu_buffer(void) {
   struct sbuffer* buf = queue_take_try(&empty_buffers);
-  if (NULL != buf)
-    init_new_buffer(buf);
+  if (NULL == buf) 
+    goto out;
+  __get_cpu_var(cpu_buffers) = buf;
+  init_new_buffer();
+ out:
   return buf;
 }
 
@@ -72,7 +47,6 @@ inline static struct sbuffer* __get_cpu_buffer(void) {
   struct sbuffer* buf = __get_cpu_var(cpu_buffers);
   if (NULL == buf) 
     buf = __get_new_cpu_buffer();
-  __get_cpu_var(cpu_buffers) = buf;
   return buf;
 }
 
-- 
1.9.1


From 9ac6c02406e5a0f03417a8339e8b2f189f0d7411 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Sat, 29 Sep 2012 21:33:39 -0400
Subject: [PATCH 47/72] eventlogging: separate timestamp from event header

---
 include/eventlogging/events.h | 30 ++++++++++++++++--------------
 1 file changed, 16 insertions(+), 14 deletions(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 14eada3..a4413c7 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -63,10 +63,9 @@
 struct event_hdr {
   __u8 event_type;
   __u8 cpu : 4;
-  __u8 flags : 4;
+  __u8 sec_len : 2;
+  __u8 usec_len : 2;
   __le16 pid;
-  __le32 tv_sec;
-  __le32 tv_usec;
 }__attribute__((packed));
 
 struct sync_log_event {
@@ -190,29 +189,32 @@ struct simple_event {
 #ifdef CONFIG_EVENT_LOGGING
 extern void* reserve_event(int len);
 
-#define event_data(type, header) (type) (header + 1) 
-
 #define init_event(type, event_type, name)				\
+  struct timeval tv;							\
   struct event_hdr* header;						\
+  __le32* sec;								\
+  __le32* usec;								\
   type* name;								\
   unsigned long flags;							\
   local_irq_save(flags);						\
-  header = (typeof(header)) reserve_event(sizeof(*header) + sizeof(*name)); \
-  name = event_data(typeof(name), header);				\
+  header = (typeof(header)) reserve_event(sizeof(*header) + 4 + 4 + sizeof(*name)); \
+  sec = (__le32*) (header+1);						\
+  usec = sec + 1;							\
+  name = (typeof(name)) (usec + 1);					\
   if (header) {								\
-  event_log_header_init((struct event_hdr*) name, event_type)
+  do_gettimeofday(&tv);							\
+  *sec = tv.tv_sec;							\
+  *usec = tv.tv_usec;							\
+  event_log_header_init((struct event_hdr*) name, 4, 4, event_type)
 
 #define finish_event() } \
     local_irq_restore(flags)
 
-static inline void event_log_header_init(struct event_hdr* event, u8 type) {
-  struct timeval tv;
-  do_gettimeofday(&tv);
-
+static inline void event_log_header_init(struct event_hdr* event, u8 sec_len, u8 usec_len, u8 type) {
   event->event_type = type;
-  event->tv_sec = tv.tv_sec;
-  event->tv_usec = tv.tv_usec;
   event->cpu = smp_processor_id();
+  event->sec_len = sec_len;
+  event->usec_len = usec_len;
   event->pid = current->pid | (in_interrupt() ? 0x8000 : 0);
 }
 
-- 
1.9.1


From 419e8f263c24b1d00f3ca41e8f7448009e47d9a8 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Sat, 29 Sep 2012 21:43:19 -0400
Subject: [PATCH 48/72] eventlogging: only set field pointers if memory
 reserved

---
 include/eventlogging/events.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index a4413c7..cdd8d77 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -198,10 +198,10 @@ extern void* reserve_event(int len);
   unsigned long flags;							\
   local_irq_save(flags);						\
   header = (typeof(header)) reserve_event(sizeof(*header) + 4 + 4 + sizeof(*name)); \
+  if (header) {								\
   sec = (__le32*) (header+1);						\
   usec = sec + 1;							\
   name = (typeof(name)) (usec + 1);					\
-  if (header) {								\
   do_gettimeofday(&tv);							\
   *sec = tv.tv_sec;							\
   *usec = tv.tv_usec;							\
-- 
1.9.1


From 092cab4172e33e6a68323e4a7148e9abd02ce4ec Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Sat, 29 Sep 2012 22:11:13 -0400
Subject: [PATCH 49/72] eventlogging: store delta timestamps in events

---
 include/eventlogging/events.h | 121 +++++++++++++++++++++++++++++++++++-------
 kernel/eventlogging/buffer.c  |   5 ++
 kernel/eventlogging/buffer.h  |   1 +
 kernel/eventlogging/logging.c |  18 ++++++-
 4 files changed, 124 insertions(+), 21 deletions(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index cdd8d77..91178c5 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -57,17 +57,49 @@
 #define EVENT_RESUME_FINISH 78
 
 #define MAX8 ((1 << 7) - 1)
-#define MAX16 ((1 << 14) - 1)
-#define MAX24 ((1 << 22) -1 )
+#define MIN8 (-(1 << 7))
+
+#define MAX16 ((1 << 15) - 1)
+#define MIN16 (-(1 << 15))
+
+#define MAX24 ((1 << 23) - 1)
+#define MIN24 (-(1 << 23))
 
 struct event_hdr {
   __u8 event_type;
-  __u8 cpu : 4;
-  __u8 sec_len : 2;
-  __u8 usec_len : 2;
+  __u8 cpu_tvlen;
   __le16 pid;
 }__attribute__((packed));
 
+#define CPU_MASK = 0xF0
+#define TVLEN_MASK = 0x0F
+
+#define SET_CPU(header, val) header->cpu_tvlen = (header->cpu_tvlen & ~(0xF0)) | ((val) << 4)
+#define GET_CPU(header) ((header->cpu_tvlen & 0xF0) >> 4)
+
+#define SET_TVLEN(header, sec, usec) do {				\
+    if ((sec) == 4)							\
+      header->cpu_tvlen = (header->cpu_tvlen & ~(0x0F)) | ((usec) << 2); \
+    else								\
+      header->cpu_tvlen = (header->cpu_tvlen & ~(0x0F)) | ((sec) << 2) | (usec); \
+  } while(0)
+
+#define GET_SEC_LEN(header) ({				\
+      int __ret;					\
+      if (0 == (header->cpu_tvlen & 0x03))		\
+	__ret = 4;					\
+      else						\
+	__ret = (header->cpu_tvlen & 0x0C) >> 2;	\
+      __ret;						\
+    })
+
+#define GET_USEC_LEN(header) ({			\
+  int __ret = (header->cpu_tvlen & 0x03);	\
+  if (0 == __ret)				\
+    __ret = (header->cpu_tvlen & 0x0C) >> 2;	\
+  __ret;					\
+})
+
 struct sync_log_event {
   char magic[8];
 }__attribute__((packed));
@@ -188,33 +220,82 @@ struct simple_event {
 
 #ifdef CONFIG_EVENT_LOGGING
 extern void* reserve_event(int len);
+extern void shrink_event(int len);
+extern struct timeval* get_timestamp(void);
 
-#define init_event(type, event_type, name)				\
+#define __init_event(type, event_type, name, diff)			\
   struct timeval tv;							\
+  u8 sec_len;								\
+  u8 usec_len;								\
   struct event_hdr* header;						\
-  __le32* sec;								\
-  __le32* usec;								\
+  char* sec;								\
+  char* usec;								\
   type* name;								\
   unsigned long flags;							\
   local_irq_save(flags);						\
-  header = (typeof(header)) reserve_event(sizeof(*header) + 4 + 4 + sizeof(*name)); \
+  header = (typeof(header)) reserve_event(sizeof(*header) + 4 + 3 + sizeof(*name)); \
   if (header) {								\
-  sec = (__le32*) (header+1);						\
-  usec = sec + 1;							\
-  name = (typeof(name)) (usec + 1);					\
-  do_gettimeofday(&tv);							\
-  *sec = tv.tv_sec;							\
-  *usec = tv.tv_usec;							\
-  event_log_header_init((struct event_hdr*) name, 4, 4, event_type)
+  tv = event_log_timestamp(diff);					\
+  if (diff) {								\
+    sec_len = vsize_sec(tv.tv_sec);					\
+    usec_len = vsize_usec(tv.tv_usec);					\
+  } else {								\
+    sec_len = 4;							\
+    usec_len = 3;							\
+  }									\
+  shrink_event(4 + 3 - sec_len - usec_len);				\
+  sec = (char*) (header+1);						\
+  usec = sec + sec_len;							\
+  name = (typeof(name)) (usec + usec_len);				\
+  memcpy(sec, &tv.tv_sec, sec_len);					\
+  memcpy(usec, &tv.tv_usec, usec_len);					\
+  event_log_header_init(header, sec_len, usec_len, event_type)
+
+#define init_event(type, event_type, name) __init_event(type, event_type, name, 1)
 
 #define finish_event() } \
     local_irq_restore(flags)
 
+/* Records the current timestamp and, if diff is true, returns the
+ * time passed since the last timestamp. Otherwise, the recorded current
+ * time is returned.  static inline struct timeval */
+static inline struct timeval event_log_timestamp(int diff) {
+  struct timeval *cur = get_timestamp();
+  struct timeval prev = *cur;
+  do_gettimeofday(cur);
+  if (!diff) 
+    return *cur;
+  prev.tv_sec = cur->tv_sec - prev.tv_sec;
+  prev.tv_usec = cur->tv_usec - prev.tv_usec;
+  return prev;
+}
+
+static inline u8 vsize_usec(long val) {
+  if ((MIN8 <= val) && (val <= MAX8))
+    return 1;
+  else if ((MIN16 <= val) && (val <= MAX16))
+    return 2;
+  else
+    return 3;
+}
+
+static inline u8 vsize_sec(long val) {
+  if (val == 0)
+    return 0;
+  else if ((MIN8 <= val) && (val <= MAX8))
+    return 1;
+  else if ((MIN16 <= val) && (val <= MAX16))
+    return 2;
+  else if ((MIN24 <= val) && (val <= MAX24))
+    return 3;
+  else
+    return 4;
+}
+
 static inline void event_log_header_init(struct event_hdr* event, u8 sec_len, u8 usec_len, u8 type) {
   event->event_type = type;
-  event->cpu = smp_processor_id();
-  event->sec_len = sec_len;
-  event->usec_len = usec_len;
+  SET_CPU(event, smp_processor_id());
+  SET_TVLEN(event, sec_len, usec_len);
   event->pid = current->pid | (in_interrupt() ? 0x8000 : 0);
 }
 
@@ -224,7 +305,7 @@ static inline void event_log_simple(u8 event_type) {
 }
 
 static inline void event_log_sync(void) {
-  init_event(struct sync_log_event, EVENT_SYNC_LOG, event);
+  __init_event(struct sync_log_event, EVENT_SYNC_LOG, event, 0);
   memcpy(&event->magic, EVENT_LOG_MAGIC, 8);
   finish_event();
 }
diff --git a/kernel/eventlogging/buffer.c b/kernel/eventlogging/buffer.c
index 0671b93..ed82a16 100644
--- a/kernel/eventlogging/buffer.c
+++ b/kernel/eventlogging/buffer.c
@@ -46,6 +46,11 @@ void* sbuffer_reserve(struct sbuffer* buf, int len) {
   }
 }
 
+/* Returns the specified number of bytes to the buffer */
+void sbuffer_cancel(struct sbuffer* buf, int len) {
+  buf->wp -= len;
+}
+
 int sbuffer_empty(struct sbuffer* buf) {
   return (buf->rp == buf->wp);
 }
diff --git a/kernel/eventlogging/buffer.h b/kernel/eventlogging/buffer.h
index 1b51443..fc38ce7 100644
--- a/kernel/eventlogging/buffer.h
+++ b/kernel/eventlogging/buffer.h
@@ -19,6 +19,7 @@ void sbuffer_free(struct sbuffer* buf);
 
 void sbuffer_clear(struct sbuffer* buf);
 void* sbuffer_reserve(struct sbuffer* buf, int len);
+void sbuffer_cancel(struct sbuffer* buf, int len);
 int sbuffer_empty(struct sbuffer* buf); // any data to read?
 int sbuffer_read(struct sbuffer* buf, char* page, int count);
 
diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index 29fefc4..5f2c889 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -19,6 +19,9 @@
 static DEFINE_PER_CPU(struct sbuffer*, cpu_buffers);
 static DEFINE_PER_CPU(unsigned int, missed_events);
 
+/* Timestamp from last packet */
+static DEFINE_PER_CPU(struct timeval, last_tv);
+
 static DEFINE_QUEUE(empty_buffers);
 static DEFINE_QUEUE(full_buffers);
 
@@ -30,7 +33,8 @@ static struct sbuffer* pfs_read_buffer;
 
 static void init_new_buffer(void) {
   event_log_sync();
-  event_log_missed_count(&__get_cpu_var(missed_events));
+  if  (__get_cpu_var(missed_events) > 0)
+       event_log_missed_count(&__get_cpu_var(missed_events));
 }
 
 inline static struct sbuffer* __get_new_cpu_buffer(void) {
@@ -81,6 +85,18 @@ void* reserve_event(int len) {
   return wp;
 }
 
+void shrink_event(int len) {
+  struct sbuffer* buf;
+  buf = __get_cpu_buffer();
+  if (buf)
+    sbuffer_cancel(buf, len);
+}
+
+/* Returns a reference to the per-cpu timestamp of the last record */
+struct timeval* get_timestamp(void) {
+  return &__get_cpu_var(last_tv);
+}
+
 /*
  * Must be called with hotplugging disabled
  * and 'cpu' offline.
-- 
1.9.1


From 21b09d6a449e12d4f4ea449986a26b6c82a9d0d1 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 1 Oct 2012 14:36:26 -0400
Subject: [PATCH 50/72] eventlogging: remove duplicate copy of old pid from
 context switch event

---
 include/eventlogging/events.h | 4 +---
 kernel/sched.c                | 2 +-
 2 files changed, 2 insertions(+), 4 deletions(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 91178c5..8ca3538 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -109,7 +109,6 @@ struct missed_count_event {
 }__attribute__((packed));
 
 struct context_switch_event {
-  __le16 old_pid;
   __le16 new_pid;
   __u8   state;  
 }__attribute__((packed));
@@ -319,10 +318,9 @@ static inline void event_log_missed_count(int* count) {
 
 #endif
 
-static inline void event_log_context_switch(pid_t old, pid_t new, long state) {
+static inline void event_log_context_switch(pid_t new, long state) {
 #ifdef CONFIG_EVENT_CONTEXT_SWITCH
   init_event(struct context_switch_event, EVENT_CONTEXT_SWITCH, event);
-  event->old_pid = old;
   event->new_pid = new;
   event->state = (__u8) (0x0FF & state);
   finish_event();
diff --git a/kernel/sched.c b/kernel/sched.c
index 0c2f128..22df291 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -3146,7 +3146,7 @@ context_switch(struct rq *rq, struct task_struct *prev,
 {
 	struct mm_struct *mm, *oldmm;
 
-	event_log_context_switch(prev->pid, next->pid, prev->state);
+	event_log_context_switch(next->pid, prev->state);
 
 	prepare_task_switch(rq, prev, next);
 
-- 
1.9.1


From 208275adc2bd2b653031b1a0f4f0c2756a001e94 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 1 Oct 2012 14:39:33 -0400
Subject: [PATCH 51/72] eventlogging: remove empty per-event structs

---
 include/eventlogging/events.h | 33 ---------------------------------
 1 file changed, 33 deletions(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 8ca3538..57b24fc 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -113,15 +113,6 @@ struct context_switch_event {
   __u8   state;  
 }__attribute__((packed));
 
-struct preempt_tick_event {
-}__attribute__((packed));
-
-struct preempt_wakeup_event {
-}__attribute__((packed));
-
-struct yield_event {
-}__attribute__((packed));
-
 struct hotcpu_event {
   __u8 cpu;
 }__attribute__((packed));
@@ -135,34 +126,16 @@ struct wake_unlock_event {
   __le32 lock;
 }__attribute__((packed));
 
-struct suspend_event {
-}__attribute__((packed));
-
-struct idle_start_event {
-}__attribute__((packed));
-
-struct idle_end_event {
-}__attribute__((packed));
-
 struct fork_event {
   __le16 pid;
   __le16 tgid;
 }__attribute__((packed));
 
-struct exit_event {
-}__attribute__((packed));
-
 struct thread_name_event {
   __u16 pid;
   char comm[16];
 }__attribute__((packed));
 
-struct network_block_event {
-}__attribute__((packed));
-
-struct network_resume_event {
-}__attribute__((packed));
-
 struct waitqueue_wait_event {
   __le32 wq;
 }__attribute__((packed));
@@ -201,12 +174,6 @@ struct sem_wait_event {
   __le32 lock;
 }__attribute__((packed));
 
-struct io_block_event {
-}__attribute__((packed));
-
-struct io_resume_event {
-}__attribute__((packed));
-
 struct simple_event {
 }__attribute__((packed));
 
-- 
1.9.1


From cbedfcd49b15901460f62899a93defd92e97714c Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 1 Oct 2012 15:05:18 -0400
Subject: [PATCH 52/72] eventlogging: refactor lock/notify common structure and
 code

---
 include/eventlogging/events.h | 71 +++++++++++++------------------------------
 kernel/eventlogging/events.c  | 13 ++------
 2 files changed, 24 insertions(+), 60 deletions(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 57b24fc..73fbadc 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -136,44 +136,15 @@ struct thread_name_event {
   char comm[16];
 }__attribute__((packed));
 
-struct waitqueue_wait_event {
-  __le32 wq;
-}__attribute__((packed));
-
-struct waitqueue_wake_event {
-  __le32 wq;
-}__attribute__((packed));
-
-struct waitqueue_notify_event {
-  __le32 wq;
-  __le16 pid;
-}__attribute__((packed));
-
-struct mutex_lock_event {
+struct general_lock_event {
   __le32 lock;
 }__attribute__((packed));
 
-struct mutex_wait_event {
-  __le32 lock;
-}__attribute__((packed));
-
-struct mutex_wake_event {
-  __le32 lock;
-}__attribute__((packed));
-
-struct mutex_notify_event {
+struct general_notify_event {
   __le32 lock;
   __le16 pid;
 }__attribute__((packed));
 
-struct sem_lock_event {
-  __le32 lock;
-}__attribute__((packed));
-
-struct sem_wait_event {
-  __le32 lock;
-}__attribute__((packed));
-
 struct simple_event {
 }__attribute__((packed));
 
@@ -283,6 +254,19 @@ static inline void event_log_missed_count(int* count) {
   finish_event();
 }
 
+static inline void event_log_general_lock(__u8 event_type, void* lock) {
+  init_event(struct general_lock_event, event_type, event);
+  event->lock = (__le32) lock;
+  finish_event();
+}
+
+static inline void event_log_general_notify(__u8 event_type, void* lock, pid_t pid) {
+  init_event(struct general_notify_event, event_type, event);
+  event->lock = (__le32) lock;
+  event->pid = pid;
+  finish_event();
+}
+
 #endif
 
 static inline void event_log_context_switch(pid_t new, long state) {
@@ -475,50 +459,37 @@ void event_log_waitqueue_notify(void* wq, pid_t pid);
 
 static inline void event_log_mutex_lock(void* lock) {
 #ifdef CONFIG_EVENT_MUTEX_LOCK
-  init_event(struct mutex_lock_event, EVENT_MUTEX_LOCK, event);
-  event->lock = (__le32) lock;
-  finish_event();
+  event_log_general_lock(EVENT_MUTEX_LOCK, lock);
 #endif
 }
 
 static inline void event_log_mutex_wait(void* lock) {
 #ifdef CONFIG_EVENT_MUTEX_WAIT
-  init_event(struct mutex_wait_event, EVENT_MUTEX_WAIT, event);
-  event->lock = (__le32) lock;
-  finish_event();
+  event_log_general_lock(EVENT_MUTEX_WAIT, lock);
 #endif
 }
 
 static inline void event_log_mutex_wake(void* lock) {
 #ifdef CONFIG_EVENT_MUTEX_WAKE
-  init_event(struct mutex_wake_event, EVENT_MUTEX_WAKE, event);
-  event->lock = (__le32) lock;
-  finish_event();
+  event_log_general_lock(EVENT_MUTEX_WAKE, lock);
 #endif
 }
 
 static inline void event_log_mutex_notify(void* lock, pid_t pid) {
 #ifdef CONFIG_EVENT_MUTEX_NOTIFY
-  init_event(struct mutex_notify_event, EVENT_MUTEX_NOTIFY, event);
-  event->lock = (__le32) lock;
-  event->pid = pid;
-  finish_event();
+  event_log_general_notify(EVENT_MUTEX_NOTIFY, lock, pid);
 #endif
 }
 
 static inline void event_log_sem_lock(void* lock) {
 #ifdef CONFIG_EVENT_SEMAPHORE_LOCK
-  init_event(struct sem_lock_event, EVENT_SEMAPHORE_LOCK, event);
-  event->lock = (__le32) lock;
-  finish_event();
+  event_log_general_lock(EVENT_SEMAPHORE_LOCK, lock);
 #endif
 }
 
 static inline void event_log_sem_wait(void* lock) {
 #ifdef CONFIG_EVENT_SEMAPHORE_WAIT
-  init_event(struct sem_wait_event, EVENT_SEMAPHORE_WAIT, event);
-  event->lock = (__le32) lock;
-  finish_event();
+  event_log_general_lock(EVENT_SEMAPHORE_WAIT, lock);
 #endif
 }
 
diff --git a/kernel/eventlogging/events.c b/kernel/eventlogging/events.c
index 7f4b3d2..c189332 100644
--- a/kernel/eventlogging/events.c
+++ b/kernel/eventlogging/events.c
@@ -2,25 +2,18 @@
 
 void event_log_waitqueue_wait(void* wq) {
 #ifdef CONFIG_EVENT_WAITQUEUE_WAIT
-  init_event(struct waitqueue_wait_event, EVENT_WAITQUEUE_WAIT, event);
-  event->wq = (__le32) wq;
-  finish_event();
+  event_log_general_lock(EVENT_WAITQUEUE_WAIT, wq);
 #endif
 }
 
 void event_log_waitqueue_wake(void* wq) {
 #ifdef CONFIG_EVENT_WAITQUEUE_WAKE
-  init_event(struct waitqueue_wake_event, EVENT_WAITQUEUE_WAKE, event);
-  event->wq = (__le32) wq;
-  finish_event();
+  event_log_general_lock(EVENT_WAITQUEUE_WAKE, wq);
 #endif
 }
 
 void event_log_waitqueue_notify(void* wq, pid_t pid) {
 #ifdef CONFIG_EVENT_WAITQUEUE_NOTIFY
-  init_event(struct waitqueue_notify_event, EVENT_WAITQUEUE_NOTIFY, event);
-  event->wq = (__le32) wq;
-  event->pid = pid;
-  finish_event();
+  event_log_general_notify(EVENT_WAITQUEUE_NOTIFY, wq, pid);
 #endif
 }
-- 
1.9.1


From 787162349517643c9205ccada81963be05561009 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 1 Oct 2012 15:31:54 -0400
Subject: [PATCH 53/72] eventlogging: log waitqueue notify events

---
 kernel/sched.c | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/kernel/sched.c b/kernel/sched.c
index 22df291..91f34ea 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -4460,7 +4460,18 @@ static void __wake_up_common(wait_queue_head_t *q, unsigned int mode,
 
 	list_for_each_entry_safe(curr, next, &q->task_list, task_list) {
 		unsigned flags = curr->flags;
-
+		/* the waitqueuentry can be initialized either with
+                 * the default wake function and the private void*
+                 * pointing to the task struct or with a custom wake
+                 * function and the private void* set to NULL.  We are
+                 * only interested in the default wake function (which
+                 * actually wakes a process), so we only log an event
+                 * with when the private void* is non-null.  This also
+                 * makes the casting to (struct task_struct*) safe,
+                 * although future kernels could break this.
+		 */
+		if (curr->private)
+			event_log_waitqueue_notify(q, ((struct task_struct*)curr->private)->pid);
 		if (curr->func(curr, mode, wake_flags, key) &&
 				(flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)
 			break;
-- 
1.9.1


From 73b7050eb080cb9de5eeb905650a1f1a3aadb385 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 1 Oct 2012 15:43:36 -0400
Subject: [PATCH 54/72] eventlogging: log semaphore wake and notify events

---
 arch/arm/configs/tegra3_android_eventlogging_defconfig |  2 ++
 include/eventlogging/events.h                          | 14 ++++++++++++++
 kernel/eventlogging/Kconfig                            |  8 ++++++++
 kernel/semaphore.c                                     |  8 ++++++--
 4 files changed, 30 insertions(+), 2 deletions(-)

diff --git a/arch/arm/configs/tegra3_android_eventlogging_defconfig b/arch/arm/configs/tegra3_android_eventlogging_defconfig
index f77ef40..08d1b22 100644
--- a/arch/arm/configs/tegra3_android_eventlogging_defconfig
+++ b/arch/arm/configs/tegra3_android_eventlogging_defconfig
@@ -543,6 +543,8 @@ CONFIG_EVENT_SOCK_BLOCK=y
 CONFIG_EVENT_SOCK_RESUME=y
 CONFIG_EVENT_SEMAPHORE_LOCK=n
 CONFIG_EVENT_SEMAPHORE_WAIT=y
+CONFIG_EVENT_SEMAPHORE_WAKE=y
+CONFIG_EVENT_SEMAPHORE_NOTIFY=y
 CONFIG_EVENT_MUTEX_LOCK=n
 CONFIG_EVENT_MUTEX_WAIT=y
 CONFIG_EVENT_MUTEX_WAKE=y
diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 73fbadc..7dbf1c9 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -35,6 +35,8 @@
 
 #define EVENT_SEMAPHORE_LOCK 40
 #define EVENT_SEMAPHORE_WAIT 41
+#define EVENT_SEMAPHORE_WAKE 42
+#define EVENT_SEMAPHORE_NOTIFY 43
 
 #define EVENT_MUTEX_LOCK 50
 #define EVENT_MUTEX_WAIT 51
@@ -493,5 +495,17 @@ static inline void event_log_sem_wait(void* lock) {
 #endif
 }
 
+static inline void event_log_sem_wake(void* lock) {
+#ifdef CONFIG_EVENT_SEMAPHORE_WAIT
+  event_log_general_lock(EVENT_SEMAPHORE_WAIT, lock);
+#endif
+}
+
+static inline void event_log_sem_notify(void* lock, pid_t pid) {
+#ifdef CONFIG_EVENT_SEMAPHORE_NOTIFY
+  event_log_general_notify(EVENT_SEMAPHORE_NOTIFY, lock, pid);
+#endif
+}
+
 #endif // __KERNEL__
 #endif // EVENTLOGGING_EVENTS_H
diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index 139c0fa..8d07d0a 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -130,6 +130,14 @@ config EVENT_SEMAPHORE_WAIT
        bool "Log semaphore waits"
        default yes
 
+config EVENT_SEMAPHORE_WAKE
+       bool "Log semaphore wakes"
+       default yes
+
+config EVENT_SEMAPHORE_NOTIFY
+       bool "Log semaphore notifies"
+       default yes
+
 config EVENT_MUTEX_LOCK
        bool "Log mutex locks"
        default no
diff --git a/kernel/semaphore.c b/kernel/semaphore.c
index 8d372cc..884b238 100644
--- a/kernel/semaphore.c
+++ b/kernel/semaphore.c
@@ -228,7 +228,6 @@ static inline int __sched __down_common(struct semaphore *sem, long state,
 	waiter.up = 0;
 
 	event_log_sem_wait(sem);
-
 	for (;;) {
 		if (signal_pending_state(state, task))
 			goto interrupted;
@@ -238,15 +237,19 @@ static inline int __sched __down_common(struct semaphore *sem, long state,
 		spin_unlock_irq(&sem->lock);
 		timeout = schedule_timeout(timeout);
 		spin_lock_irq(&sem->lock);
-		if (waiter.up)
+		if (waiter.up) {
+			event_log_sem_wake(sem);
 			return 0;
+		}
 	}
 
  timed_out:
+	event_log_sem_wake(sem);
 	list_del(&waiter.list);
 	return -ETIME;
 
  interrupted:
+	event_log_sem_wake(sem);
 	list_del(&waiter.list);
 	return -EINTR;
 }
@@ -277,5 +280,6 @@ static noinline void __sched __up(struct semaphore *sem)
 						struct semaphore_waiter, list);
 	list_del(&waiter->list);
 	waiter->up = 1;
+	event_log_sem_notify(sem, waiter->task->pid);
 	wake_up_process(waiter->task);
 }
-- 
1.9.1


From 851a1b9a741b7cf9eadf8cd861c0f8dbf440f9b1 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Wed, 3 Oct 2012 00:19:29 -0400
Subject: [PATCH 55/72] eventlogging: learn to log futex events

---
 .../configs/tegra3_android_eventlogging_defconfig  |  3 +++
 include/eventlogging/events.h                      | 22 ++++++++++++++++++++
 kernel/eventlogging/Kconfig                        | 12 +++++++++++
 kernel/futex.c                                     | 24 ++++++++++++++--------
 4 files changed, 52 insertions(+), 9 deletions(-)

diff --git a/arch/arm/configs/tegra3_android_eventlogging_defconfig b/arch/arm/configs/tegra3_android_eventlogging_defconfig
index 08d1b22..6d2144a 100644
--- a/arch/arm/configs/tegra3_android_eventlogging_defconfig
+++ b/arch/arm/configs/tegra3_android_eventlogging_defconfig
@@ -549,4 +549,7 @@ CONFIG_EVENT_MUTEX_LOCK=n
 CONFIG_EVENT_MUTEX_WAIT=y
 CONFIG_EVENT_MUTEX_WAKE=y
 CONFIG_EVENT_MUTEX_NOTIFY=y
+CONFIG_EVENT_FUTEX_WAIT=y
+CONFIG_EVENT_FUTEX_WAKE=y
+CONFIG_EVENT_FUTEX_NOTIFY=y
 CONFIG_EVENT_THREAD_NAME=y
diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 7dbf1c9..60965cb 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -38,6 +38,10 @@
 #define EVENT_SEMAPHORE_WAKE 42
 #define EVENT_SEMAPHORE_NOTIFY 43
 
+#define EVENT_FUTEX_WAIT 46
+#define EVENT_FUTEX_WAKE 47
+#define EVENT_FUTEX_NOTIFY 48
+
 #define EVENT_MUTEX_LOCK 50
 #define EVENT_MUTEX_WAIT 51
 #define EVENT_MUTEX_WAKE 52
@@ -483,6 +487,24 @@ static inline void event_log_mutex_notify(void* lock, pid_t pid) {
 #endif
 }
 
+static inline void event_log_futex_wait(void* lock) {
+#ifdef CONFIG_EVENT_FUTEX_WAIT
+  event_log_general_lock(EVENT_FUTEX_WAIT, lock);
+#endif
+}
+
+static inline void event_log_futex_wake(void* lock) {
+#ifdef CONFIG_EVENT_MUTEX_WAKE
+  event_log_general_lock(EVENT_FUTEX_WAKE, lock);
+#endif
+}
+
+static inline void event_log_futex_notify(void* lock, pid_t pid) {
+#ifdef CONFIG_EVENT_FUTEX_NOTIFY
+  event_log_general_notify(EVENT_FUTEX_NOTIFY, lock, pid);
+#endif
+}
+
 static inline void event_log_sem_lock(void* lock) {
 #ifdef CONFIG_EVENT_SEMAPHORE_LOCK
   event_log_general_lock(EVENT_SEMAPHORE_LOCK, lock);
diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index 8d07d0a..2310c48 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -154,6 +154,18 @@ config EVENT_MUTEX_NOTIFY
        bool "Log who wakes up a mutex"
        default yes
 
+config EVENT_FUTEX_WAIT
+       bool "Log futex waits"
+       default yes
+
+config EVENT_FUTEX_WAKE
+       bool "Log futex wakeups"
+       default yes
+
+config EVENT_FUTEX_NOTIFY
+       bool "Log who wakes up a futex"
+       default yes
+
 config EVENT_THREAD_NAME
        bool "Log when a process name is changed"
        default yes
diff --git a/kernel/futex.c b/kernel/futex.c
index b2d51a7..623ef95 100644
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@ -63,6 +63,8 @@
 
 #include <asm/futex.h>
 
+#include <eventlogging/events.h>
+
 #include "rtmutex_common.h"
 
 int __read_mostly futex_cmpxchg_enabled;
@@ -836,7 +838,7 @@ static void __unqueue_futex(struct futex_q *q)
  * The hash bucket lock must be held when this is called.
  * Afterwards, the futex_q must not be accessed.
  */
-static void wake_futex(struct futex_q *q)
+static void wake_futex(u32 __user *uaddr, struct futex_q *q)
 {
 	struct task_struct *p = q->task;
 
@@ -859,6 +861,7 @@ static void wake_futex(struct futex_q *q)
 	smp_wmb();
 	q->lock_ptr = NULL;
 
+	event_log_futex_notify(uaddr, p->pid);
 	wake_up_state(p, TASK_NORMAL);
 	put_task_struct(p);
 }
@@ -1001,7 +1004,7 @@ futex_wake(u32 __user *uaddr, unsigned int flags, int nr_wake, u32 bitset)
 			if (!(this->bitset & bitset))
 				continue;
 
-			wake_futex(this);
+			wake_futex(uaddr, this);
 			if (++ret >= nr_wake)
 				break;
 		}
@@ -1075,7 +1078,7 @@ retry_private:
 
 	plist_for_each_entry_safe(this, next, head, list) {
 		if (match_futex (&this->key, &key1)) {
-			wake_futex(this);
+ 			wake_futex(uaddr1, this);
 			if (++ret >= nr_wake)
 				break;
 		}
@@ -1087,7 +1090,7 @@ retry_private:
 		op_ret = 0;
 		plist_for_each_entry_safe(this, next, head, list) {
 			if (match_futex (&this->key, &key2)) {
-				wake_futex(this);
+				wake_futex(uaddr2, this);
 				if (++op_ret >= nr_wake2)
 					break;
 			}
@@ -1397,7 +1400,7 @@ retry_private:
 		 * woken by futex_unlock_pi().
 		 */
 		if (++task_count <= nr_wake && !requeue_pi) {
-			wake_futex(this);
+			wake_futex(uaddr1, this);
 			continue;
 		}
 
@@ -1756,7 +1759,7 @@ out:
  * @q:		the futex_q to queue up on
  * @timeout:	the prepared hrtimer_sleeper, or null for no timeout
  */
-static void futex_wait_queue_me(struct futex_hash_bucket *hb, struct futex_q *q,
+static void futex_wait_queue_me(u32 __user *uaddr, struct futex_hash_bucket *hb, struct futex_q *q,
 				struct hrtimer_sleeper *timeout)
 {
 	/*
@@ -1785,8 +1788,11 @@ static void futex_wait_queue_me(struct futex_hash_bucket *hb, struct futex_q *q,
 		 * flagged for rescheduling. Only call schedule if there
 		 * is no timeout, or if it has yet to expire.
 		 */
-		if (!timeout || timeout->task)
+		if (!timeout || timeout->task) {
+			event_log_futex_wait(uaddr);
 			schedule();
+			event_log_futex_wake(uaddr);
+		}
 	}
 	__set_current_state(TASK_RUNNING);
 }
@@ -1901,7 +1907,7 @@ retry:
 		goto out;
 
 	/* queue_me and wait for wakeup, timeout, or a signal. */
-	futex_wait_queue_me(hb, &q, to);
+	futex_wait_queue_me(uaddr, hb, &q, to);
 
 	/* If we were woken (and unqueued), we succeeded, whatever. */
 	ret = 0;
@@ -2309,7 +2315,7 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
 		goto out_key2;
 
 	/* Queue the futex_q, drop the hb lock, wait for wakeup. */
-	futex_wait_queue_me(hb, &q, to);
+	futex_wait_queue_me(uaddr, hb, &q, to);
 
 	spin_lock(&hb->lock);
 	ret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);
-- 
1.9.1


From 8d458b859acb95660f0b69731475ecaa46336e71 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Thu, 4 Oct 2012 16:04:54 -0400
Subject: [PATCH 56/72] eventlogging: poke buffer queue readers when safe

---
 include/eventlogging/events.h | 34 ++++++++++++++++++++++------------
 kernel/eventlogging/logging.c |  4 ++++
 kernel/eventlogging/queue.h   |  8 ++++++++
 3 files changed, 34 insertions(+), 12 deletions(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 60965cb..e8abdd2 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -164,6 +164,7 @@ struct simple_event {
 #ifdef CONFIG_EVENT_LOGGING
 extern void* reserve_event(int len);
 extern void shrink_event(int len);
+extern void poke_queues(void);
 extern struct timeval* get_timestamp(void);
 
 #define __init_event(type, event_type, name, diff)			\
@@ -196,7 +197,11 @@ extern struct timeval* get_timestamp(void);
 
 #define init_event(type, event_type, name) __init_event(type, event_type, name, 1)
 
-#define finish_event() } \
+#define finish_event() poke_queues(); \
+  }				      \
+ local_irq_restore(flags)
+
+#define finish_event_no_poke() }      \
     local_irq_restore(flags)
 
 /* Records the current timestamp and, if diff is true, returns the
@@ -247,30 +252,35 @@ static inline void event_log_simple(u8 event_type) {
   finish_event();
 }
 
+static inline void event_log_simple_no_poke(u8 event_type) {
+  init_event(struct simple_event, event_type, event);
+  finish_event_no_poke();
+}
+
 static inline void event_log_sync(void) {
   __init_event(struct sync_log_event, EVENT_SYNC_LOG, event, 0);
   memcpy(&event->magic, EVENT_LOG_MAGIC, 8);
-  finish_event();
+  finish_event_no_poke();
 }
 
 static inline void event_log_missed_count(int* count) {
   init_event(struct missed_count_event, EVENT_MISSED_COUNT, event);
   event->count = *count;
   *count = 0;
-  finish_event();
+  finish_event_no_poke();
 }
 
 static inline void event_log_general_lock(__u8 event_type, void* lock) {
   init_event(struct general_lock_event, event_type, event);
   event->lock = (__le32) lock;
-  finish_event();
+  finish_event_no_poke();
 }
 
 static inline void event_log_general_notify(__u8 event_type, void* lock, pid_t pid) {
   init_event(struct general_notify_event, event_type, event);
   event->lock = (__le32) lock;
   event->pid = pid;
-  finish_event();
+  finish_event_no_poke();
 }
 
 #endif
@@ -280,19 +290,19 @@ static inline void event_log_context_switch(pid_t new, long state) {
   init_event(struct context_switch_event, EVENT_CONTEXT_SWITCH, event);
   event->new_pid = new;
   event->state = (__u8) (0x0FF & state);
-  finish_event();
+  finish_event_no_poke();
 #endif
 }
 
 static inline void event_log_preempt_tick(void) {
 #ifdef CONFIG_EVENT_PREEMPT_TICK
-  event_log_simple(EVENT_PREEMPT_TICK);
+  event_log_simple_no_poke(EVENT_PREEMPT_TICK);
 #endif
 }
 
 static inline void event_log_preempt_wakeup(void) {
 #ifdef CONFIG_EVENT_PREEMPT_WAKEUP
-  event_log_simple(EVENT_PREEMPT_WAKEUP);
+  event_log_simple_no_poke(EVENT_PREEMPT_WAKEUP);
 #endif
 }
 
@@ -342,25 +352,25 @@ static inline void event_log_idle_end(void) {
 
 static inline void event_log_suspend_start(void) {
 #ifdef CONFIG_EVENT_SUSPEND_START
-  event_log_simple(EVENT_SUSPEND_START);
+  event_log_simple_no_poke(EVENT_SUSPEND_START);
 #endif
 }
 
 static inline void event_log_suspend(void) {
 #ifdef CONFIG_EVENT_SUSPEND
-  event_log_simple(EVENT_SUSPEND);
+  event_log_simple_no_poke(EVENT_SUSPEND);
 #endif
 }
 
 static inline void event_log_resume(void) {
 #ifdef CONFIG_EVENT_RESUME
-  event_log_simple(EVENT_RESUME);
+  event_log_simple_no_poke(EVENT_RESUME);
 #endif
 }
 
 static inline void event_log_resume_finish(void) {
 #ifdef CONFIG_EVENT_RESUME_FINISH
-  event_log_simple(EVENT_RESUME_FINISH);
+  event_log_simple_no_poke(EVENT_RESUME_FINISH);
 #endif
 }
 
diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index 5f2c889..411af05 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -85,6 +85,10 @@ void* reserve_event(int len) {
   return wp;
 }
 
+void poke_queues(void) {
+  queue_poke(&full_buffers);
+}
+
 void shrink_event(int len) {
   struct sbuffer* buf;
   buf = __get_cpu_buffer();
diff --git a/kernel/eventlogging/queue.h b/kernel/eventlogging/queue.h
index bf59cbd..e199c42 100644
--- a/kernel/eventlogging/queue.h
+++ b/kernel/eventlogging/queue.h
@@ -43,6 +43,14 @@ static inline void queue_put(struct queue* queue, struct sbuffer *buf) {
   queue_unlock(queue);
 }
 
+/* Wakes up any blocked peekers or takers if the queue is not empty */
+static inline void queue_poke(struct queue* queue) {
+  queue_lock(queue);
+  if (unlikely(!list_empty(&queue->list)))
+    wake_up_interruptible(&queue->wait);
+  queue_unlock(queue);
+}
+
 static inline struct sbuffer* __queue_peek_try(struct queue* queue) {
   if (!list_empty(&queue->list))
     return list_entry(queue->list.next, struct sbuffer, list);
-- 
1.9.1


From bb63a4c8f9e3d8e27ee33425deefe65454c61385 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Thu, 4 Oct 2012 16:05:11 -0400
Subject: [PATCH 57/72] eventlogging: poke buffer queue readers after
 context_switch

---
 kernel/sched.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/kernel/sched.c b/kernel/sched.c
index 91f34ea..de7ea46 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -4318,9 +4318,14 @@ static inline void sched_submit_work(struct task_struct *tsk)
 asmlinkage void __sched schedule(void)
 {
 	struct task_struct *tsk = current;
-
+	
 	sched_submit_work(tsk);
 	__schedule();
+#ifdef CONFIG_EVENT_LOGGING
+	/* Cannot wake up blocked peekers and takers when logging the
+	   event in context_switch(), so manually poke them here. */
+	poke_queues();
+#endif
 }
 EXPORT_SYMBOL(schedule);
 
-- 
1.9.1


From 80b161ff0fec65996fba0e7a9f571323a0b13a52 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Fri, 5 Oct 2012 18:29:10 -0400
Subject: [PATCH 58/72] eventlogging: lzo compress full buffers

---
 kernel/eventlogging/buffer.c  | 26 ++++++++++++++
 kernel/eventlogging/buffer.h  |  5 +++
 kernel/eventlogging/logging.c | 80 +++++++++++++++++++++++++++++++++++++++++--
 3 files changed, 109 insertions(+), 2 deletions(-)

diff --git a/kernel/eventlogging/buffer.c b/kernel/eventlogging/buffer.c
index ed82a16..127e4d7 100644
--- a/kernel/eventlogging/buffer.c
+++ b/kernel/eventlogging/buffer.c
@@ -72,4 +72,30 @@ int sbuffer_read(struct sbuffer* buf, char* page, int count) {
   return len;
 }
 
+/* Swaps the memory held by the two buffers */
+void sbuffer_swap(struct sbuffer* buf1, struct sbuffer* buf2) {
+  int order;
+  void *start, *end, *rp, *wp;
+  
+  /* Save values from buf1 */
+  order = buf1->order;
+  start = buf1->start;
+  end = buf1->end;
+  rp = buf1->rp;
+  wp = buf1->wp;
+  
+  /* Move buf2 to buf1 */
+  buf1->order = buf2->order;
+  buf1->start = buf2->start;
+  buf1->end = buf2->end;
+  buf1->rp = buf2->rp;
+  buf1->wp = buf2->wp;
+
+  /* And move buf1 copy to buf2 */
+  buf2->order = order;
+  buf2->start = start;
+  buf2->end = end;
+  buf2->rp = rp;
+  buf2->wp = wp;
+}
 
diff --git a/kernel/eventlogging/buffer.h b/kernel/eventlogging/buffer.h
index fc38ce7..5165898 100644
--- a/kernel/eventlogging/buffer.h
+++ b/kernel/eventlogging/buffer.h
@@ -2,9 +2,11 @@
 #define EVENT_LOGGING_BUFFER_H
 
 #include <linux/list.h>
+#include <linux/workqueue.h>
 
 struct sbuffer {
   struct list_head list;
+  struct work_struct work;
   int order;   // order of page allocation (2^order pages)
   void* start; // starting address
   void* end;   // last address in buffer
@@ -23,4 +25,7 @@ void sbuffer_cancel(struct sbuffer* buf, int len);
 int sbuffer_empty(struct sbuffer* buf); // any data to read?
 int sbuffer_read(struct sbuffer* buf, char* page, int count);
 
+/* Swaps the memory held by the two buffers */
+void sbuffer_swap(struct sbuffer* buf1, struct sbuffer* buf2); 
+
 #endif
diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index 411af05..0072da1 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -4,6 +4,7 @@
 #include <linux/cpu.h>
 #include <linux/slab.h>
 #include <linux/proc_fs.h>
+#include <linux/lzo.h>
 
 #include <eventlogging/events.h>
 
@@ -24,6 +25,7 @@ static DEFINE_PER_CPU(struct timeval, last_tv);
 
 static DEFINE_QUEUE(empty_buffers);
 static DEFINE_QUEUE(full_buffers);
+static DEFINE_QUEUE(compressed_buffers);
 
 #define PFS_NAME "event_logging"
 #define PFS_PERMS S_IFREG|S_IROTH|S_IRGRP|S_IRUSR|S_IWOTH|S_IWGRP|S_IWUSR
@@ -31,6 +33,9 @@ static struct proc_dir_entry* el_pfs_entry;
 static DEFINE_MUTEX(pfs_read_lock);
 static struct sbuffer* pfs_read_buffer;
 
+static DEFINE_MUTEX(compress_lock);
+static struct sbuffer* compress_empty_buffer;
+
 static void init_new_buffer(void) {
   event_log_sync();
   if  (__get_cpu_var(missed_events) > 0)
@@ -85,8 +90,10 @@ void* reserve_event(int len) {
   return wp;
 }
 
+static void schedule_compression(void);
+
 void poke_queues(void) {
-  queue_poke(&full_buffers);
+  schedule_compression();
 }
 
 void shrink_event(int len) {
@@ -171,9 +178,78 @@ static __init int init_alloc_buffers(void) {
     printk("eventlogging: prepare buffer for CPU %d\n", cpu);
   }
 
+  /* Allocate empty buffer for compression */
+  compress_empty_buffer = queue_take_try(&empty_buffers);
+  if (!compress_empty_buffer)
+    printk(KERN_ERR "eventlogging: failed to allocate empty buffer for compression\n");
+
   return 0;
 }
 
+/* ============================= Compression ================================ */
+static char lzo_work_mem[LZO1X_1_MEM_COMPRESS];
+
+static int compress_buffer(struct sbuffer* buf) {
+  int err;
+  u32 compressed_len;
+
+  err = mutex_lock_interruptible(&compress_lock);
+  if (err)
+    return err;
+
+  /* Try to get empty buffer, if one is not already available. This
+     should never happen. */
+  if (!compress_empty_buffer && 
+      !(compress_empty_buffer = queue_take_try(&empty_buffers)))
+    goto out;
+
+  sbuffer_clear(compress_empty_buffer);
+
+  /* Reserve four bytes to record data size */
+  compress_empty_buffer->wp += 4;
+
+  compressed_len = compress_empty_buffer->end - compress_empty_buffer->start;
+  err = lzo1x_1_compress(buf->rp, (buf->wp - buf->rp), compress_empty_buffer->wp, &compressed_len, &lzo_work_mem);
+  if (err) {
+    printk(KERN_ERR "eventlogging: error compressing buffer: %d", err);
+    goto out;
+  }
+  compress_empty_buffer->wp += compressed_len;
+  memcpy(compress_empty_buffer->start, &compressed_len, 4);
+
+  sbuffer_swap(compress_empty_buffer, buf);
+  err = 0;
+
+ out:
+  mutex_unlock(&compress_lock);
+  return err;
+}
+
+static void compress_buffer_func(struct work_struct* work) {
+  int ret;
+  struct sbuffer* buf;
+  
+  buf = container_of(work, struct sbuffer, work);
+  ret = compress_buffer(buf);  
+  if (ret)
+    goto err;
+
+  queue_put(&compressed_buffers, buf);
+  queue_poke(&compressed_buffers);
+  return;
+
+ err:
+  printk("eventlogging: failed to compress buffer: %d", ret);
+}
+
+static void schedule_compression(void) {
+  struct sbuffer* buf;
+  while( (buf = queue_take_try(&full_buffers)) ) {
+    INIT_WORK(&buf->work, compress_buffer_func);
+    schedule_work(&buf->work);
+  }
+}
+
 /* =========================== Proc FS Methods ============================== */
 
 static int event_logging_read_pfs(char* page, char** start, off_t off, int count, int* eof, void* data) {
@@ -197,7 +273,7 @@ static int event_logging_read_pfs(char* page, char** start, off_t off, int count
 
     /* Get a new buffer from the full queue */
     if (NULL == pfs_read_buffer) {
-      pfs_read_buffer = queue_take_interruptible(&full_buffers);
+      pfs_read_buffer = queue_take_interruptible(&compressed_buffers);
       if (IS_ERR(pfs_read_buffer)) {
 	err = PTR_ERR(pfs_read_buffer);
 	pfs_read_buffer = NULL;
-- 
1.9.1


From bf1a6c11a4c658596d08d27f3817bb30eef16995 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Wed, 10 Oct 2012 03:44:49 -0400
Subject: [PATCH 59/72] eventlogging: add select for LZO compression to Kconfig

---
 kernel/eventlogging/Kconfig | 1 +
 1 file changed, 1 insertion(+)

diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index 2310c48..17c9607 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -5,6 +5,7 @@
 
 menuconfig EVENT_LOGGING
         bool "Event Logging Zhang/Bild"
+	select LZO_COMPRESS
         help
           Event tracing framework for Lide Zhang and David Bild.
 
-- 
1.9.1


From 0c4dd6c36dda43de9a7e9756e2756b06f6f216d6 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Wed, 10 Oct 2012 03:22:39 -0400
Subject: [PATCH 60/72] eventlogging: add defconfig for omap tuna (galaxy
 nexus)

---
 arch/arm/configs/tuna_eventlogging_defconfig | 477 +++++++++++++++++++++++++++
 1 file changed, 477 insertions(+)
 create mode 100644 arch/arm/configs/tuna_eventlogging_defconfig

diff --git a/arch/arm/configs/tuna_eventlogging_defconfig b/arch/arm/configs/tuna_eventlogging_defconfig
new file mode 100644
index 0000000..738581b
--- /dev/null
+++ b/arch/arm/configs/tuna_eventlogging_defconfig
@@ -0,0 +1,477 @@
+CONFIG_EXPERIMENTAL=y
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_PANIC_TIMEOUT=5
+CONFIG_KALLSYMS_ALL=y
+CONFIG_ASHMEM=y
+# CONFIG_AIO is not set
+CONFIG_EMBEDDED=y
+CONFIG_PERF_COUNTERS=y
+CONFIG_PROFILING=y
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_ARCH_OMAP=y
+CONFIG_OMAP_SMARTREFLEX=y
+CONFIG_OMAP_SMARTREFLEX_CLASS3=y
+CONFIG_OMAP_SMARTREFLEX_CLASS1P5=y
+CONFIG_OMAP_RESET_CLOCKS=y
+CONFIG_OMAP_DM_TIMER_DEBUG=y
+CONFIG_OMAP_TEMP_SENSOR=y
+CONFIG_OMAP_REMOTEPROC_MEMPOOL_SIZE=0x0
+# CONFIG_ARCH_OMAP2 is not set
+# CONFIG_ARCH_OMAP3 is not set
+# CONFIG_MACH_OMAP_4430SDP is not set
+CONFIG_OMAP_ALLOW_OSWR=y
+CONFIG_ARM_THUMBEE=y
+CONFIG_PL310_ERRATA_727915=y
+CONFIG_FIQ_DEBUGGER_CONSOLE=y
+CONFIG_ARM_ERRATA_764369=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_SMP=y
+CONFIG_NR_CPUS=2
+CONFIG_PREEMPT=y
+CONFIG_HIGHMEM=y
+CONFIG_COMPACTION=y
+CONFIG_ARM_FLUSH_CONSOLE_ON_RESTART=y
+CONFIG_CMDLINE="console=ttyFIQ0 androidboot.console=ttyFIQ0 mem=1G vmalloc=768M omap_wdt.timer_margin=30 no_console_suspend"
+CONFIG_CMDLINE_EXTEND=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_HOTPLUG=y
+CONFIG_CPU_IDLE=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_MISC=y
+CONFIG_WAKELOCK=y
+CONFIG_PM_DEBUG=y
+CONFIG_SUSPEND_TIME=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_INET_ESP=y
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_NETFILTER=y
+# CONFIG_BRIDGE_NETFILTER is not set
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_TARGET_LOG=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_BRIDGE=y
+# CONFIG_BRIDGE_IGMP_SNOOPING is not set
+CONFIG_PHONET=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_SCH_INGRESS=y
+CONFIG_NET_CLS_U32=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+CONFIG_NET_ACT_MIRRED=y
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_CFG80211=y
+CONFIG_NL80211_TESTMODE=y
+# CONFIG_CFG80211_WEXT is not set
+CONFIG_CFG80211_ALLOW_RECONNECT=y
+CONFIG_RFKILL=y
+CONFIG_RFKILL_INPUT=y
+CONFIG_MTD=y
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_NAND_IDS=y
+CONFIG_MTD_ONENAND=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_MISC_DEVICES=y
+CONFIG_SAMSUNG_JACK=y
+CONFIG_UID_STAT=y
+CONFIG_BMP180=y
+CONFIG_USB_SWITCH_FSA9480=y
+CONFIG_OMAP_DIE_TEMP_SENSOR=y
+CONFIG_LEDS_AN30259A=y
+CONFIG_MPU_SENSORS_TIMERIRQ=y
+CONFIG_INV_SENSORS=y
+CONFIG_MPU_SENSORS_MPU3050=y
+CONFIG_MPU_SENSORS_BMA250=y
+CONFIG_MPU_SENSORS_YAS530=y
+CONFIG_SEC_MODEM=y
+CONFIG_UMTS_LINK_MIPI=y
+CONFIG_UMTS_MODEM_XMM6260=y
+CONFIG_CDMA_LINK_DPRAM=y
+CONFIG_CDMA_MODEM_CBP71=y
+CONFIG_LTE_LINK_USB=y
+CONFIG_LTE_MODEM_CMC221=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_DEBUG=y
+CONFIG_DM_CRYPT=y
+CONFIG_DM_UEVENT=y
+CONFIG_NETDEVICES=y
+CONFIG_IFB=y
+CONFIG_TUN=y
+CONFIG_WIFI_CONTROL_FUNC=y
+CONFIG_BCMDHD=y
+CONFIG_BCMDHD_FW_PATH="/system/vendor/firmware/fw_bcmdhd.bin"
+CONFIG_DHD_ENABLE_P2P=y
+CONFIG_USB_USBNET=y
+CONFIG_PPP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+# CONFIG_INPUT_MOUSEDEV is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_KEYRESET=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_OMAP4=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_INPUT_TABLET=y
+CONFIG_TABLET_USB_ACECAD=y
+CONFIG_TABLET_USB_AIPTEK=y
+CONFIG_TABLET_USB_GTCO=y
+CONFIG_TABLET_USB_HANWANG=y
+CONFIG_TABLET_USB_KBTAB=y
+CONFIG_TABLET_USB_WACOM=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ATMEL_MXT=y
+CONFIG_TOUCHSCREEN_MMS=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_KEYCHORD=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=y
+CONFIG_OPTICAL_GP2A=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_VT is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_HW_RANDOM=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_GPIO=y
+CONFIG_SPI=y
+CONFIG_SPI_OMAP24XX=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_TWL4030=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_PDA_POWER=y
+CONFIG_BATTERY_MAX17040=y
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_OMAP_WATCHDOG=y
+CONFIG_TWL6030_POWER=y
+CONFIG_TWL6030_PWM=y
+CONFIG_TWL6030_MADC=y
+CONFIG_REGULATOR_TWL4030=y
+CONFIG_MEDIA_SUPPORT=y
+# CONFIG_RC_CORE is not set
+CONFIG_PVR_SGX=y
+CONFIG_PVR_NEED_PVR_DPF=y
+CONFIG_PVR_NEED_PVR_ASSERT=y
+CONFIG_PVR_USSE_EDM_STATUS_DEBUG=y
+CONFIG_SGX_DVFS_MODE_OPTIMIZED=y
+CONFIG_PVR_LINUX_MEM_AREA_POOL=y
+CONFIG_ION=y
+CONFIG_ION_OMAP=y
+CONFIG_FB=y
+CONFIG_SII9234=y
+CONFIG_FB_OMAP_BOOTLOADER_INIT=y
+CONFIG_OMAP2_DSS=y
+CONFIG_OMAP2_VRAM_SIZE=16
+# CONFIG_OMAP2_DSS_DPI is not set
+# CONFIG_OMAP2_DSS_VENC is not set
+CONFIG_OMAP2_DSS_DSI=y
+CONFIG_FB_OMAP2=y
+CONFIG_PANEL_S6E8AA0=y
+CONFIG_OMAP4_HDCP=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_DISPLAY_SUPPORT=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_SOC=y
+CONFIG_SND_OMAP_SOC=y
+CONFIG_SND_OMAP_SOC_SDP4430=y
+CONFIG_SND_OMAP_SOC_OMAP4_HDMI=y
+CONFIG_HID_A4TECH=y
+CONFIG_HID_ACRUX=y
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EMS_FF=y
+CONFIG_HID_ELECOM=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KEYTOUCH=y
+CONFIG_HID_KYE=y
+CONFIG_HID_UCLOGIC=y
+CONFIG_HID_WALTOP=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LCPOWER=y
+CONFIG_HID_LOGITECH=y
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+CONFIG_LOGIG940_FF=y
+CONFIG_LOGIWII_FF=y
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_PICOLCD=y
+CONFIG_HID_QUANTA=y
+CONFIG_HID_ROCCAT_ARVO=y
+CONFIG_HID_ROCCAT_KONE=y
+CONFIG_HID_ROCCAT_KONEPLUS=y
+CONFIG_HID_ROCCAT_KOVAPLUS=y
+CONFIG_HID_ROCCAT_PYRA=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_WACOM=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_ZEROPLUS_FF=y
+CONFIG_HID_ZYDACRON=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG_WHITELIST is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_USB_MUSB_OMAP2PLUS=y
+CONFIG_USB_MUSB_OTG=y
+CONFIG_USB_GADGET_MUSB_HDRC=y
+CONFIG_USB_ACM=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_VBUS_DRAW=500
+CONFIG_USB_G_ANDROID=y
+CONFIG_USB_OTG_WAKELOCK=y
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_EMBEDDED_SDIO=y
+CONFIG_MMC_PARANOID_SD_INIT=y
+CONFIG_MMC_OMAP=y
+CONFIG_MMC_OMAP_HS=y
+CONFIG_SWITCH=y
+CONFIG_SWITCH_GPIO=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_TWL4030=y
+CONFIG_STAGING=y
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_OMAP_HSI=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT4_FS=y
+# CONFIG_EXT4_FS_XATTR is not set
+# CONFIG_DNOTIFY is not set
+CONFIG_FUSE_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+# CONFIG_NETWORK_FILESYSTEMS is not set
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_EFI_PARTITION=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=10
+# CONFIG_DEBUG_PREEMPT is not set
+CONFIG_DEBUG_SPINLOCK_SLEEP=y
+CONFIG_DEBUG_INFO=y
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_SCHED_TRACER=y
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+CONFIG_SECURITY_MIDDLEWARE_COMPONENT=y
+# CONFIG_SMC_KERNEL_CRYPTO is not set
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRYPTO_DEV_TEGRA_SE=y
+CONFIG_EVENT_LOGGING=y
+CONFIG_EVENT_CPU_ONLINE=y
+CONFIG_EVENT_CPU_DOWN_PREPARE=y
+CONFIG_EVENT_CPU_DEAD=y
+CONFIG_EVENT_WAKE_LOCK=y
+CONFIG_EVENT_WAKE_UNLOCK=y
+CONFIG_EVENT_CONTEXT_SWITCH=y
+CONFIG_EVENT_PREEMPT_TICK=y
+CONFIG_EVENT_PREEMPT_WAKEUP=y
+CONFIG_EVENT_YIELD=y
+CONFIG_EVENT_WAITQUEUE_WAIT=y
+CONFIG_EVENT_WAITQUEUE_WAKE=y
+CONFIG_EVENT_WAITQUEUE_NOTIFY=y
+CONFIG_EVENT_IDLE_START=n
+CONFIG_EVENT_IDLE_END=n
+CONFIG_EVENT_SUSPEND_START=y
+CONFIG_EVENT_SUSPEND=y
+CONFIG_EVENT_RESUME=y
+CONFIG_EVENT_RESUME_FINISH=y
+CONFIG_EVENT_FORK=y
+CONFIG_EVENT_EXIT=y
+CONFIG_EVENT_IO_BLOCK=y
+CONFIG_EVENT_IO_RESUME=y
+CONFIG_EVENT_DATAGRAM_BLOCK=y
+CONFIG_EVENT_DATAGRAM_RESUME=y
+CONFIG_EVENT_STREAM_BLOCK=y
+CONFIG_EVENT_STREAM_RESUME=y
+CONFIG_EVENT_SOCK_BLOCK=y
+CONFIG_EVENT_SOCK_RESUME=y
+CONFIG_EVENT_SEMAPHORE_LOCK=n
+CONFIG_EVENT_SEMAPHORE_WAIT=y
+CONFIG_EVENT_SEMAPHORE_WAKE=y
+CONFIG_EVENT_SEMAPHORE_NOTIFY=y
+CONFIG_EVENT_MUTEX_LOCK=n
+CONFIG_EVENT_MUTEX_WAIT=y
+CONFIG_EVENT_MUTEX_WAKE=y
+CONFIG_EVENT_MUTEX_NOTIFY=y
+CONFIG_EVENT_FUTEX_WAIT=y
+CONFIG_EVENT_FUTEX_WAKE=y
+CONFIG_EVENT_FUTEX_NOTIFY=y
+CONFIG_EVENT_THREAD_NAME=y
-- 
1.9.1


From 60488e8d60fe41de201cabf75d382677f5fc97fb Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Thu, 11 Oct 2012 19:47:14 -0400
Subject: [PATCH 61/72] kconfig: ignore zconf.lex.c

---
 scripts/kconfig/.gitignore | 1 +
 1 file changed, 1 insertion(+)

diff --git a/scripts/kconfig/.gitignore b/scripts/kconfig/.gitignore
index 624f650..7d83afb 100644
--- a/scripts/kconfig/.gitignore
+++ b/scripts/kconfig/.gitignore
@@ -6,6 +6,7 @@ lex.*.c
 *.tab.c
 *.tab.h
 zconf.hash.c
+zconf.lex.c
 *.moc
 lkc_defs.h
 gconf.glade.h
-- 
1.9.1


From 523de04801f61b87e1913eebf8b22403ca970a07 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Tue, 16 Oct 2012 17:12:47 -0400
Subject: [PATCH 62/72] eventlogging: set number of buffers for gnexus

---
 kernel/eventlogging/logging.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index 0072da1..ada19ae 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -15,7 +15,7 @@
 #include "queue.h"
 
 #define BUFFER_ORDER 10  // 2^10 = 4 MB with 4096 page size
-#define NUM_BUFFERS  32  // 32 * 4 MB = 128 MB total
+#define NUM_BUFFERS   8  // 8 * 4 MB = 32 MB total
 
 static DEFINE_PER_CPU(struct sbuffer*, cpu_buffers);
 static DEFINE_PER_CPU(unsigned int, missed_events);
-- 
1.9.1


From 4022bbdb2c19f0d4023a0239e2a6f905ab62b1f4 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Tue, 16 Oct 2012 17:38:34 -0400
Subject: [PATCH 63/72] eventlogging: learn to log cpufreq changes

---
 include/eventlogging/events.h | 17 +++++++++++++++++
 kernel/eventlogging/Kconfig   |  4 ++++
 kernel/eventlogging/Makefile  |  2 +-
 kernel/eventlogging/cpufreq.c | 29 +++++++++++++++++++++++++++++
 kernel/eventlogging/cpufreq.h |  6 ++++++
 kernel/eventlogging/logging.c |  2 ++
 6 files changed, 59 insertions(+), 1 deletion(-)
 create mode 100644 kernel/eventlogging/cpufreq.c
 create mode 100644 kernel/eventlogging/cpufreq.h

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index e8abdd2..d63d2c1 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -11,6 +11,7 @@
 #define EVENT_CPU_ONLINE 5
 #define EVENT_CPU_DOWN_PREPARE 6
 #define EVENT_CPU_DEAD 7
+#define EVENT_CPUFREQ_SET 8
 
 #define EVENT_PREEMPT_WAKEUP 9
 #define EVENT_CONTEXT_SWITCH 10
@@ -123,6 +124,12 @@ struct hotcpu_event {
   __u8 cpu;
 }__attribute__((packed));
 
+struct cpufreq_set_event {
+  __u8 cpu;
+  __le32 old_freq;
+  __le32 new_freq;
+}__attribute__((packed));
+
 struct wake_lock_event {
   __le32 lock;
   __le32 timeout;
@@ -338,6 +345,16 @@ static inline void event_log_cpu_dead(unsigned int cpu) {
 #endif
 }
 
+static inline void event_log_cpufreq_set(unsigned int cpu, unsigned int old_freq, unsigned int new_freq) {
+#ifdef CONFIG_EVENT_CPUFREQ_SET
+  init_event(struct cpufreq_set_event, EVENT_CPUFREQ_SET, event);
+  event->cpu = cpu;
+  event->old_freq = old_freq;
+  event->new_freq = new_freq;
+  finish_event();
+#endif
+}
+
 static inline void event_log_idle_start(void) {
 #ifdef CONFIG_EVENT_IDLE_START
   event_log_simple(EVENT_IDLE_START);
diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index 17c9607..c65e231 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -23,6 +23,10 @@ config EVENT_CPU_DEAD
        bool "Log when cpu goes offline"
        default yes
 
+config EVENT_CPUFREQ_SET
+       bool "Log when cpu frequency changes"
+       default yes
+
 config EVENT_SUSPEND_START
        bool "Log when a suspend request is issued"
        default yes
diff --git a/kernel/eventlogging/Makefile b/kernel/eventlogging/Makefile
index 2bdf9b1..e023784 100644
--- a/kernel/eventlogging/Makefile
+++ b/kernel/eventlogging/Makefile
@@ -1 +1 @@
-obj-$(CONFIG_EVENT_LOGGING) := logging.o buffer.o idle.o hotcpu.o events.o
+obj-$(CONFIG_EVENT_LOGGING) := logging.o buffer.o idle.o hotcpu.o cpufreq.o events.o
diff --git a/kernel/eventlogging/cpufreq.c b/kernel/eventlogging/cpufreq.c
new file mode 100644
index 0000000..92303ca
--- /dev/null
+++ b/kernel/eventlogging/cpufreq.c
@@ -0,0 +1,29 @@
+#include <linux/cpufreq.h>
+#include <linux/notifier.h>
+
+#include <eventlogging/events.h>
+
+#ifdef CONFIG_EVENT_CPUFREQ_SET
+static struct notifier_block cpufreq_notifier;
+
+static int cpufreq_notifier_call(struct notifier_block* self, unsigned long event, void* data) {
+  struct cpufreq_freqs* freqs;
+  switch (event) {
+  case CPUFREQ_POSTCHANGE:
+    freqs = (struct cpufreq_freqs*) data;
+    event_log_cpufreq_set(freqs->cpu, freqs->old, freqs->new);
+    break;
+  default:
+    break;
+  }
+  return 0;
+}
+
+__init int init_cpufreq_notifier(void) {
+  cpufreq_notifier.notifier_call = cpufreq_notifier_call;
+  cpufreq_register_notifier(&cpufreq_notifier, CPUFREQ_TRANSITION_NOTIFIER);
+  return 0;
+}
+#else
+__init int init_cpufreq_notifier(void) {return 0;}
+#endif
diff --git a/kernel/eventlogging/cpufreq.h b/kernel/eventlogging/cpufreq.h
new file mode 100644
index 0000000..916dbd6
--- /dev/null
+++ b/kernel/eventlogging/cpufreq.h
@@ -0,0 +1,6 @@
+#ifndef EVENT_LOGGING_CPUFREQ_H
+#define EVENT_LOGGING_CPUFREQ_H
+
+__init int init_cpufreq_notifier(void);
+
+#endif
diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index ada19ae..1fefd2b 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -12,6 +12,7 @@
 #include "buffer.h"
 #include "idle.h"
 #include "hotcpu.h"
+#include "cpufreq.h"
 #include "queue.h"
 
 #define BUFFER_ORDER 10  // 2^10 = 4 MB with 4096 page size
@@ -319,6 +320,7 @@ static __init int event_logging_create_pfs(void) {
 early_initcall(init_alloc_buffers);
 early_initcall(init_idle_notifier);
 early_initcall(init_hotcpu_notifier);
+fs_initcall(init_cpufreq_notifier);
 fs_initcall(event_logging_create_pfs);
 
 
-- 
1.9.1


From affc3683445016e78a26064197e44de7df84becb Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Tue, 16 Oct 2012 17:39:13 -0400
Subject: [PATCH 64/72] eventlogging: add cpufreq_set event to tuna defconfig

---
 arch/arm/configs/tuna_eventlogging_defconfig | 1 +
 1 file changed, 1 insertion(+)

diff --git a/arch/arm/configs/tuna_eventlogging_defconfig b/arch/arm/configs/tuna_eventlogging_defconfig
index 738581b..5bc7af5 100644
--- a/arch/arm/configs/tuna_eventlogging_defconfig
+++ b/arch/arm/configs/tuna_eventlogging_defconfig
@@ -438,6 +438,7 @@ CONFIG_EVENT_LOGGING=y
 CONFIG_EVENT_CPU_ONLINE=y
 CONFIG_EVENT_CPU_DOWN_PREPARE=y
 CONFIG_EVENT_CPU_DEAD=y
+CONFIG_EVENT_CPUFREQ_SET=y
 CONFIG_EVENT_WAKE_LOCK=y
 CONFIG_EVENT_WAKE_UNLOCK=y
 CONFIG_EVENT_CONTEXT_SWITCH=y
-- 
1.9.1


From 8fbd85882e64943c1d025590537620212a62778e Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 22 Oct 2012 02:37:36 -0400
Subject: [PATCH 65/72] eventlogging: add read reset method to buffers

---
 kernel/eventlogging/buffer.c | 4 ++++
 kernel/eventlogging/buffer.h | 1 +
 2 files changed, 5 insertions(+)

diff --git a/kernel/eventlogging/buffer.c b/kernel/eventlogging/buffer.c
index 127e4d7..0053560 100644
--- a/kernel/eventlogging/buffer.c
+++ b/kernel/eventlogging/buffer.c
@@ -72,6 +72,10 @@ int sbuffer_read(struct sbuffer* buf, char* page, int count) {
   return len;
 }
 
+void sbuffer_restart_read(struct sbuffer* buf) {
+  buf->rp = buf->start;
+}
+
 /* Swaps the memory held by the two buffers */
 void sbuffer_swap(struct sbuffer* buf1, struct sbuffer* buf2) {
   int order;
diff --git a/kernel/eventlogging/buffer.h b/kernel/eventlogging/buffer.h
index 5165898..e9d1f68 100644
--- a/kernel/eventlogging/buffer.h
+++ b/kernel/eventlogging/buffer.h
@@ -24,6 +24,7 @@ void* sbuffer_reserve(struct sbuffer* buf, int len);
 void sbuffer_cancel(struct sbuffer* buf, int len);
 int sbuffer_empty(struct sbuffer* buf); // any data to read?
 int sbuffer_read(struct sbuffer* buf, char* page, int count);
+void sbuffer_restart_read(struct sbuffer* buf);
 
 /* Swaps the memory held by the two buffers */
 void sbuffer_swap(struct sbuffer* buf1, struct sbuffer* buf2); 
-- 
1.9.1


From 027aacb6f9c3fe17a01a851b3426da7cc8da2747 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Mon, 22 Oct 2012 02:37:56 -0400
Subject: [PATCH 66/72] eventlogging: learn procfs command to restart reading
 of current buffer

---
 kernel/eventlogging/logging.c | 51 ++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 50 insertions(+), 1 deletion(-)

diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index 1fefd2b..093df4e 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -5,6 +5,9 @@
 #include <linux/slab.h>
 #include <linux/proc_fs.h>
 #include <linux/lzo.h>
+#include <linux/string.h>
+
+#include <asm/uaccess.h>
 
 #include <eventlogging/events.h>
 
@@ -29,6 +32,8 @@ static DEFINE_QUEUE(full_buffers);
 static DEFINE_QUEUE(compressed_buffers);
 
 #define PFS_NAME "event_logging"
+#define PFS_COMMAND_LEN 10
+#define PFS_RESTART "restart"
 #define PFS_PERMS S_IFREG|S_IROTH|S_IRGRP|S_IRUSR|S_IWOTH|S_IWGRP|S_IWUSR
 static struct proc_dir_entry* el_pfs_entry;
 static DEFINE_MUTEX(pfs_read_lock);
@@ -252,6 +257,25 @@ static void schedule_compression(void) {
 }
 
 /* =========================== Proc FS Methods ============================== */
+static int event_logging_read_pfs_restart(void) {
+  int err;
+
+  err = mutex_lock_interruptible(&pfs_read_lock);
+  if (err)
+    goto mutex_err;
+
+  /* If read is incomplete, restart read of this buffer */
+  if (NULL != pfs_read_buffer && !sbuffer_empty(pfs_read_buffer)) {
+    printk(KERN_INFO "eventlogging: restarting read of buffer");
+    sbuffer_restart_read(pfs_read_buffer);
+  }
+
+  mutex_unlock(&pfs_read_lock);
+  return 0;
+
+ mutex_err:
+  return err;
+}
 
 static int event_logging_read_pfs(char* page, char** start, off_t off, int count, int* eof, void* data) {
   int err, len;
@@ -295,9 +319,34 @@ static int event_logging_read_pfs(char* page, char** start, off_t off, int count
 }
 
 static int event_logging_write_pfs(struct file* file, const char* buffer, unsigned long count, void *data) {
-  if (count > 0)
+  int err;
+  char command[PFS_COMMAND_LEN+1];
+
+  if (!count)
+    return 0;
+
+  memset(command, 0, sizeof(command));
+  if (count > PFS_COMMAND_LEN)
+    count = PFS_COMMAND_LEN;
+
+  if ( copy_from_user(command, buffer, count) )
+    return -EFAULT;
+
+  /* Process restart command */
+  if ( 0 == strcmp(command, PFS_RESTART) ) {
+    err = event_logging_read_pfs_restart();
+    if (err)
+      goto err;
+  }
+  /* Process default command */
+  else {
     flush_all_cpus();
+  }
+
   return count;
+
+ err:
+  return err;
 }
 
 static __init int event_logging_create_pfs(void) {
-- 
1.9.1


From 6465ea1fe663ad30601e66cb6effdd00153aaab6 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Sat, 27 Oct 2012 23:52:54 -0400
Subject: [PATCH 67/72] eventlogging: learn to log binder transaction events

---
 arch/arm/configs/tuna_eventlogging_defconfig |  4 +++
 drivers/staging/android/binder.c             |  7 +++++
 include/eventlogging/events.h                | 42 ++++++++++++++++++++++++++++
 kernel/eventlogging/Kconfig                  | 16 +++++++++++
 4 files changed, 69 insertions(+)

diff --git a/arch/arm/configs/tuna_eventlogging_defconfig b/arch/arm/configs/tuna_eventlogging_defconfig
index 5bc7af5..8ba03c8 100644
--- a/arch/arm/configs/tuna_eventlogging_defconfig
+++ b/arch/arm/configs/tuna_eventlogging_defconfig
@@ -439,6 +439,10 @@ CONFIG_EVENT_CPU_ONLINE=y
 CONFIG_EVENT_CPU_DOWN_PREPARE=y
 CONFIG_EVENT_CPU_DEAD=y
 CONFIG_EVENT_CPUFREQ_SET=y
+CONFIG_EVENT_BINDER_PRODUCE_ONEWAY=y
+CONFIG_EVENT_BINDER_PRODUCE_TWOWAY=y
+CONFIG_EVENT_BINDER_PRODUCE_REPLY=y
+CONFIG_EVENT_BINDER_CONSUME=y
 CONFIG_EVENT_WAKE_LOCK=y
 CONFIG_EVENT_WAKE_UNLOCK=y
 CONFIG_EVENT_CONTEXT_SWITCH=y
diff --git a/drivers/staging/android/binder.c b/drivers/staging/android/binder.c
index e13b4c4..ef114c6 100644
--- a/drivers/staging/android/binder.c
+++ b/drivers/staging/android/binder.c
@@ -34,6 +34,8 @@
 #include <linux/uaccess.h>
 #include <linux/vmalloc.h>
 
+#include <eventlogging/events.h>
+
 #include "binder.h"
 
 static DEFINE_MUTEX(binder_lock);
@@ -1718,11 +1720,13 @@ static void binder_transaction(struct binder_proc *proc,
 	if (reply) {
 		BUG_ON(t->buffer->async_transaction != 0);
 		binder_pop_transaction(target_thread, in_reply_to);
+		event_log_binder_produce_reply(t);
 	} else if (!(t->flags & TF_ONE_WAY)) {
 		BUG_ON(t->buffer->async_transaction != 0);
 		t->need_reply = 1;
 		t->from_parent = thread->transaction_stack;
 		thread->transaction_stack = t;
+		event_log_binder_produce_twoway(t);
 	} else {
 		BUG_ON(target_node == NULL);
 		BUG_ON(t->buffer->async_transaction != 1);
@@ -1731,6 +1735,7 @@ static void binder_transaction(struct binder_proc *proc,
 			target_wait = NULL;
 		} else
 			target_node->has_async_transaction = 1;
+		event_log_binder_produce_oneway(t);
 	}
 	t->work.type = BINDER_WORK_TRANSACTION;
 	list_add_tail(&t->work.entry, target_list);
@@ -1738,6 +1743,7 @@ static void binder_transaction(struct binder_proc *proc,
 	list_add_tail(&tcomplete->entry, &thread->todo);
 	if (target_wait)
 		wake_up_interruptible(target_wait);
+
 	return;
 
 err_get_unused_fd_failed:
@@ -2458,6 +2464,7 @@ retry:
 			     t->buffer->data_size, t->buffer->offsets_size,
 			     tr.data.ptr.buffer, tr.data.ptr.offsets);
 
+		event_log_binder_consume(t);
 		list_del(&t->work.entry);
 		t->buffer->allow_user_free = 1;
 		if (cmd == BR_TRANSACTION && !(t->flags & TF_ONE_WAY)) {
diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index d63d2c1..ed4ab63 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -63,6 +63,11 @@
 #define EVENT_RESUME 77
 #define EVENT_RESUME_FINISH 78
 
+#define EVENT_BINDER_PRODUCE_ONEWAY 90
+#define EVENT_BINDER_PRODUCE_TWOWAY 91
+#define EVENT_BINDER_PRODUCE_REPLY  92
+#define EVENT_BINDER_CONSUME        93
+
 #define MAX8 ((1 << 7) - 1)
 #define MIN8 (-(1 << 7))
 
@@ -158,6 +163,10 @@ struct general_notify_event {
   __le16 pid;
 }__attribute__((packed));
 
+struct binder_event {
+  __le32 transaction;
+}__attribute__((packed));
+
 struct simple_event {
 }__attribute__((packed));
 
@@ -345,6 +354,39 @@ static inline void event_log_cpu_dead(unsigned int cpu) {
 #endif
 }
 
+#if defined(CONFIG_EVENT_BINDER_PRODUCE_ONEWAY) || defined(CONFIG_EVENT_BINDER_PRODUCE_TWOWAY) \
+ || defined(CONFIG_EVENT_BINDER_PRODUCE_REPLY) || defined(CONFIG_EVENT_BINDER_CONSUME)
+static inline void event_log_binder(u8 event_type, void* transaction) {
+  init_event(struct binder_event, event_type, event);
+  event->transaction = (__le32) transaction;
+  finish_event();
+}
+#endif
+
+static inline void event_log_binder_produce_oneway(void* transaction) {
+  #ifdef CONFIG_EVENT_BINDER_PRODUCE_ONEWAY
+  event_log_binder(EVENT_BINDER_PRODUCE_ONEWAY, transaction);
+  #endif
+}
+
+static inline void event_log_binder_produce_twoway(void* transaction) {
+  #ifdef CONFIG_EVENT_BINDER_PRODUCE_TWOWAY
+  event_log_binder(EVENT_BINDER_PRODUCE_TWOWAY, transaction);
+  #endif
+}
+
+static inline void event_log_binder_produce_reply(void* transaction) {
+  #ifdef CONFIG_EVENT_BINDER_PRODUCE_REPLY
+  event_log_binder(EVENT_BINDER_PRODUCE_REPLY, transaction);
+  #endif
+}
+
+static inline void event_log_binder_consume(void* transaction) {
+  #ifdef CONFIG_EVENT_BINDER_CONSUME
+  event_log_binder(EVENT_BINDER_CONSUME, transaction);
+  #endif
+}
+
 static inline void event_log_cpufreq_set(unsigned int cpu, unsigned int old_freq, unsigned int new_freq) {
 #ifdef CONFIG_EVENT_CPUFREQ_SET
   init_event(struct cpufreq_set_event, EVENT_CPUFREQ_SET, event);
diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index c65e231..09b0cdd 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -27,6 +27,22 @@ config EVENT_CPUFREQ_SET
        bool "Log when cpu frequency changes"
        default yes
 
+config EVENT_BINDER_PRODUCE_ONEWAY
+       bool "Log when a one-way binder transaction is submitted"
+       default yes
+
+config EVENT_BINDER_PRODUCE_TWOWAY
+       bool "Log when a two-way binder transaction is submitted"
+       default yes
+
+config EVENT_BINDER_PRODUCE_REPLY
+       bool "Log when a reply transaction is submitted"
+       default yes
+
+config EVENT_BINDER_CONSUME
+       bool "Log when a  binder transaction is processed"
+       default yes
+
 config EVENT_SUSPEND_START
        bool "Log when a suspend request is issued"
        default yes
-- 
1.9.1


From 3f18c7bf49fb3b1f2a5b6e1512c303a0cf5337db Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Sat, 27 Oct 2012 23:54:25 -0400
Subject: [PATCH 68/72] eventlogging: log correct event type for cpu hotplug
 events

---
 include/eventlogging/events.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index ed4ab63..78d3540 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -330,7 +330,7 @@ static inline void event_log_yield(void) {
 
 #if defined(CONFIG_EVENT_CPU_ONLINE) || defined(CONFIG_EVENT_CPU_DEAD) || defined(CONFIG_EVENT_CPU_DOWN_PREPARE)
 static inline void event_log_hotcpu(unsigned int cpu, u8 event_type) {
-  init_event(struct hotcpu_event, EVENT_CPU_ONLINE, event);
+  init_event(struct hotcpu_event, event_type, event);
   event->cpu = cpu;
   finish_event();
 }
-- 
1.9.1


From 31488bd10f446b56de0b28771a92b0c5193089c3 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Sat, 27 Oct 2012 23:56:56 -0400
Subject: [PATCH 69/72] eventlogging: change event_log_hotcpu argument order so
 event type is first

Event type is the most generic paramter (it is effectively subtyping
the function), so it should be first.  All other general event_log_*
methods also follow this order.
---
 include/eventlogging/events.h | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 78d3540..20327a6 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -329,7 +329,7 @@ static inline void event_log_yield(void) {
 }
 
 #if defined(CONFIG_EVENT_CPU_ONLINE) || defined(CONFIG_EVENT_CPU_DEAD) || defined(CONFIG_EVENT_CPU_DOWN_PREPARE)
-static inline void event_log_hotcpu(unsigned int cpu, u8 event_type) {
+static inline void event_log_hotcpu(u8 event_type, unsigned int cpu) {
   init_event(struct hotcpu_event, event_type, event);
   event->cpu = cpu;
   finish_event();
@@ -338,19 +338,19 @@ static inline void event_log_hotcpu(unsigned int cpu, u8 event_type) {
 
 static inline void event_log_cpu_online(unsigned int cpu) {
 #ifdef CONFIG_EVENT_CPU_ONLINE
-  event_log_hotcpu(cpu, EVENT_CPU_ONLINE);
+  event_log_hotcpu(EVENT_CPU_ONLINE, cpu);
 #endif
 }
 
 static inline void event_log_cpu_down_prepare(unsigned int cpu) {
 #ifdef CONFIG_EVENT_CPU_DOWN_PREPARE
-  event_log_hotcpu(cpu, EVENT_CPU_DOWN_PREPARE);
+  event_log_hotcpu(EVENT_CPU_DOWN_PREPARE, cpu);
 #endif
 }
 
 static inline void event_log_cpu_dead(unsigned int cpu) {
 #ifdef CONFIG_EVENT_CPU_DEAD
-  event_log_hotcpu(cpu, EVENT_CPU_DEAD);
+  event_log_hotcpu(EVENT_CPU_DEAD, cpu);
 #endif
 }
 
-- 
1.9.1


From 3a7dce9861dfc9f7c987750b47db2689cddb4ed5 Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Tue, 4 Dec 2012 21:04:46 -0500
Subject: [PATCH 70/72] eventlogging: learn to log cpufreq_interactive events

---
 arch/arm/configs/tuna_eventlogging_defconfig |  7 ++++
 drivers/cpufreq/cpufreq_interactive.c        | 16 ++++++++-
 include/eventlogging/events.h                | 52 ++++++++++++++++++++++++++++
 kernel/eventlogging/Kconfig                  | 20 +++++++++++
 4 files changed, 94 insertions(+), 1 deletion(-)

diff --git a/arch/arm/configs/tuna_eventlogging_defconfig b/arch/arm/configs/tuna_eventlogging_defconfig
index 8ba03c8..dbc9c70 100644
--- a/arch/arm/configs/tuna_eventlogging_defconfig
+++ b/arch/arm/configs/tuna_eventlogging_defconfig
@@ -480,3 +480,10 @@ CONFIG_EVENT_FUTEX_WAIT=y
 CONFIG_EVENT_FUTEX_WAKE=y
 CONFIG_EVENT_FUTEX_NOTIFY=y
 CONFIG_EVENT_THREAD_NAME=y
+CONFIG_EVENT_CPUFREQ_BOOST=y
+CONFIG_EVENT_CPUFREQ_WAKE_UP=y
+CONFIG_EVENT_CPUFREQ_MOD_TIMER=y
+CONFIG_EVENT_CPUFREQ_DEL_TIMER=y
+CONFIG_EVENT_CPUFREQ_TIMER=y
+
+
diff --git a/drivers/cpufreq/cpufreq_interactive.c b/drivers/cpufreq/cpufreq_interactive.c
index 7dbacf0..bd4f50c 100644
--- a/drivers/cpufreq/cpufreq_interactive.c
+++ b/drivers/cpufreq/cpufreq_interactive.c
@@ -34,6 +34,8 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/cpufreq_interactive.h>
 
+#include <eventlogging/events.h>
+
 static atomic_t active_count = ATOMIC_INIT(0);
 
 struct cpufreq_interactive_cpuinfo {
@@ -144,6 +146,8 @@ static void cpufreq_interactive_timer(unsigned long data)
 	if (!pcpu->governor_enabled)
 		goto exit;
 
+	event_log_cpufreq_timer(data);
+
 	/*
 	 * Once pcpu->timer_run_time is updated to >= pcpu->idle_exit_time,
 	 * this lets idle exit know the current idle time sample has
@@ -272,6 +276,7 @@ static void cpufreq_interactive_timer(unsigned long data)
 		spin_lock_irqsave(&up_cpumask_lock, flags);
 		cpumask_set_cpu(data, &up_cpumask);
 		spin_unlock_irqrestore(&up_cpumask_lock, flags);
+		event_log_cpufreq_wake_up();
 		wake_up_process(up_task);
 	}
 
@@ -301,6 +306,7 @@ rearm:
 
 		pcpu->time_in_idle = get_cpu_idle_time_us(
 			data, &pcpu->idle_exit_time);
+		event_log_cpufreq_mod_timer(pcpu->cpu_timer.data, timer_rate);
 		mod_timer(&pcpu->cpu_timer,
 			  jiffies + usecs_to_jiffies(timer_rate));
 	}
@@ -336,6 +342,7 @@ static void cpufreq_interactive_idle_start(void)
 			pcpu->time_in_idle = get_cpu_idle_time_us(
 				smp_processor_id(), &pcpu->idle_exit_time);
 			pcpu->timer_idlecancel = 0;
+			event_log_cpufreq_mod_timer(pcpu->cpu_timer.data, timer_rate);
 			mod_timer(&pcpu->cpu_timer,
 				  jiffies + usecs_to_jiffies(timer_rate));
 		}
@@ -348,6 +355,7 @@ static void cpufreq_interactive_idle_start(void)
 		 * CPU didn't go busy; we'll recheck things upon idle exit.
 		 */
 		if (pending && pcpu->timer_idlecancel) {
+			event_log_cpufreq_del_timer(pcpu->cpu_timer.data);
 			del_timer(&pcpu->cpu_timer);
 			/*
 			 * Ensure last timer run time is after current idle
@@ -387,6 +395,7 @@ static void cpufreq_interactive_idle_end(void)
 			get_cpu_idle_time_us(smp_processor_id(),
 					     &pcpu->idle_exit_time);
 		pcpu->timer_idlecancel = 0;
+		event_log_cpufreq_mod_timer(pcpu->cpu_timer.data, timer_rate);
 		mod_timer(&pcpu->cpu_timer,
 			  jiffies + usecs_to_jiffies(timer_rate));
 	}
@@ -501,6 +510,8 @@ static void cpufreq_interactive_boost(void)
 	unsigned long flags;
 	struct cpufreq_interactive_cpuinfo *pcpu;
 
+	event_log_cpufreq_boost();
+
 	spin_lock_irqsave(&up_cpumask_lock, flags);
 
 	for_each_online_cpu(i) {
@@ -526,8 +537,10 @@ static void cpufreq_interactive_boost(void)
 
 	spin_unlock_irqrestore(&up_cpumask_lock, flags);
 
-	if (anyboost)
+	if (anyboost) {
+		event_log_cpufreq_wake_up();
 		wake_up_process(up_task);
+	}
 }
 
 /*
@@ -878,6 +891,7 @@ static int cpufreq_governor_interactive(struct cpufreq_policy *policy,
 			pcpu = &per_cpu(cpuinfo, j);
 			pcpu->governor_enabled = 0;
 			smp_wmb();
+			event_log_cpufreq_del_timer(pcpu->cpu_timer.data);
 			del_timer_sync(&pcpu->cpu_timer);
 
 			/*
diff --git a/include/eventlogging/events.h b/include/eventlogging/events.h
index 20327a6..81bb546 100644
--- a/include/eventlogging/events.h
+++ b/include/eventlogging/events.h
@@ -68,6 +68,12 @@
 #define EVENT_BINDER_PRODUCE_REPLY  92
 #define EVENT_BINDER_CONSUME        93
 
+#define EVENT_CPUFREQ_BOOST 100
+#define EVENT_CPUFREQ_WAKE_UP 101
+#define EVENT_CPUFREQ_MOD_TIMER 102
+#define EVENT_CPUFREQ_DEL_TIMER 103
+#define EVENT_CPUFREQ_TIMER 104
+
 #define MAX8 ((1 << 7) - 1)
 #define MIN8 (-(1 << 7))
 
@@ -167,6 +173,15 @@ struct binder_event {
   __le32 transaction;
 }__attribute__((packed));
 
+struct cpufreq_mod_timer_event {
+  __u8 cpu;
+  __u32 microseconds;
+}__attribute__((packed));
+
+struct cpufreq_timer_event {
+  __u8 cpu;
+}__attribute__((packed));
+
 struct simple_event {
 }__attribute__((packed));
 
@@ -598,5 +613,42 @@ static inline void event_log_sem_notify(void* lock, pid_t pid) {
 #endif
 }
 
+static inline void event_log_cpufreq_boost(void) {
+#ifdef CONFIG_EVENT_CPUFREQ_BOOST
+  event_log_simple(EVENT_CPUFREQ_BOOST);
+#endif
+}
+
+static inline void event_log_cpufreq_wake_up(void) {
+#ifdef CONFIG_EVENT_CPUFREQ_WAKE_UP
+  event_log_simple(EVENT_CPUFREQ_WAKE_UP);
+#endif
+}
+
+static inline void event_log_cpufreq_mod_timer(unsigned int cpu, unsigned int microseconds) {
+#ifdef CONFIG_EVENT_CPUFREQ_MOD_TIMER
+  init_event(struct cpufreq_mod_timer_event, EVENT_CPUFREQ_MOD_TIMER, event);
+  event->cpu = cpu;
+  event->microseconds = microseconds;
+  finish_event(); 
+#endif
+}
+
+static inline void event_log_cpufreq_del_timer(unsigned int cpu) {
+#ifdef CONFIG_EVENT_CPUFREQ_DEL_TIMER
+  init_event(struct cpufreq_timer_event, EVENT_CPUFREQ_DEL_TIMER, event);
+  event->cpu = cpu;
+  finish_event(); 
+#endif
+}
+
+static inline void event_log_cpufreq_timer(unsigned int cpu) {
+#ifdef CONFIG_EVENT_CPUFREQ_TIMER
+  init_event(struct cpufreq_timer_event, EVENT_CPUFREQ_TIMER, event);
+  event->cpu = cpu;
+  finish_event(); 
+#endif
+}
+
 #endif // __KERNEL__
 #endif // EVENTLOGGING_EVENTS_H
diff --git a/kernel/eventlogging/Kconfig b/kernel/eventlogging/Kconfig
index 09b0cdd..0150186 100644
--- a/kernel/eventlogging/Kconfig
+++ b/kernel/eventlogging/Kconfig
@@ -191,5 +191,25 @@ config EVENT_THREAD_NAME
        bool "Log when a process name is changed"
        default yes
 
+config EVENT_CPUFREQ_BOOST
+       bool "Log when boost is called, presumably after a input event"
+       default yes
+
+config EVENT_CPUFREQ_WAKE_UP
+       bool "Log when thread kinteractiveup is woken up"
+       default yes
+
+config EVENT_CPUFREQ_MOD_TIMER
+       bool "Log when governor time is set"
+       default yes
+
+config EVENT_CPUFREQ_DEL_TIMER
+	bool "Log when governor timer is deleted"
+	default yes
+
+config EVENT_CPUFREQ_TIMER
+       bool "Log when governor timer callback is executed"
+       default yes
+
 endif
 
-- 
1.9.1


From 1215025881e287c835614b12ab408507eef2a05f Mon Sep 17 00:00:00 2001
From: "David R. Bild" <drbild@umich.edu>
Date: Thu, 6 Dec 2012 00:34:47 -0500
Subject: [PATCH 71/72] eventlogging: learn clear command to recycle unread
 buffers

---
 kernel/eventlogging/logging.c | 58 +++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 58 insertions(+)

diff --git a/kernel/eventlogging/logging.c b/kernel/eventlogging/logging.c
index 093df4e..40d2e4f 100644
--- a/kernel/eventlogging/logging.c
+++ b/kernel/eventlogging/logging.c
@@ -34,6 +34,7 @@ static DEFINE_QUEUE(compressed_buffers);
 #define PFS_NAME "event_logging"
 #define PFS_COMMAND_LEN 10
 #define PFS_RESTART "restart"
+#define PFS_CLEAR "clear"
 #define PFS_PERMS S_IFREG|S_IROTH|S_IRGRP|S_IRUSR|S_IWOTH|S_IWGRP|S_IWUSR
 static struct proc_dir_entry* el_pfs_entry;
 static DEFINE_MUTEX(pfs_read_lock);
@@ -277,6 +278,57 @@ static int event_logging_read_pfs_restart(void) {
   return err;
 }
 
+/**
+ * Flush the current buffers and then remove all pending,
+ * unread compressed buffers.
+ */
+static int event_logging_read_pfs_clear(void) {
+  int err;
+  struct sbuffer* buf;
+  int cnt = 0;
+
+  err = mutex_lock_interruptible(&pfs_read_lock);
+  if (err)
+    goto mutex_err;
+
+  /* Flush all cpus */
+  flush_all_cpus();
+
+  /* Remove all from full buffers queue. */
+  /* TODO: This removal races with the poke_queues() method, so the
+   * buffer might still sneak into a compression task and then onto
+   * the compressed buffers queue.  It's unlikely so I haven't fixed
+   * that yet.
+   */
+  while( (buf = queue_take_try(&full_buffers)) ) {
+    ++cnt;
+    sbuffer_clear(buf);
+    queue_put(&empty_buffers, buf);
+  }
+
+  /* Return buffer currently being read to empty queue*/ 
+  if (NULL != pfs_read_buffer) {
+    ++cnt;
+    sbuffer_clear(pfs_read_buffer);
+    queue_put(&empty_buffers, pfs_read_buffer);
+    pfs_read_buffer = NULL;
+  }
+
+  /* Remove all from compressed buffers queue */
+  while ( (buf = queue_take_try(&compressed_buffers)) ) {
+    ++cnt;
+    sbuffer_clear(buf);
+    queue_put(&empty_buffers, buf);
+  }
+  printk(KERN_INFO "eventlogging: cleared %d unread buffers", cnt);
+
+  mutex_unlock(&pfs_read_lock);
+  return 0;
+
+ mutex_err:
+  return err;
+}
+
 static int event_logging_read_pfs(char* page, char** start, off_t off, int count, int* eof, void* data) {
   int err, len;
 
@@ -338,6 +390,12 @@ static int event_logging_write_pfs(struct file* file, const char* buffer, unsign
     if (err)
       goto err;
   }
+  /* Process clear command */
+  else if (0 == strcmp(command, PFS_CLEAR) ) {
+    err = event_logging_read_pfs_clear();
+    if (err)
+      goto err;
+  }
   /* Process default command */
   else {
     flush_all_cpus();
-- 
1.9.1


From d03a64e3a5b0eb98aa6a15419733ca0a4b4ff4fc Mon Sep 17 00:00:00 2001
From: yangqi <sloanyang@gmail.com>
Date: Thu, 21 Aug 2014 15:46:09 +0800
Subject: [PATCH 72/72] Fixing bugs

---
 include/linux/wait.h | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/include/linux/wait.h b/include/linux/wait.h
index 301614d..d16a044 100644
--- a/include/linux/wait.h
+++ b/include/linux/wait.h
@@ -31,16 +31,16 @@ extern void event_log_waitqueue_wait(void* wq);
 #define event_log_waitqueue_wait(t) do{;}while(0);
 #endif
 
-#ifdef CONFIG_EVENT_WAITQUEUE_WAIT
+#ifdef CONFIG_EVENT_WAITQUEUE_WAKE
 extern void event_log_waitqueue_wake(void* wq);
 #else
-#define event_log_waitqueue_wait(t) do{;}while(0);
+#define event_log_waitqueue_wake(t) do{;}while(0);
 #endif
 
-#ifdef CONFIG_EVENT_WAITQUEUE_WAIT
+#ifdef CONFIG_EVENT_WAITQUEUE_NOTIFY
 extern void event_log_waitqueue_notify(void* wq, pid_t pid);
 #else
-#define event_log_waitqueue_wait(t, p) do{;}while(0);
+#define event_log_waitqueue_notify(t, p) do{;}while(0);
 #endif
 
 typedef struct __wait_queue wait_queue_t;
-- 
1.9.1

